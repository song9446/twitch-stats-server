import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, W as validate_store, X as component_subscribe, M as onMount, b as svg_element, c as claim_element, f as children, j as detach_dev, l as attr_dev, o as add_location, p as insert_dev, H as empty, e as element, t as text, a as space, h as claim_text, k as claim_space, O as set_style, q as append_dev, G as set_data_dev, m as toggle_class, n as noop, B as destroy_each, r as binding_callbacks, Y as xlink_attr, I as assign, N as exclude_internal_props, P as listen_dev, Z as add_render_callback, _ as create_in_transition, $ as create_out_transition, a0 as createEventDispatcher, v as mount_component, w as transition_in, x as transition_out, y as destroy_component, z as group_outros, T as update_keyed_each, V as outro_and_destroy_block, A as check_outros, a1 as bubble, g as globals, R as run_all, D as create_slot, E as get_slot_changes, F as get_slot_context, a2 as tick, u as bind, C as add_flush_callback } from './index.1eb00da2.js';
import { A as API } from './api.8ae65b01.js';
import { w as writable } from './index.727acde3.js';
import { S as StreamerAutoComplete } from './StreamerAutoComplete.3315e373.js';
import { T as Tip } from './Tip.e61592d1.js';
import { c as findLastIndex, f as faUser_2, e as faKey_2, b as faHistory_2, d as dark_random_color } from './faHistory.56473669.js';
import { f as faUserSecret_2, a as faCommentDots_2, c as cubicOut } from './index.fe26b672.js';

/* src/components/MigrationTimeline.svelte generated by Svelte v3.12.1 */

const file = "src/components/MigrationTimeline.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.data = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.game = list[i];
	return child_ctx;
}

// (7:10) {#if game.box_art_url}
function create_if_block_2(ctx) {
	var image, image_xlink_href_value;

	const block = {
		c: function create() {
			image = svg_element("image");
			this.h();
		},

		l: function claim(nodes) {
			image = claim_element(nodes, "image", { "xlink:href": true, width: true, height: true, x: true, y: true }, true);
			var image_nodes = children(image);

			image_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			xlink_attr(image, "xlink:href", image_xlink_href_value = ctx.game.box_art_url.replace("{width}", ctx.game_box_art_width).replace("{height}", ctx.game_box_art_height));
			attr_dev(image, "width", ctx.game_box_art_width);
			attr_dev(image, "height", ctx.game_box_art_height);
			attr_dev(image, "x", "0");
			attr_dev(image, "y", "0");
			add_location(image, file, 7, 12, 401);
		},

		m: function mount(target, anchor) {
			insert_dev(target, image, anchor);
		},

		p: function update(changed, ctx) {
			if ((changed.games || changed.game_box_art_width || changed.game_box_art_height) && image_xlink_href_value !== (image_xlink_href_value = ctx.game.box_art_url.replace("{width}", ctx.game_box_art_width).replace("{height}", ctx.game_box_art_height))) {
				xlink_attr(image, "xlink:href", image_xlink_href_value);
			}

			if (changed.game_box_art_width) {
				attr_dev(image, "width", ctx.game_box_art_width);
			}

			if (changed.game_box_art_height) {
				attr_dev(image, "height", ctx.game_box_art_height);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(image);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_2.name, type: "if", source: "(7:10) {#if game.box_art_url}", ctx });
	return block;
}

// (5:8) {#each Object.values(games) as game}
function create_each_block_1(ctx) {
	var pattern, pattern_id_value, pattern_y_value;

	var if_block = (ctx.game.box_art_url) && create_if_block_2(ctx);

	const block = {
		c: function create() {
			pattern = svg_element("pattern");
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			pattern = claim_element(nodes, "pattern", { id: true, width: true, height: true, patternUnits: true, y: true }, true);
			var pattern_nodes = children(pattern);

			if (if_block) if_block.l(pattern_nodes);
			pattern_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(pattern, "id", pattern_id_value = "game-box-art-" + ctx.game.id);
			attr_dev(pattern, "width", ctx.game_box_art_width);
			attr_dev(pattern, "height", ctx.game_box_art_height);
			attr_dev(pattern, "patternUnits", "userSpaceOnUse");
			attr_dev(pattern, "y", pattern_y_value = ctx.height*0.25);
			add_location(pattern, file, 5, 8, 216);
		},

		m: function mount(target, anchor) {
			insert_dev(target, pattern, anchor);
			if (if_block) if_block.m(pattern, null);
		},

		p: function update(changed, ctx) {
			if (ctx.game.box_art_url) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					if_block.m(pattern, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if ((changed.games) && pattern_id_value !== (pattern_id_value = "game-box-art-" + ctx.game.id)) {
				attr_dev(pattern, "id", pattern_id_value);
			}

			if (changed.game_box_art_width) {
				attr_dev(pattern, "width", ctx.game_box_art_width);
			}

			if (changed.game_box_art_height) {
				attr_dev(pattern, "height", ctx.game_box_art_height);
			}

			if ((changed.height) && pattern_y_value !== (pattern_y_value = ctx.height*0.25)) {
				attr_dev(pattern, "y", pattern_y_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(pattern);
			}

			if (if_block) if_block.d();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block_1.name, type: "each", source: "(5:8) {#each Object.values(games) as game}", ctx });
	return block;
}

// (67:10) {:else}
function create_else_block(ctx) {
	var path, path_d_value;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			path = claim_element(nodes, "path", { style: true, fill: true, d: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			set_style(path, "stroke-linejoin", "round");
			attr_dev(path, "fill", "#000000");
			attr_dev(path, "d", path_d_value = ctx.data.path);
			add_location(path, file, 67, 12, 3758);
		},

		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},

		p: function update(changed, ctx) {
			if ((changed.data_chunks) && path_d_value !== (path_d_value = ctx.data.path)) {
				attr_dev(path, "d", path_d_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(path);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block.name, type: "else", source: "(67:10) {:else}", ctx });
	return block;
}

// (63:10) {#if data[0] && data[0][5] && data[0][5].game && games[data[0][5].game.id] && data[0][5].game.box_art_url}
function create_if_block_1(ctx) {
	var path, path_d_value;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			path = claim_element(nodes, "path", { style: true, d: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			set_style(path, "fill", "url(#game-box-art-" + ctx.data[0][5].game.id + ")");
			set_style(path, "stroke-linejoin", "round");
			attr_dev(path, "d", path_d_value = ctx.data.path);
			add_location(path, file, 63, 12, 3595);
		},

		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},

		p: function update(changed, ctx) {
			if (changed.data_chunks) {
				set_style(path, "fill", "url(#game-box-art-" + ctx.data[0][5].game.id + ")");
			}

			if ((changed.data_chunks) && path_d_value !== (path_d_value = ctx.data.path)) {
				attr_dev(path, "d", path_d_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(path);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1.name, type: "if", source: "(63:10) {#if data[0] && data[0][5] && data[0][5].game && games[data[0][5].game.id] && data[0][5].game.box_art_url}", ctx });
	return block;
}

// (62:8) {#each data_chunks as data}
function create_each_block(ctx) {
	var if_block_anchor;

	function select_block_type(changed, ctx) {
		if (ctx.data[0] && ctx.data[0][5] && ctx.data[0][5].game && ctx.games[ctx.data[0][5].game.id] && ctx.data[0][5].game.box_art_url) return create_if_block_1;
		return create_else_block;
	}

	var current_block_type = select_block_type(null, ctx);
	var if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block) {
				if_block.p(changed, ctx);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);
				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},

		d: function destroy(detaching) {
			if_block.d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block.name, type: "each", source: "(62:8) {#each data_chunks as data}", ctx });
	return block;
}

// (82:1) {#if tooltip_data}
function create_if_block(ctx) {
	var div7, div6, div0, t0_value = tooltip_data_time_format(ctx.tooltip_data) + "", t0, t1, p0, t2_value = ctx.tooltip_data[5].title + "", t2, t3, div1, svg0, path0, t4, b0, t5_value = ctx.tooltip_data[1] + "", t5, t6, t7, div2, svg1, path1, t8, b1, t9_value = ctx.tooltip_data[1] - ctx.tooltip_data[2] + "", t9, t10, t11, div3, svg2, path2, t12, b2, t13_value = ctx.tooltip_data[2] + "", t13, t14, t15, div4, svg3, path3, t16, b3, t17_value = ctx.tooltip_data[4].toFixed(1) + "", t17, t18, t19, div5, svg4, path4, t20, b4, t21, t22_value = ctx.Math.floor((ctx.tooltip_data[0] - ctx.tooltip_data[5].started_at) / 3600) + "", t22, t23, t24_value = ctx.Math.round((ctx.tooltip_data[0] - ctx.tooltip_data[5].started_at) % 3600 / 60) + "", t24, t25, t26, p1, t27_value = ctx.tooltip_data[5].game != null? ctx.tooltip_data[5].game.name : "" + "", t27, div7_style_value;

	const block = {
		c: function create() {
			div7 = element("div");
			div6 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			p0 = element("p");
			t2 = text(t2_value);
			t3 = space();
			div1 = element("div");
			svg0 = svg_element("svg");
			path0 = svg_element("path");
			t4 = space();
			b0 = element("b");
			t5 = text(t5_value);
			t6 = text("명");
			t7 = space();
			div2 = element("div");
			svg1 = svg_element("svg");
			path1 = svg_element("path");
			t8 = space();
			b1 = element("b");
			t9 = text(t9_value);
			t10 = text("명");
			t11 = space();
			div3 = element("div");
			svg2 = svg_element("svg");
			path2 = svg_element("path");
			t12 = space();
			b2 = element("b");
			t13 = text(t13_value);
			t14 = text("명");
			t15 = space();
			div4 = element("div");
			svg3 = svg_element("svg");
			path3 = svg_element("path");
			t16 = space();
			b3 = element("b");
			t17 = text(t17_value);
			t18 = text("채팅/초");
			t19 = space();
			div5 = element("div");
			svg4 = svg_element("svg");
			path4 = svg_element("path");
			t20 = space();
			b4 = element("b");
			t21 = text("업타임 ");
			t22 = text(t22_value);
			t23 = text("시간");
			t24 = text(t24_value);
			t25 = text("분");
			t26 = space();
			p1 = element("p");
			t27 = text(t27_value);
			this.h();
		},

		l: function claim(nodes) {
			div7 = claim_element(nodes, "DIV", { class: true, style: true }, false);
			var div7_nodes = children(div7);

			div6 = claim_element(div7_nodes, "DIV", { class: true }, false);
			var div6_nodes = children(div6);

			div0 = claim_element(div6_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			t0 = claim_text(div0_nodes, t0_value);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div6_nodes);

			p0 = claim_element(div6_nodes, "P", { class: true, style: true }, false);
			var p0_nodes = children(p0);

			t2 = claim_text(p0_nodes, t2_value);
			p0_nodes.forEach(detach_dev);
			t3 = claim_space(div6_nodes);

			div1 = claim_element(div6_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			svg0 = claim_element(div1_nodes, "svg", { "area-hidden": true, role: true, xmlns: true, viewBox: true, class: true }, true);
			var svg0_nodes = children(svg0);

			path0 = claim_element(svg0_nodes, "path", { fill: true, d: true }, true);
			var path0_nodes = children(path0);

			path0_nodes.forEach(detach_dev);
			svg0_nodes.forEach(detach_dev);
			t4 = claim_space(div1_nodes);

			b0 = claim_element(div1_nodes, "B", {}, false);
			var b0_nodes = children(b0);

			t5 = claim_text(b0_nodes, t5_value);
			t6 = claim_text(b0_nodes, "명");
			b0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t7 = claim_space(div6_nodes);

			div2 = claim_element(div6_nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			svg1 = claim_element(div2_nodes, "svg", { "area-hidden": true, role: true, xmlns: true, viewBox: true, class: true }, true);
			var svg1_nodes = children(svg1);

			path1 = claim_element(svg1_nodes, "path", { fill: true, d: true }, true);
			var path1_nodes = children(path1);

			path1_nodes.forEach(detach_dev);
			svg1_nodes.forEach(detach_dev);
			t8 = claim_space(div2_nodes);

			b1 = claim_element(div2_nodes, "B", {}, false);
			var b1_nodes = children(b1);

			t9 = claim_text(b1_nodes, t9_value);
			t10 = claim_text(b1_nodes, "명");
			b1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t11 = claim_space(div6_nodes);

			div3 = claim_element(div6_nodes, "DIV", { class: true }, false);
			var div3_nodes = children(div3);

			svg2 = claim_element(div3_nodes, "svg", { "area-hidden": true, role: true, xmlns: true, viewBox: true, class: true }, true);
			var svg2_nodes = children(svg2);

			path2 = claim_element(svg2_nodes, "path", { fill: true, d: true }, true);
			var path2_nodes = children(path2);

			path2_nodes.forEach(detach_dev);
			svg2_nodes.forEach(detach_dev);
			t12 = claim_space(div3_nodes);

			b2 = claim_element(div3_nodes, "B", {}, false);
			var b2_nodes = children(b2);

			t13 = claim_text(b2_nodes, t13_value);
			t14 = claim_text(b2_nodes, "명");
			b2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			t15 = claim_space(div6_nodes);

			div4 = claim_element(div6_nodes, "DIV", { class: true, style: true }, false);
			var div4_nodes = children(div4);

			svg3 = claim_element(div4_nodes, "svg", { "area-hidden": true, role: true, xmlns: true, viewBox: true, class: true }, true);
			var svg3_nodes = children(svg3);

			path3 = claim_element(svg3_nodes, "path", { fill: true, d: true }, true);
			var path3_nodes = children(path3);

			path3_nodes.forEach(detach_dev);
			svg3_nodes.forEach(detach_dev);
			t16 = claim_space(div4_nodes);

			b3 = claim_element(div4_nodes, "B", {}, false);
			var b3_nodes = children(b3);

			t17 = claim_text(b3_nodes, t17_value);
			t18 = claim_text(b3_nodes, "채팅/초");
			b3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			t19 = claim_space(div6_nodes);

			div5 = claim_element(div6_nodes, "DIV", { class: true }, false);
			var div5_nodes = children(div5);

			svg4 = claim_element(div5_nodes, "svg", { "area-hidden": true, role: true, xmlns: true, viewBox: true, class: true }, true);
			var svg4_nodes = children(svg4);

			path4 = claim_element(svg4_nodes, "path", { fill: true, d: true }, true);
			var path4_nodes = children(path4);

			path4_nodes.forEach(detach_dev);
			svg4_nodes.forEach(detach_dev);
			t20 = claim_space(div5_nodes);

			b4 = claim_element(div5_nodes, "B", {}, false);
			var b4_nodes = children(b4);

			t21 = claim_text(b4_nodes, "업타임 ");
			t22 = claim_text(b4_nodes, t22_value);
			t23 = claim_text(b4_nodes, "시간");
			t24 = claim_text(b4_nodes, t24_value);
			t25 = claim_text(b4_nodes, "분");
			b4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			t26 = claim_space(div6_nodes);

			p1 = claim_element(div6_nodes, "P", { class: true, style: true }, false);
			var p1_nodes = children(p1);

			t27 = claim_text(p1_nodes, t27_value);
			p1_nodes.forEach(detach_dev);
			div6_nodes.forEach(detach_dev);
			div7_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div0, "class", "text-gray-600 text-xs font-semibold tracking-wide");
			add_location(div0, file, 84, 7, 4465);
			attr_dev(p0, "class", "break-all mt-1 text-gray italic tracking-tight");
			set_style(p0, "font-size", "0.5rem");
			add_location(p0, file, 87, 14, 4606);
			attr_dev(path0, "fill", "currentColor");
			attr_dev(path0, "d", faUser_2.icon[4]);
			add_location(path0, file, 92, 20, 5036);
			attr_dev(svg0, "area-hidden", "true");
			attr_dev(svg0, "role", "img");
			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg0, "viewBox", "0 0 " + faUser_2.icon[0] + " " + faUser_2.icon[1]);
			attr_dev(svg0, "class", "w-4 h-4 mr-2 overflow-visible inline-block");
			add_location(svg0, file, 91, 18, 4846);
			add_location(b0, file, 94, 18, 5128);
			attr_dev(div1, "class", "mt-1 flex flex-row flex-wrap items-center text-gray-900");
			add_location(div1, file, 90, 16, 4758);
			attr_dev(path1, "fill", "currentColor");
			attr_dev(path1, "d", faUserSecret_2.icon[4]);
			add_location(path1, file, 98, 20, 5486);
			attr_dev(svg1, "area-hidden", "true");
			attr_dev(svg1, "role", "img");
			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg1, "viewBox", "0 0 " + faUserSecret_2.icon[0] + " " + faUserSecret_2.icon[1]);
			attr_dev(svg1, "class", "w-3 h-3 mr-2 overflow-visible inline-block");
			add_location(svg1, file, 97, 18, 5284);
			add_location(b1, file, 100, 18, 5584);
			attr_dev(div2, "class", "flex flex-row flex-wrap items-center text-gray-600 text-xs");
			add_location(div2, file, 96, 16, 5193);
			attr_dev(path2, "fill", "currentColor");
			attr_dev(path2, "d", faKey_2.icon[4]);
			add_location(path2, file, 104, 20, 5948);
			attr_dev(svg2, "area-hidden", "true");
			attr_dev(svg2, "role", "img");
			attr_dev(svg2, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg2, "viewBox", "0 0 " + faKey_2.icon[0] + " " + faKey_2.icon[1]);
			attr_dev(svg2, "class", "w-3 h-3 mr-2 overflow-visible inline-block");
			add_location(svg2, file, 103, 18, 5760);
			add_location(b2, file, 106, 18, 6039);
			attr_dev(div3, "class", "flex flex-row flex-wrap items-center text-yellow-700 text-xs");
			add_location(div3, file, 102, 16, 5667);
			attr_dev(path3, "fill", "currentColor");
			attr_dev(path3, "d", faCommentDots_2.icon[4]);
			add_location(path3, file, 110, 20, 6405);
			attr_dev(svg3, "area-hidden", "true");
			attr_dev(svg3, "role", "img");
			attr_dev(svg3, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg3, "viewBox", "0 0 " + faCommentDots_2.icon[0] + " " + faCommentDots_2.icon[1]);
			attr_dev(svg3, "class", "w-4 h-4 mr-2 overflow-visible inline-block");
			add_location(svg3, file, 109, 18, 6201);
			add_location(b3, file, 112, 18, 6504);
			attr_dev(div4, "class", "mt-1 flex flex-row flex-wrap items-center");
			set_style(div4, "color", "#FF6F61");
			add_location(div4, file, 108, 16, 6104);
			attr_dev(path4, "fill", "currentColor");
			attr_dev(path4, "d", faHistory_2.icon[4]);
			add_location(path4, file, 116, 20, 6869);
			attr_dev(svg4, "area-hidden", "true");
			attr_dev(svg4, "role", "img");
			attr_dev(svg4, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg4, "viewBox", "0 0 " + faHistory_2.icon[0] + " " + faHistory_2.icon[1]);
			attr_dev(svg4, "class", "w-4 h-4 mr-2 overflow-visible inline-block");
			add_location(svg4, file, 115, 18, 6673);
			add_location(b4, file, 118, 18, 6964);
			attr_dev(div5, "class", "mt-1 flex flex-row flex-wrap items-center text-purple-600");
			add_location(div5, file, 114, 16, 6583);
			attr_dev(p1, "class", "mt-2 text-xs px-1 border rounded-full text-white text-center");
			set_style(p1, "background-color", dark_random_color(ctx.tooltip_data[5].game && ctx.tooltip_data[5].game.id || 0));
			add_location(p1, file, 120, 14, 7155);
			attr_dev(div6, "class", "flex flex-col font-sans custom-tooltip p-3 w-48 flex-unwrap");
			add_location(div6, file, 83, 12, 4383);
			attr_dev(div7, "class", "absolute bg-white opacity-75 z-50");
			attr_dev(div7, "style", div7_style_value = "" + (ctx.tooltip_x < ctx.width*0.5? 'left:' + (ctx.tooltip_x+5) + 'px': 'right:' + ((ctx.width-ctx.tooltip_x)+5) + 'px') + "; top: " + (ctx.tooltip_y + 5) + "px");
			add_location(div7, file, 82, 4, 4193);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div7, anchor);
			append_dev(div7, div6);
			append_dev(div6, div0);
			append_dev(div0, t0);
			append_dev(div6, t1);
			append_dev(div6, p0);
			append_dev(p0, t2);
			append_dev(div6, t3);
			append_dev(div6, div1);
			append_dev(div1, svg0);
			append_dev(svg0, path0);
			append_dev(div1, t4);
			append_dev(div1, b0);
			append_dev(b0, t5);
			append_dev(b0, t6);
			append_dev(div6, t7);
			append_dev(div6, div2);
			append_dev(div2, svg1);
			append_dev(svg1, path1);
			append_dev(div2, t8);
			append_dev(div2, b1);
			append_dev(b1, t9);
			append_dev(b1, t10);
			append_dev(div6, t11);
			append_dev(div6, div3);
			append_dev(div3, svg2);
			append_dev(svg2, path2);
			append_dev(div3, t12);
			append_dev(div3, b2);
			append_dev(b2, t13);
			append_dev(b2, t14);
			append_dev(div6, t15);
			append_dev(div6, div4);
			append_dev(div4, svg3);
			append_dev(svg3, path3);
			append_dev(div4, t16);
			append_dev(div4, b3);
			append_dev(b3, t17);
			append_dev(b3, t18);
			append_dev(div6, t19);
			append_dev(div6, div5);
			append_dev(div5, svg4);
			append_dev(svg4, path4);
			append_dev(div5, t20);
			append_dev(div5, b4);
			append_dev(b4, t21);
			append_dev(b4, t22);
			append_dev(b4, t23);
			append_dev(b4, t24);
			append_dev(b4, t25);
			append_dev(div6, t26);
			append_dev(div6, p1);
			append_dev(p1, t27);
		},

		p: function update(changed, ctx) {
			if ((changed.tooltip_data) && t0_value !== (t0_value = tooltip_data_time_format(ctx.tooltip_data) + "")) {
				set_data_dev(t0, t0_value);
			}

			if ((changed.tooltip_data) && t2_value !== (t2_value = ctx.tooltip_data[5].title + "")) {
				set_data_dev(t2, t2_value);
			}

			if ((changed.tooltip_data) && t5_value !== (t5_value = ctx.tooltip_data[1] + "")) {
				set_data_dev(t5, t5_value);
			}

			if ((changed.tooltip_data) && t9_value !== (t9_value = ctx.tooltip_data[1] - ctx.tooltip_data[2] + "")) {
				set_data_dev(t9, t9_value);
			}

			if ((changed.tooltip_data) && t13_value !== (t13_value = ctx.tooltip_data[2] + "")) {
				set_data_dev(t13, t13_value);
			}

			if ((changed.tooltip_data) && t17_value !== (t17_value = ctx.tooltip_data[4].toFixed(1) + "")) {
				set_data_dev(t17, t17_value);
			}

			if ((changed.tooltip_data) && t22_value !== (t22_value = ctx.Math.floor((ctx.tooltip_data[0] - ctx.tooltip_data[5].started_at) / 3600) + "")) {
				set_data_dev(t22, t22_value);
			}

			if ((changed.tooltip_data) && t24_value !== (t24_value = ctx.Math.round((ctx.tooltip_data[0] - ctx.tooltip_data[5].started_at) % 3600 / 60) + "")) {
				set_data_dev(t24, t24_value);
			}

			if ((changed.tooltip_data) && t27_value !== (t27_value = ctx.tooltip_data[5].game != null? ctx.tooltip_data[5].game.name : "" + "")) {
				set_data_dev(t27, t27_value);
			}

			if (changed.tooltip_data) {
				set_style(p1, "background-color", dark_random_color(ctx.tooltip_data[5].game && ctx.tooltip_data[5].game.id || 0));
			}

			if ((changed.tooltip_x || changed.width || changed.tooltip_y) && div7_style_value !== (div7_style_value = "" + (ctx.tooltip_x < ctx.width*0.5? 'left:' + (ctx.tooltip_x+5) + 'px': 'right:' + ((ctx.width-ctx.tooltip_x)+5) + 'px') + "; top: " + (ctx.tooltip_y + 5) + "px")) {
				attr_dev(div7, "style", div7_style_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div7);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block.name, type: "if", source: "(82:1) {#if tooltip_data}", ctx });
	return block;
}

function create_fragment(ctx) {
	var div1, div0, svg_1, defs, marker, path0, g0, path1, path1_d_value, g1, line, t;

	let each_value_1 = Object.values(ctx.games);

	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let each_value = ctx.data_chunks;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	var if_block = (ctx.tooltip_data) && create_if_block(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			svg_1 = svg_element("svg");
			defs = svg_element("defs");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			marker = svg_element("marker");
			path0 = svg_element("path");
			g0 = svg_element("g");
			path1 = svg_element("path");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			g1 = svg_element("g");
			line = svg_element("line");
			t = space();
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			div0 = claim_element(div1_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			svg_1 = claim_element(div0_nodes, "svg", { class: true, width: true, height: true }, true);
			var svg_1_nodes = children(svg_1);

			defs = claim_element(svg_1_nodes, "defs", {}, true);
			var defs_nodes = children(defs);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].l(defs_nodes);
			}

			marker = claim_element(defs_nodes, "marker", { id: true, markerWidth: true, markerHeight: true, refX: true, refY: true, orient: true }, true);
			var marker_nodes = children(marker);

			path0 = claim_element(marker_nodes, "path", { d: true, fill: true }, true);
			var path0_nodes = children(path0);

			path0_nodes.forEach(detach_dev);
			marker_nodes.forEach(detach_dev);
			defs_nodes.forEach(detach_dev);

			g0 = claim_element(svg_1_nodes, "g", { stroke: true, "stroke-width": true }, true);
			var g0_nodes = children(g0);

			path1 = claim_element(g0_nodes, "path", { d: true, fill: true, "marker-end": true }, true);
			var path1_nodes = children(path1);

			path1_nodes.forEach(detach_dev);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(g0_nodes);
			}

			g0_nodes.forEach(detach_dev);

			g1 = claim_element(svg_1_nodes, "g", { "shape-rendering": true }, true);
			var g1_nodes = children(g1);

			line = claim_element(g1_nodes, "line", { x1: true, x2: true, y1: true, y2: true, stroke: true, "stroke-width": true, "stroke-dasharray": true }, true);
			var line_nodes = children(line);

			line_nodes.forEach(detach_dev);
			g1_nodes.forEach(detach_dev);
			svg_1_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t = claim_space(div1_nodes);
			if (if_block) if_block.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(path0, "d", "M0,0 V8 L4,4 Z");
			attr_dev(path0, "fill", "#444");
			add_location(path0, file, 14, 10, 790);
			attr_dev(marker, "id", "bighead");
			attr_dev(marker, "markerWidth", "4");
			attr_dev(marker, "markerHeight", "8");
			attr_dev(marker, "refX", "0.1");
			attr_dev(marker, "refY", "4");
			attr_dev(marker, "orient", "auto");
			add_location(marker, file, 11, 8, 652);
			add_location(defs, file, 3, 6, 156);
			attr_dev(path1, "d", path1_d_value = "M0," + ctx.height*0.5 + " L" + (ctx.width - 4) + "," + ctx.height*0.5);
			attr_dev(path1, "fill", "none");
			attr_dev(path1, "marker-end", "url(#bighead)");
			add_location(path1, file, 56, 6, 3300);
			attr_dev(g0, "stroke", "#A0AEC0");
			attr_dev(g0, "stroke-width", "1.0");
			add_location(g0, file, 55, 6, 3256);
			attr_dev(line, "x1", ctx.tooltip_x);
			attr_dev(line, "x2", ctx.tooltip_x);
			attr_dev(line, "y1", 0);
			attr_dev(line, "y2", ctx.height);
			attr_dev(line, "stroke", "#000000");
			attr_dev(line, "stroke-width", "0.5");
			attr_dev(line, "stroke-dasharray", "4 1");
			toggle_class(line, "hidden", ctx.tooltip_data == null);
			add_location(line, file, 75, 8, 3965);
			attr_dev(g1, "shape-rendering", "crispEdges");
			add_location(g1, file, 74, 6, 3924);
			attr_dev(svg_1, "class", "flex-grow border-gray-900 w-full");
			attr_dev(svg_1, "width", ctx.width);
			attr_dev(svg_1, "height", ctx.height);
			add_location(svg_1, file, 2, 4, 57);
			attr_dev(div0, "class", "w-full");
			add_location(div0, file, 1, 2, 32);
			attr_dev(div1, "class", "w-full relative");
			add_location(div1, file, 0, 0, 0);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, svg_1);
			append_dev(svg_1, defs);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(defs, null);
			}

			append_dev(defs, marker);
			append_dev(marker, path0);
			append_dev(svg_1, g0);
			append_dev(g0, path1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(g0, null);
			}

			append_dev(svg_1, g1);
			append_dev(g1, line);
			ctx.svg_1_binding(svg_1);
			append_dev(div1, t);
			if (if_block) if_block.m(div1, null);
		},

		p: function update(changed, ctx) {
			if (changed.games || changed.game_box_art_width || changed.game_box_art_height || changed.height) {
				each_value_1 = Object.values(ctx.games);

				let i;
				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(changed, child_ctx);
					} else {
						each_blocks_1[i] = create_each_block_1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(defs, marker);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}
				each_blocks_1.length = each_value_1.length;
			}

			if ((changed.height || changed.width) && path1_d_value !== (path1_d_value = "M0," + ctx.height*0.5 + " L" + (ctx.width - 4) + "," + ctx.height*0.5)) {
				attr_dev(path1, "d", path1_d_value);
			}

			if (changed.data_chunks || changed.games) {
				each_value = ctx.data_chunks;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(g0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}

			if (changed.tooltip_x) {
				attr_dev(line, "x1", ctx.tooltip_x);
				attr_dev(line, "x2", ctx.tooltip_x);
			}

			if (changed.height) {
				attr_dev(line, "y2", ctx.height);
			}

			if (changed.tooltip_data) {
				toggle_class(line, "hidden", ctx.tooltip_data == null);
			}

			if (changed.width) {
				attr_dev(svg_1, "width", ctx.width);
			}

			if (changed.height) {
				attr_dev(svg_1, "height", ctx.height);
			}

			if (ctx.tooltip_data) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			destroy_each(each_blocks_1, detaching);

			destroy_each(each_blocks, detaching);

			ctx.svg_1_binding(null);
			if (if_block) if_block.d();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment.name, type: "component", source: "", ctx });
	return block;
}

let max_y_axis = writable(0);
let max_y_axis_right = writable(0);

	function tooltip_data_time_format(data) {
		let d = new Date(data[0]*1000),
				h = d.getHours(), m = d.getMinutes();
		return `${h<12? "AM": "PM"} ${("0"+(h>12? h-12: h)).slice(-2)}:${("0"+m).slice(-2)}`;
	}

function instance($$self, $$props, $$invalidate) {
	let $max_y_axis, $max_y_axis_right;

	validate_store(max_y_axis, 'max_y_axis');
	component_subscribe($$self, max_y_axis, $$value => { $max_y_axis = $$value; $$invalidate('$max_y_axis', $max_y_axis); });
	validate_store(max_y_axis_right, 'max_y_axis_right');
	component_subscribe($$self, max_y_axis_right, $$value => { $max_y_axis_right = $$value; $$invalidate('$max_y_axis_right', $max_y_axis_right); });

	

let { date, streamer } = $$props;



let tooltip_x=0, 
		tooltip_y=0, 
		tooltip_data=null;

let today = new Date(date); today.setHours(0,0,0,0);
let to = new Date(today.getTime() + 1000*60*60*24);
let from = today;

let { height = 100 } = $$props;
let width = 500;

let games = {};
let data_chunks = [];
let last_data = null;

let svg;

let to_timestamp = to.getTime()/1000;
let from_timestamp = from.getTime()/1000;
function xscale(x) {
  return width * (x - from_timestamp) / (24*60*60);
}
function ixscale(x) {
  return x / width * (24*60*60) + from_timestamp
}
function yscale(x) {
  return height * ($max_y_axis - x) / $max_y_axis;
}
function update_path() {
  for(let data of data_chunks){
    data.path = 
      `M${xscale(data[0][0])},${height*0.5}` +
      data.map(d=>
        `L${xscale(d[0])},${yscale(d[2])*0.5}`
      ).join("") + 
      data.map((_, i, arr) =>
        `L${xscale(arr[arr.length - i - 1][0])},${yscale(arr[arr.length - i - 1][2])*-0.5 + height*1.0}`
      ).join("") + 
      `L${xscale(data[0][0])},${height*0.5}`;
  }
  $$invalidate('data_chunks', data_chunks);
}
let last_max_y_axis = $max_y_axis;
let last_max_y_axis_right = $max_y_axis_right;

let now_x = null;

onMount(async ()=> {
	$$invalidate('width', width = svg.getBoundingClientRect().width);
  now_x = xscale(new Date().getTime()/1000);
  if(streamer == null)
    return;
  let {stream_changes, stream_metadata_changes} = await API.timeline(streamer.id, from, to);
  last_data = stream_changes[stream_changes.length-1];
  max_y_axis.update(x => Math.max(x, ...stream_changes.map(d=>Math.max(d[2]))));
  max_y_axis_right.update(x => Math.max(x, ...stream_changes.map(d=>d[4])));
  let j=0;
  let metadatas = stream_changes.map(x => {
    while(stream_metadata_changes.length > j && x[0] >= stream_metadata_changes[j].time) ++j;
    if(x[1] === null) return null;
    else if(j>0) return stream_metadata_changes[j-1];
    else return null;
  });
  stream_changes = stream_changes.map((d, i)=>[...d, metadatas[i]]);
  let sm_n = 20, chatting_speed_sm = [stream_changes.slice(0, sm_n).reduce((a,b)=>a+b[4], 0)/sm_n];
  for(let i=sm_n, l=stream_changes.length, sm=chatting_speed_sm[0]; i<l; ++i){
    sm = sm + (stream_changes[i][4] - stream_changes[i-sm_n][4])/sm_n;
    chatting_speed_sm.push(sm);
  }
  for(let i=0, sm=0; i<Math.min(sm_n, stream_changes.length); ++i){
    sm = sm*i/(i+1) + stream_changes[i][4]/(i+1);
    stream_changes[i][4] = sm;
  }
  for(let i=0, l=chatting_speed_sm.length; i<l; ++i)
    stream_changes[Math.min(stream_changes.length-1, i + sm_n-1)][4] = chatting_speed_sm[i];

	$$invalidate('svg', svg.onmousemove = function(e){
		let x = e.clientX - svg.getBoundingClientRect().x, 
				y = e.clientY - svg.getBoundingClientRect().y;
    $$invalidate('tooltip_x', tooltip_x = x); 
    $$invalidate('tooltip_y', tooltip_y = y);
    let target_date = ixscale(x);
    let right_index = stream_changes.findIndex(d => d[0] >= target_date),
        left_index = findLastIndex(stream_changes, d => d[0] <= target_date);
    let nearest_index; 
    if(right_index >= 0 && left_index >= 0) 
      nearest_index = Math.abs(stream_changes[left_index][0] - target_date) <= Math.abs(stream_changes[right_index][0] - target_date)?
        left_index: right_index;
    else if(right_index >= 0)
      nearest_index = right_index;
    else if(left_index >= 0)
      nearest_index = left_index;
    else {
      $$invalidate('tooltip_data', tooltip_data = null);
      return;
    }

    if(Math.abs(stream_changes[nearest_index][0] - target_date) < 60*60) {// || right_index != 0 && metadatas[right_index].started_at == metadatas[right_index-1].started_at) {
      $$invalidate('tooltip_data', tooltip_data = stream_changes[nearest_index]);
    }
    else 
      $$invalidate('tooltip_data', tooltip_data = null);
  }, svg);
  $$invalidate('svg', svg.onmouseleave = function(e){
    $$invalidate('tooltip_data', tooltip_data = null);
  }, svg);
  data_chunks.push([]);
	for(let i=0, l=stream_changes.length, j=0; i<l; ++i) {
   	  if(i>0 && metadatas[i] != metadatas[i-1] && 
          ((metadatas[i] == null || metadatas[i-1] == null) || 
            metadatas[i].started_at != metadatas[i-1].started_at || 
            (metadatas[i].game && metadatas[i].game.id) != (metadatas[i-1].game && metadatas[i-1].game.id) ||
            metadatas[i].title != metadatas[i-1].title)){
        ++j;
        data_chunks.push([]);
        if(metadatas[i] && metadatas[i-1] && metadatas[i].started_at == metadatas[i-1].started_at){
          let mid = stream_changes[i].slice(0, 5).map((d, j) => Math.floor((d + stream_changes[i-1][j])*0.5));
          data_chunks[j-1].push([...mid, metadatas[i-1]]);
          data_chunks[j].push([...mid, metadatas[i]]);
        }
      }
      data_chunks[j].push(stream_changes[i]);
  }
  update_path();
  $$invalidate('data_chunks', data_chunks);
  for(let data of data_chunks){
  	if(data[0] == null || data[0][5] == null || data[0][5].game == null) continue;
		$$invalidate('games', games[data[0][5].game.id] = data[0][5].game, games);
	}
});

	const writable_props = ['date', 'streamer', 'height'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<MigrationTimeline> was created with unknown prop '${key}'`);
	});

	function svg_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('svg', svg = $$value);
		});
	}

	$$self.$set = $$props => {
		if ('date' in $$props) $$invalidate('date', date = $$props.date);
		if ('streamer' in $$props) $$invalidate('streamer', streamer = $$props.streamer);
		if ('height' in $$props) $$invalidate('height', height = $$props.height);
	};

	$$self.$capture_state = () => {
		return { max_y_axis, max_y_axis_right, date, streamer, tooltip_x, tooltip_y, tooltip_data, today, to, from, height, width, games, data_chunks, last_data, svg, to_timestamp, from_timestamp, last_max_y_axis, last_max_y_axis_right, now_x, game_box_art_width, game_box_art_height, $max_y_axis, $max_y_axis_right };
	};

	$$self.$inject_state = $$props => {
		if ('date' in $$props) $$invalidate('date', date = $$props.date);
		if ('streamer' in $$props) $$invalidate('streamer', streamer = $$props.streamer);
		if ('tooltip_x' in $$props) $$invalidate('tooltip_x', tooltip_x = $$props.tooltip_x);
		if ('tooltip_y' in $$props) $$invalidate('tooltip_y', tooltip_y = $$props.tooltip_y);
		if ('tooltip_data' in $$props) $$invalidate('tooltip_data', tooltip_data = $$props.tooltip_data);
		if ('today' in $$props) today = $$props.today;
		if ('to' in $$props) to = $$props.to;
		if ('from' in $$props) from = $$props.from;
		if ('height' in $$props) $$invalidate('height', height = $$props.height);
		if ('width' in $$props) $$invalidate('width', width = $$props.width);
		if ('games' in $$props) $$invalidate('games', games = $$props.games);
		if ('data_chunks' in $$props) $$invalidate('data_chunks', data_chunks = $$props.data_chunks);
		if ('last_data' in $$props) last_data = $$props.last_data;
		if ('svg' in $$props) $$invalidate('svg', svg = $$props.svg);
		if ('to_timestamp' in $$props) to_timestamp = $$props.to_timestamp;
		if ('from_timestamp' in $$props) from_timestamp = $$props.from_timestamp;
		if ('last_max_y_axis' in $$props) $$invalidate('last_max_y_axis', last_max_y_axis = $$props.last_max_y_axis);
		if ('last_max_y_axis_right' in $$props) $$invalidate('last_max_y_axis_right', last_max_y_axis_right = $$props.last_max_y_axis_right);
		if ('now_x' in $$props) now_x = $$props.now_x;
		if ('game_box_art_width' in $$props) $$invalidate('game_box_art_width', game_box_art_width = $$props.game_box_art_width);
		if ('game_box_art_height' in $$props) $$invalidate('game_box_art_height', game_box_art_height = $$props.game_box_art_height);
		if ('$max_y_axis' in $$props) max_y_axis.set($max_y_axis);
		if ('$max_y_axis_right' in $$props) max_y_axis_right.set($max_y_axis_right);
	};

	let game_box_art_width, game_box_art_height;

	$$self.$$.update = ($$dirty = { height: 1, data_chunks: 1, last_max_y_axis: 1, $max_y_axis: 1, last_max_y_axis_right: 1, $max_y_axis_right: 1 }) => {
		if ($$dirty.height) { $$invalidate('game_box_art_width', game_box_art_width = height*0.4); }
		if ($$dirty.height) { $$invalidate('game_box_art_height', game_box_art_height = height*0.5); }
		if ($$dirty.data_chunks || $$dirty.last_max_y_axis || $$dirty.$max_y_axis || $$dirty.last_max_y_axis_right || $$dirty.$max_y_axis_right) { if(data_chunks && ((last_max_y_axis != $max_y_axis) || (last_max_y_axis_right != $max_y_axis_right))) {
      $$invalidate('last_max_y_axis', last_max_y_axis = $max_y_axis);
      $$invalidate('last_max_y_axis_right', last_max_y_axis_right = $max_y_axis_right);
      update_path();
    } }
	};

	return {
		date,
		streamer,
		tooltip_x,
		tooltip_y,
		tooltip_data,
		height,
		width,
		games,
		data_chunks,
		svg,
		game_box_art_width,
		game_box_art_height,
		Math,
		svg_1_binding
	};
}

class MigrationTimeline extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["date", "streamer", "height"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "MigrationTimeline", options, id: create_fragment.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.date === undefined && !('date' in props)) {
			console.warn("<MigrationTimeline> was created without expected prop 'date'");
		}
		if (ctx.streamer === undefined && !('streamer' in props)) {
			console.warn("<MigrationTimeline> was created without expected prop 'streamer'");
		}
	}

	get date() {
		throw new Error("<MigrationTimeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set date(value) {
		throw new Error("<MigrationTimeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get streamer() {
		throw new Error("<MigrationTimeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set streamer(value) {
		throw new Error("<MigrationTimeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<MigrationTimeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<MigrationTimeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Migrations.svelte generated by Svelte v3.12.1 */

const file$1 = "src/components/Migrations.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.path = list[i];
	return child_ctx;
}

// (10:4) {#each paths as path}
function create_each_block$1(ctx) {
	var path, path_stroke_width_value, path_d_value, text_1, t0_value = ctx.path.count + "", t0, t1, text_1_font_size_value, text_1_transform_value;

	const block = {
		c: function create() {
			path = svg_element("path");
			text_1 = svg_element("text");
			t0 = text(t0_value);
			t1 = text("명\n      ");
			this.h();
		},

		l: function claim(nodes) {
			path = claim_element(nodes, "path", { "marker-end": true, "stroke-width": true, fill: true, stroke: true, d: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach_dev);

			text_1 = claim_element(nodes, "text", { fill: true, "font-size": true, "font-family": true, transform: true, "text-anchor": true }, true);
			var text_1_nodes = children(text_1);

			t0 = claim_text(text_1_nodes, t0_value);
			t1 = claim_text(text_1_nodes, "명\n      ");
			text_1_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(path, "marker-end", "url(#head)");
			attr_dev(path, "stroke-width", path_stroke_width_value = ctx.path.width);
			attr_dev(path, "fill", "none");
			attr_dev(path, "stroke", "#718096");
			attr_dev(path, "d", path_d_value = ctx.path.path);
			add_location(path, file$1, 10, 4, 385);
			attr_dev(text_1, "fill", "#718096");
			attr_dev(text_1, "font-size", text_1_font_size_value = 10 + ctx.path.width*2);
			attr_dev(text_1, "font-family", "Arial");
			attr_dev(text_1, "transform", text_1_transform_value = "translate(" + (ctx.path.x + ctx.path.width) + ", " + ctx.height*0.5 + ") rotate(90)");
			attr_dev(text_1, "text-anchor", "middle");
			add_location(text_1, file$1, 17, 6, 536);
		},

		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
			insert_dev(target, text_1, anchor);
			append_dev(text_1, t0);
			append_dev(text_1, t1);
		},

		p: function update(changed, ctx) {
			if ((changed.paths) && path_stroke_width_value !== (path_stroke_width_value = ctx.path.width)) {
				attr_dev(path, "stroke-width", path_stroke_width_value);
			}

			if ((changed.paths) && path_d_value !== (path_d_value = ctx.path.path)) {
				attr_dev(path, "d", path_d_value);
			}

			if ((changed.paths) && t0_value !== (t0_value = ctx.path.count + "")) {
				set_data_dev(t0, t0_value);
			}

			if ((changed.paths) && text_1_font_size_value !== (text_1_font_size_value = 10 + ctx.path.width*2)) {
				attr_dev(text_1, "font-size", text_1_font_size_value);
			}

			if ((changed.paths || changed.height) && text_1_transform_value !== (text_1_transform_value = "translate(" + (ctx.path.x + ctx.path.width) + ", " + ctx.height*0.5 + ") rotate(90)")) {
				attr_dev(text_1, "transform", text_1_transform_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(path);
				detach_dev(text_1);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block$1.name, type: "each", source: "(10:4) {#each paths as path}", ctx });
	return block;
}

function create_fragment$1(ctx) {
	var svg_1, defs, marker, path, g, svg_1_class_value, svg_1_viewBox_value;

	let each_value = ctx.paths;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			svg_1 = svg_element("svg");
			defs = svg_element("defs");
			marker = svg_element("marker");
			path = svg_element("path");
			g = svg_element("g");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
			this.h();
		},

		l: function claim(nodes) {
			svg_1 = claim_element(nodes, "svg", { class: true, viewBox: true, width: true, height: true }, true);
			var svg_1_nodes = children(svg_1);

			defs = claim_element(svg_1_nodes, "defs", {}, true);
			var defs_nodes = children(defs);

			marker = claim_element(defs_nodes, "marker", { id: true, markerWidth: true, markerHeight: true, refX: true, refY: true, orient: true }, true);
			var marker_nodes = children(marker);

			path = claim_element(marker_nodes, "path", { d: true, fill: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach_dev);
			marker_nodes.forEach(detach_dev);
			defs_nodes.forEach(detach_dev);

			g = claim_element(svg_1_nodes, "g", {}, true);
			var g_nodes = children(g);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(g_nodes);
			}

			g_nodes.forEach(detach_dev);
			svg_1_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(path, "d", "M0,0 V4 L2,2 Z");
			attr_dev(path, "fill", "#718096");
			add_location(path, file$1, 5, 6, 282);
			attr_dev(marker, "id", "head");
			attr_dev(marker, "markerWidth", "2");
			attr_dev(marker, "markerHeight", "4");
			attr_dev(marker, "refX", "0.1");
			attr_dev(marker, "refY", "2");
			attr_dev(marker, "orient", "auto");
			add_location(marker, file$1, 2, 4, 159);
			add_location(defs, file$1, 1, 2, 148);
			add_location(g, file$1, 8, 2, 351);
			attr_dev(svg_1, "class", svg_1_class_value = "w-full overflow-visible opacity-50 " + ctx.$$props.class);
			attr_dev(svg_1, "viewBox", svg_1_viewBox_value = "0 0 " + ctx.width + " " + ctx.height);
			attr_dev(svg_1, "width", ctx.width);
			attr_dev(svg_1, "height", ctx.height);
			add_location(svg_1, file$1, 0, 0, 0);
		},

		m: function mount(target, anchor) {
			insert_dev(target, svg_1, anchor);
			append_dev(svg_1, defs);
			append_dev(defs, marker);
			append_dev(marker, path);
			append_dev(svg_1, g);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(g, null);
			}

			ctx.svg_1_binding(svg_1);
		},

		p: function update(changed, ctx) {
			if (changed.paths || changed.height) {
				each_value = ctx.paths;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(g, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}

			if ((changed.$$props) && svg_1_class_value !== (svg_1_class_value = "w-full overflow-visible opacity-50 " + ctx.$$props.class)) {
				attr_dev(svg_1, "class", svg_1_class_value);
			}

			if ((changed.width || changed.height) && svg_1_viewBox_value !== (svg_1_viewBox_value = "0 0 " + ctx.width + " " + ctx.height)) {
				attr_dev(svg_1, "viewBox", svg_1_viewBox_value);
			}

			if (changed.width) {
				attr_dev(svg_1, "width", ctx.width);
			}

			if (changed.height) {
				attr_dev(svg_1, "height", ctx.height);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg_1);
			}

			destroy_each(each_blocks, detaching);

			ctx.svg_1_binding(null);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$1.name, type: "component", source: "", ctx });
	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	
  let width = 1;
  let svg;
  let { height = 100, timeline_height = 150, migrations, id1, id2 } = $$props;
  let today;
  onMount(()=> {
    $$invalidate('width', width = svg.getBoundingClientRect().width);
  });

	function svg_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('svg', svg = $$value);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('height' in $$new_props) $$invalidate('height', height = $$new_props.height);
		if ('timeline_height' in $$new_props) $$invalidate('timeline_height', timeline_height = $$new_props.timeline_height);
		if ('migrations' in $$new_props) $$invalidate('migrations', migrations = $$new_props.migrations);
		if ('id1' in $$new_props) $$invalidate('id1', id1 = $$new_props.id1);
		if ('id2' in $$new_props) $$invalidate('id2', id2 = $$new_props.id2);
	};

	$$self.$capture_state = () => {
		return { width, svg, height, timeline_height, migrations, id1, id2, today, paths };
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('width' in $$props) $$invalidate('width', width = $$new_props.width);
		if ('svg' in $$props) $$invalidate('svg', svg = $$new_props.svg);
		if ('height' in $$props) $$invalidate('height', height = $$new_props.height);
		if ('timeline_height' in $$props) $$invalidate('timeline_height', timeline_height = $$new_props.timeline_height);
		if ('migrations' in $$props) $$invalidate('migrations', migrations = $$new_props.migrations);
		if ('id1' in $$props) $$invalidate('id1', id1 = $$new_props.id1);
		if ('id2' in $$props) $$invalidate('id2', id2 = $$new_props.id2);
		if ('today' in $$props) $$invalidate('today', today = $$new_props.today);
		if ('paths' in $$props) $$invalidate('paths', paths = $$new_props.paths);
	};

	let paths;

	$$self.$$.update = ($$dirty = { migrations: 1, today: 1, width: 1, id1: 1, timeline_height: 1, height: 1 }) => {
		if ($$dirty.migrations || $$dirty.today) { {
        if(migrations.length){
          $$invalidate('today', today = new Date(migrations[0].time));
          today.setHours(0,0,0,0);
        }
      } }
		if ($$dirty.migrations || $$dirty.today || $$dirty.width || $$dirty.id1 || $$dirty.timeline_height || $$dirty.height) { $$invalidate('paths', paths = migrations.map(m => {
        let x = (new Date(m.time).getTime() - today.getTime() - 30*60*1000)*width/(24*60*60*1000);
        let w = Math.max(1, (Math.sqrt(m.migration_count) / 5)*width/1000);
        if(m.source == id1)
          //return `M${x},${0} C${x + length},${0} ${x},${height} ${x + length},${height}`;
          return {"path": `M${x},${-timeline_height*0.5} L${x},${height*2/3 - w*1.5}`, "width": w, "count": m.migration_count, "x": x};
        else
          //return `M${x},${height} C${x + length},${height} ${x},${0} ${x + length},${0}`;
          return {"path": `M${x},${height+timeline_height*0.5} L${x},${height*1/3 + w*1.5}`, "width": w, "count": m.migration_count, "x": x};
      })); }
	};

	return {
		width,
		svg,
		height,
		timeline_height,
		migrations,
		id1,
		id2,
		paths,
		$$props,
		svg_1_binding,
		$$props: $$props = exclude_internal_props($$props)
	};
}

class Migrations extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["height", "timeline_height", "migrations", "id1", "id2"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Migrations", options, id: create_fragment$1.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.migrations === undefined && !('migrations' in props)) {
			console.warn("<Migrations> was created without expected prop 'migrations'");
		}
		if (ctx.id1 === undefined && !('id1' in props)) {
			console.warn("<Migrations> was created without expected prop 'id1'");
		}
		if (ctx.id2 === undefined && !('id2' in props)) {
			console.warn("<Migrations> was created without expected prop 'id2'");
		}
	}

	get height() {
		throw new Error("<Migrations>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<Migrations>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get timeline_height() {
		throw new Error("<Migrations>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set timeline_height(value) {
		throw new Error("<Migrations>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get migrations() {
		throw new Error("<Migrations>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set migrations(value) {
		throw new Error("<Migrations>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id1() {
		throw new Error("<Migrations>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id1(value) {
		throw new Error("<Migrations>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id2() {
		throw new Error("<Migrations>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id2(value) {
		throw new Error("<Migrations>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const getCalendarPage = (month, year, dayProps, weekStart = 0) => {
  let date = new Date(year, month, 1);
  date.setDate(date.getDate() - date.getDay() + weekStart);
  let nextMonth = month === 11 ? 0 : month + 1;
  // ensure days starts on Sunday
  // and end on saturday
  let weeks = [];
  while (date.getMonth() !== nextMonth || date.getDay() !== weekStart || weeks.length !== 6) {
    if (date.getDay() === weekStart) weeks.unshift({ days: [], id: `${year}${month}${year}${weeks.length}` });
    const updated = Object.assign({
      partOfMonth: date.getMonth() === month,
      day: date.getDate(),
      month: date.getMonth(),
      year: date.getFullYear(),
      date: new Date(date)
    }, dayProps(date));
    weeks[0].days.push(updated);
    date.setDate(date.getDate() + 1);
  }
  weeks.reverse();
  return { month, year, weeks };
};

const getDayPropsHandler = (start, end, selectableCallback) => {
  let today = new Date();
  today.setHours(0, 0, 0, 0);
  return date => {
    const isInRange = date >= start && date <= end;
    return {
      isInRange,
      selectable: isInRange && (!selectableCallback || selectableCallback(date)),
      isToday: date.getTime() === today.getTime()
    };
  };
};

function getMonths(start, end, selectableCallback = null, weekStart = 0) {
  start.setHours(0, 0, 0, 0);
  end.setHours(0, 0, 0, 0);
  let endDate = new Date(end.getFullYear(), end.getMonth() + 1, 1);
  let months = [];
  let date = new Date(start.getFullYear(), start.getMonth(), 1);
  let dayPropsHandler = getDayPropsHandler(start, end, selectableCallback);
  while (date < endDate) {
    months.push(getCalendarPage(date.getMonth(), date.getFullYear(), dayPropsHandler, weekStart));
    date.setMonth(date.getMonth() + 1);
  }
  return months;
}

const areDatesEquivalent = (a, b) => a.getDate() === b.getDate()
  && a.getMonth() === b.getMonth()
  && a.getFullYear() === b.getFullYear();

function fade(node, { delay = 0, duration = 400 }) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        css: t => `opacity: ${t * o}`
    };
}
function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 }) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
    };
}

/* node_modules/svelte-calendar/src/Components/Week.svelte generated by Svelte v3.12.1 */

const file$2 = "node_modules/svelte-calendar/src/Components/Week.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.day = list[i];
	return child_ctx;
}

// (20:2) {#each days as day}
function create_each_block$2(ctx) {
	var div, button, t0_value = ctx.day.date.getDate() + "", t0, t1, dispose;

	function click_handler() {
		return ctx.click_handler(ctx);
	}

	const block = {
		c: function create() {
			div = element("div");
			button = element("button");
			t0 = text(t0_value);
			t1 = space();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			button = claim_element(div_nodes, "BUTTON", { class: true, type: true }, false);
			var button_nodes = children(button);

			t0 = claim_text(button_nodes, t0_value);
			button_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(button, "class", "day--label svelte-5wjnn4");
			attr_dev(button, "type", "button");
			toggle_class(button, "selected", areDatesEquivalent(ctx.day.date, ctx.selected));
			toggle_class(button, "highlighted", areDatesEquivalent(ctx.day.date, ctx.highlighted));
			toggle_class(button, "shake-date", ctx.shouldShakeDate && areDatesEquivalent(ctx.day.date, ctx.shouldShakeDate));
			toggle_class(button, "disabled", !ctx.day.selectable);
			add_location(button, file$2, 26, 6, 654);
			attr_dev(div, "class", "day svelte-5wjnn4");
			toggle_class(div, "outside-month", !ctx.day.partOfMonth);
			toggle_class(div, "is-today", ctx.day.isToday);
			toggle_class(div, "is-disabled", !ctx.day.selectable);
			add_location(div, file$2, 20, 4, 489);
			dispose = listen_dev(button, "click", click_handler);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, button);
			append_dev(button, t0);
			append_dev(div, t1);
		},

		p: function update(changed, new_ctx) {
			ctx = new_ctx;
			if ((changed.days) && t0_value !== (t0_value = ctx.day.date.getDate() + "")) {
				set_data_dev(t0, t0_value);
			}

			if ((changed.areDatesEquivalent || changed.days || changed.selected)) {
				toggle_class(button, "selected", areDatesEquivalent(ctx.day.date, ctx.selected));
			}

			if ((changed.areDatesEquivalent || changed.days || changed.highlighted)) {
				toggle_class(button, "highlighted", areDatesEquivalent(ctx.day.date, ctx.highlighted));
			}

			if ((changed.shouldShakeDate || changed.areDatesEquivalent || changed.days)) {
				toggle_class(button, "shake-date", ctx.shouldShakeDate && areDatesEquivalent(ctx.day.date, ctx.shouldShakeDate));
			}

			if (changed.days) {
				toggle_class(button, "disabled", !ctx.day.selectable);
				toggle_class(div, "outside-month", !ctx.day.partOfMonth);
				toggle_class(div, "is-today", ctx.day.isToday);
				toggle_class(div, "is-disabled", !ctx.day.selectable);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block$2.name, type: "each", source: "(20:2) {#each days as day}", ctx });
	return block;
}

function create_fragment$2(ctx) {
	var div, div_intro, div_outro, current;

	let each_value = ctx.days;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "week svelte-5wjnn4");
			add_location(div, file$2, 14, 0, 343);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.days || changed.areDatesEquivalent || changed.selected || changed.highlighted || changed.shouldShakeDate) {
				each_value = ctx.days;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}
		},

		i: function intro(local) {
			if (current) return;
			add_render_callback(() => {
				if (div_outro) div_outro.end(1);
				if (!div_intro) div_intro = create_in_transition(div, fly, { x: ctx.direction * 50, duration: 180, delay: 90 });
				div_intro.start();
			});

			current = true;
		},

		o: function outro(local) {
			if (div_intro) div_intro.invalidate();

			div_outro = create_out_transition(div, fade, { duration: 180 });

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_each(each_blocks, detaching);

			if (detaching) {
				if (div_outro) div_outro.end();
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$2.name, type: "component", source: "", ctx });
	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	

  const dispatch = createEventDispatcher();

  let { days, selected, highlighted, shouldShakeDate, direction } = $$props;

	const writable_props = ['days', 'selected', 'highlighted', 'shouldShakeDate', 'direction'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Week> was created with unknown prop '${key}'`);
	});

	const click_handler = ({ day }) => dispatch('dateSelected', day.date);

	$$self.$set = $$props => {
		if ('days' in $$props) $$invalidate('days', days = $$props.days);
		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
		if ('highlighted' in $$props) $$invalidate('highlighted', highlighted = $$props.highlighted);
		if ('shouldShakeDate' in $$props) $$invalidate('shouldShakeDate', shouldShakeDate = $$props.shouldShakeDate);
		if ('direction' in $$props) $$invalidate('direction', direction = $$props.direction);
	};

	$$self.$capture_state = () => {
		return { days, selected, highlighted, shouldShakeDate, direction };
	};

	$$self.$inject_state = $$props => {
		if ('days' in $$props) $$invalidate('days', days = $$props.days);
		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
		if ('highlighted' in $$props) $$invalidate('highlighted', highlighted = $$props.highlighted);
		if ('shouldShakeDate' in $$props) $$invalidate('shouldShakeDate', shouldShakeDate = $$props.shouldShakeDate);
		if ('direction' in $$props) $$invalidate('direction', direction = $$props.direction);
	};

	return {
		dispatch,
		days,
		selected,
		highlighted,
		shouldShakeDate,
		direction,
		click_handler
	};
}

class Week extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, ["days", "selected", "highlighted", "shouldShakeDate", "direction"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Week", options, id: create_fragment$2.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.days === undefined && !('days' in props)) {
			console.warn("<Week> was created without expected prop 'days'");
		}
		if (ctx.selected === undefined && !('selected' in props)) {
			console.warn("<Week> was created without expected prop 'selected'");
		}
		if (ctx.highlighted === undefined && !('highlighted' in props)) {
			console.warn("<Week> was created without expected prop 'highlighted'");
		}
		if (ctx.shouldShakeDate === undefined && !('shouldShakeDate' in props)) {
			console.warn("<Week> was created without expected prop 'shouldShakeDate'");
		}
		if (ctx.direction === undefined && !('direction' in props)) {
			console.warn("<Week> was created without expected prop 'direction'");
		}
	}

	get days() {
		throw new Error("<Week>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set days(value) {
		throw new Error("<Week>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selected() {
		throw new Error("<Week>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<Week>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get highlighted() {
		throw new Error("<Week>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set highlighted(value) {
		throw new Error("<Week>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get shouldShakeDate() {
		throw new Error("<Week>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set shouldShakeDate(value) {
		throw new Error("<Week>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get direction() {
		throw new Error("<Week>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set direction(value) {
		throw new Error("<Week>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-calendar/src/Components/Month.svelte generated by Svelte v3.12.1 */

const file$3 = "node_modules/svelte-calendar/src/Components/Month.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.week = list[i];
	return child_ctx;
}

// (20:2) {#each visibleMonth.weeks as week (week.id) }
function create_each_block$3(key_1, ctx) {
	var first, current;

	var week = new Week({
		props: {
		days: ctx.week.days,
		selected: ctx.selected,
		highlighted: ctx.highlighted,
		shouldShakeDate: ctx.shouldShakeDate,
		direction: ctx.direction
	},
		$$inline: true
	});
	week.$on("dateSelected", ctx.dateSelected_handler);

	const block = {
		key: key_1,

		first: null,

		c: function create() {
			first = empty();
			week.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			first = empty();
			week.$$.fragment.l(nodes);
			this.h();
		},

		h: function hydrate() {
			this.first = first;
		},

		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(week, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var week_changes = {};
			if (changed.visibleMonth) week_changes.days = ctx.week.days;
			if (changed.selected) week_changes.selected = ctx.selected;
			if (changed.highlighted) week_changes.highlighted = ctx.highlighted;
			if (changed.shouldShakeDate) week_changes.shouldShakeDate = ctx.shouldShakeDate;
			if (changed.direction) week_changes.direction = ctx.direction;
			week.$set(week_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(week.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(week.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(first);
			}

			destroy_component(week, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block$3.name, type: "each", source: "(20:2) {#each visibleMonth.weeks as week (week.id) }", ctx });
	return block;
}

function create_fragment$3(ctx) {
	var div, each_blocks = [], each_1_lookup = new Map(), current;

	let each_value = ctx.visibleMonth.weeks;

	const get_key = ctx => ctx.week.id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$3(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "month-container svelte-1y5dcxc");
			add_location(div, file$3, 18, 0, 286);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			const each_value = ctx.visibleMonth.weeks;

			group_outros();
			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
			check_outros();
		},

		i: function intro(local) {
			if (current) return;
			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},

		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$3.name, type: "component", source: "", ctx });
	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { id, visibleMonth, selected, highlighted, shouldShakeDate } = $$props;

  let lastId = id;
  let direction;

	const writable_props = ['id', 'visibleMonth', 'selected', 'highlighted', 'shouldShakeDate'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Month> was created with unknown prop '${key}'`);
	});

	function dateSelected_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ('id' in $$props) $$invalidate('id', id = $$props.id);
		if ('visibleMonth' in $$props) $$invalidate('visibleMonth', visibleMonth = $$props.visibleMonth);
		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
		if ('highlighted' in $$props) $$invalidate('highlighted', highlighted = $$props.highlighted);
		if ('shouldShakeDate' in $$props) $$invalidate('shouldShakeDate', shouldShakeDate = $$props.shouldShakeDate);
	};

	$$self.$capture_state = () => {
		return { id, visibleMonth, selected, highlighted, shouldShakeDate, lastId, direction };
	};

	$$self.$inject_state = $$props => {
		if ('id' in $$props) $$invalidate('id', id = $$props.id);
		if ('visibleMonth' in $$props) $$invalidate('visibleMonth', visibleMonth = $$props.visibleMonth);
		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
		if ('highlighted' in $$props) $$invalidate('highlighted', highlighted = $$props.highlighted);
		if ('shouldShakeDate' in $$props) $$invalidate('shouldShakeDate', shouldShakeDate = $$props.shouldShakeDate);
		if ('lastId' in $$props) $$invalidate('lastId', lastId = $$props.lastId);
		if ('direction' in $$props) $$invalidate('direction', direction = $$props.direction);
	};

	$$self.$$.update = ($$dirty = { lastId: 1, id: 1 }) => {
		if ($$dirty.lastId || $$dirty.id) { {
        $$invalidate('direction', direction = lastId < id ? 1 : -1);
        $$invalidate('lastId', lastId = id);
      } }
	};

	return {
		id,
		visibleMonth,
		selected,
		highlighted,
		shouldShakeDate,
		direction,
		dateSelected_handler
	};
}

class Month extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, ["id", "visibleMonth", "selected", "highlighted", "shouldShakeDate"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Month", options, id: create_fragment$3.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.id === undefined && !('id' in props)) {
			console.warn("<Month> was created without expected prop 'id'");
		}
		if (ctx.visibleMonth === undefined && !('visibleMonth' in props)) {
			console.warn("<Month> was created without expected prop 'visibleMonth'");
		}
		if (ctx.selected === undefined && !('selected' in props)) {
			console.warn("<Month> was created without expected prop 'selected'");
		}
		if (ctx.highlighted === undefined && !('highlighted' in props)) {
			console.warn("<Month> was created without expected prop 'highlighted'");
		}
		if (ctx.shouldShakeDate === undefined && !('shouldShakeDate' in props)) {
			console.warn("<Month> was created without expected prop 'shouldShakeDate'");
		}
	}

	get id() {
		throw new Error("<Month>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Month>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get visibleMonth() {
		throw new Error("<Month>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set visibleMonth(value) {
		throw new Error("<Month>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selected() {
		throw new Error("<Month>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<Month>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get highlighted() {
		throw new Error("<Month>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set highlighted(value) {
		throw new Error("<Month>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get shouldShakeDate() {
		throw new Error("<Month>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set shouldShakeDate(value) {
		throw new Error("<Month>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-calendar/src/Components/NavBar.svelte generated by Svelte v3.12.1 */
const { Object: Object_1 } = globals;

const file$4 = "node_modules/svelte-calendar/src/Components/NavBar.svelte";

function get_each_context$4(ctx, list, i) {
	const child_ctx = Object_1.create(ctx);
	child_ctx.monthDefinition = list[i];
	child_ctx.index = i;
	return child_ctx;
}

// (64:4) {#each availableMonths as monthDefinition, index}
function create_each_block$4(ctx) {
	var div, span, t0_value = ctx.monthDefinition.abbrev + "", t0, t1, dispose;

	function click_handler_2(...args) {
		return ctx.click_handler_2(ctx, ...args);
	}

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			span = claim_element(div_nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t0 = claim_text(span_nodes, t0_value);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "class", "svelte-1uccyem");
			add_location(span, file$4, 70, 8, 1978);
			attr_dev(div, "class", "month-selector--month svelte-1uccyem");
			toggle_class(div, "selected", ctx.index === ctx.month);
			toggle_class(div, "selectable", ctx.monthDefinition.selectable);
			add_location(div, file$4, 64, 6, 1741);
			dispose = listen_dev(div, "click", click_handler_2);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			append_dev(span, t0);
			append_dev(div, t1);
		},

		p: function update(changed, new_ctx) {
			ctx = new_ctx;
			if ((changed.availableMonths) && t0_value !== (t0_value = ctx.monthDefinition.abbrev + "")) {
				set_data_dev(t0, t0_value);
			}

			if (changed.month) {
				toggle_class(div, "selected", ctx.index === ctx.month);
			}

			if (changed.availableMonths) {
				toggle_class(div, "selectable", ctx.monthDefinition.selectable);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block$4.name, type: "each", source: "(64:4) {#each availableMonths as monthDefinition, index}", ctx });
	return block;
}

function create_fragment$4(ctx) {
	var div5, div3, div0, i0, t0, div1, t1_value = ctx.monthsOfYear[ctx.month][0] + "", t1, t2, t3, t4, div2, i1, t5, div4, dispose;

	let each_value = ctx.availableMonths;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div5 = element("div");
			div3 = element("div");
			div0 = element("div");
			i0 = element("i");
			t0 = space();
			div1 = element("div");
			t1 = text(t1_value);
			t2 = space();
			t3 = text(ctx.year);
			t4 = space();
			div2 = element("div");
			i1 = element("i");
			t5 = space();
			div4 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
			this.h();
		},

		l: function claim(nodes) {
			div5 = claim_element(nodes, "DIV", { class: true }, false);
			var div5_nodes = children(div5);

			div3 = claim_element(div5_nodes, "DIV", { class: true }, false);
			var div3_nodes = children(div3);

			div0 = claim_element(div3_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			i0 = claim_element(div0_nodes, "I", { class: true }, false);
			var i0_nodes = children(i0);

			i0_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(div3_nodes);

			div1 = claim_element(div3_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			t1 = claim_text(div1_nodes, t1_value);
			t2 = claim_space(div1_nodes);
			t3 = claim_text(div1_nodes, ctx.year);
			div1_nodes.forEach(detach_dev);
			t4 = claim_space(div3_nodes);

			div2 = claim_element(div3_nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			i1 = claim_element(div2_nodes, "I", { class: true }, false);
			var i1_nodes = children(i1);

			i1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			t5 = claim_space(div5_nodes);

			div4 = claim_element(div5_nodes, "DIV", { class: true }, false);
			var div4_nodes = children(div4);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div4_nodes);
			}

			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(i0, "class", "arrow left svelte-1uccyem");
			add_location(i0, file$4, 51, 6, 1286);
			attr_dev(div0, "class", "control svelte-1uccyem");
			toggle_class(div0, "enabled", ctx.canDecrementMonth);
			add_location(div0, file$4, 48, 4, 1160);
			attr_dev(div1, "class", "label svelte-1uccyem");
			add_location(div1, file$4, 53, 4, 1330);
			attr_dev(i1, "class", "arrow right svelte-1uccyem");
			add_location(i1, file$4, 59, 6, 1566);
			attr_dev(div2, "class", "control svelte-1uccyem");
			toggle_class(div2, "enabled", ctx.canIncrementMonth);
			add_location(div2, file$4, 56, 4, 1442);
			attr_dev(div3, "class", "heading-section svelte-1uccyem");
			add_location(div3, file$4, 47, 2, 1125);
			attr_dev(div4, "class", "month-selector svelte-1uccyem");
			toggle_class(div4, "open", ctx.monthSelectorOpen);
			add_location(div4, file$4, 62, 2, 1619);
			attr_dev(div5, "class", "title");
			add_location(div5, file$4, 46, 0, 1102);

			dispose = [
				listen_dev(div0, "click", ctx.click_handler),
				listen_dev(div1, "click", ctx.toggleMonthSelectorOpen),
				listen_dev(div2, "click", ctx.click_handler_1)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);
			append_dev(div5, div3);
			append_dev(div3, div0);
			append_dev(div0, i0);
			append_dev(div3, t0);
			append_dev(div3, div1);
			append_dev(div1, t1);
			append_dev(div1, t2);
			append_dev(div1, t3);
			append_dev(div3, t4);
			append_dev(div3, div2);
			append_dev(div2, i1);
			append_dev(div5, t5);
			append_dev(div5, div4);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div4, null);
			}
		},

		p: function update(changed, ctx) {
			if (changed.canDecrementMonth) {
				toggle_class(div0, "enabled", ctx.canDecrementMonth);
			}

			if ((changed.monthsOfYear || changed.month) && t1_value !== (t1_value = ctx.monthsOfYear[ctx.month][0] + "")) {
				set_data_dev(t1, t1_value);
			}

			if (changed.year) {
				set_data_dev(t3, ctx.year);
			}

			if (changed.canIncrementMonth) {
				toggle_class(div2, "enabled", ctx.canIncrementMonth);
			}

			if (changed.month || changed.availableMonths) {
				each_value = ctx.availableMonths;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div4, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}

			if (changed.monthSelectorOpen) {
				toggle_class(div4, "open", ctx.monthSelectorOpen);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div5);
			}

			destroy_each(each_blocks, detaching);

			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$4.name, type: "component", source: "", ctx });
	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();

  let { month, year, start, end, canIncrementMonth, canDecrementMonth, monthsOfYear } = $$props;

  let monthSelectorOpen = false;
  let availableMonths;

  function toggleMonthSelectorOpen() {
    $$invalidate('monthSelectorOpen', monthSelectorOpen = !monthSelectorOpen);
  }

  function monthSelected(event, { m, i }) {
    event.stopPropagation();
    if (!m.selectable) return;
    dispatch('monthSelected', i);
    toggleMonthSelectorOpen();
  }

	const writable_props = ['month', 'year', 'start', 'end', 'canIncrementMonth', 'canDecrementMonth', 'monthsOfYear'];
	Object_1.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<NavBar> was created with unknown prop '${key}'`);
	});

	const click_handler = () => dispatch('incrementMonth', -1);

	const click_handler_1 = () => dispatch('incrementMonth', 1);

	const click_handler_2 = ({ monthDefinition, index }, e) => monthSelected(e, { m: monthDefinition, i: index });

	$$self.$set = $$props => {
		if ('month' in $$props) $$invalidate('month', month = $$props.month);
		if ('year' in $$props) $$invalidate('year', year = $$props.year);
		if ('start' in $$props) $$invalidate('start', start = $$props.start);
		if ('end' in $$props) $$invalidate('end', end = $$props.end);
		if ('canIncrementMonth' in $$props) $$invalidate('canIncrementMonth', canIncrementMonth = $$props.canIncrementMonth);
		if ('canDecrementMonth' in $$props) $$invalidate('canDecrementMonth', canDecrementMonth = $$props.canDecrementMonth);
		if ('monthsOfYear' in $$props) $$invalidate('monthsOfYear', monthsOfYear = $$props.monthsOfYear);
	};

	$$self.$capture_state = () => {
		return { month, year, start, end, canIncrementMonth, canDecrementMonth, monthsOfYear, monthSelectorOpen, availableMonths };
	};

	$$self.$inject_state = $$props => {
		if ('month' in $$props) $$invalidate('month', month = $$props.month);
		if ('year' in $$props) $$invalidate('year', year = $$props.year);
		if ('start' in $$props) $$invalidate('start', start = $$props.start);
		if ('end' in $$props) $$invalidate('end', end = $$props.end);
		if ('canIncrementMonth' in $$props) $$invalidate('canIncrementMonth', canIncrementMonth = $$props.canIncrementMonth);
		if ('canDecrementMonth' in $$props) $$invalidate('canDecrementMonth', canDecrementMonth = $$props.canDecrementMonth);
		if ('monthsOfYear' in $$props) $$invalidate('monthsOfYear', monthsOfYear = $$props.monthsOfYear);
		if ('monthSelectorOpen' in $$props) $$invalidate('monthSelectorOpen', monthSelectorOpen = $$props.monthSelectorOpen);
		if ('availableMonths' in $$props) $$invalidate('availableMonths', availableMonths = $$props.availableMonths);
	};

	$$self.$$.update = ($$dirty = { start: 1, year: 1, end: 1, monthsOfYear: 1 }) => {
		if ($$dirty.start || $$dirty.year || $$dirty.end || $$dirty.monthsOfYear) { {
        let isOnLowerBoundary = start.getFullYear() === year;
        let isOnUpperBoundary = end.getFullYear() === year;
        $$invalidate('availableMonths', availableMonths = monthsOfYear.map((m, i) => {
          return Object.assign({}, {
            name: m[0],
            abbrev: m[1]
          }, {
            selectable:
              (!isOnLowerBoundary && !isOnUpperBoundary)
              || (
                (!isOnLowerBoundary || i >= start.getMonth())
                && (!isOnUpperBoundary || i <= end.getMonth())
              )
          });
        }));
      } }
	};

	return {
		dispatch,
		month,
		year,
		start,
		end,
		canIncrementMonth,
		canDecrementMonth,
		monthsOfYear,
		monthSelectorOpen,
		availableMonths,
		toggleMonthSelectorOpen,
		monthSelected,
		click_handler,
		click_handler_1,
		click_handler_2
	};
}

class NavBar extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, ["month", "year", "start", "end", "canIncrementMonth", "canDecrementMonth", "monthsOfYear"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "NavBar", options, id: create_fragment$4.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.month === undefined && !('month' in props)) {
			console.warn("<NavBar> was created without expected prop 'month'");
		}
		if (ctx.year === undefined && !('year' in props)) {
			console.warn("<NavBar> was created without expected prop 'year'");
		}
		if (ctx.start === undefined && !('start' in props)) {
			console.warn("<NavBar> was created without expected prop 'start'");
		}
		if (ctx.end === undefined && !('end' in props)) {
			console.warn("<NavBar> was created without expected prop 'end'");
		}
		if (ctx.canIncrementMonth === undefined && !('canIncrementMonth' in props)) {
			console.warn("<NavBar> was created without expected prop 'canIncrementMonth'");
		}
		if (ctx.canDecrementMonth === undefined && !('canDecrementMonth' in props)) {
			console.warn("<NavBar> was created without expected prop 'canDecrementMonth'");
		}
		if (ctx.monthsOfYear === undefined && !('monthsOfYear' in props)) {
			console.warn("<NavBar> was created without expected prop 'monthsOfYear'");
		}
	}

	get month() {
		throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set month(value) {
		throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get year() {
		throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set year(value) {
		throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get start() {
		throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set start(value) {
		throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get end() {
		throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set end(value) {
		throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get canIncrementMonth() {
		throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set canIncrementMonth(value) {
		throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get canDecrementMonth() {
		throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set canDecrementMonth(value) {
		throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get monthsOfYear() {
		throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set monthsOfYear(value) {
		throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-calendar/src/Components/Popover.svelte generated by Svelte v3.12.1 */
const { window: window_1 } = globals;

const file$5 = "node_modules/svelte-calendar/src/Components/Popover.svelte";

const get_contents_slot_changes = () => ({});
const get_contents_slot_context = () => ({});

const get_trigger_slot_changes = () => ({});
const get_trigger_slot_context = () => ({});

function create_fragment$5(ctx) {
	var div4, div0, t, div3, div2, div1, current, dispose;

	add_render_callback(ctx.onwindowresize);

	const trigger_slot_template = ctx.$$slots.trigger;
	const trigger_slot = create_slot(trigger_slot_template, ctx, get_trigger_slot_context);

	const contents_slot_template = ctx.$$slots.contents;
	const contents_slot = create_slot(contents_slot_template, ctx, get_contents_slot_context);

	const block = {
		c: function create() {
			div4 = element("div");
			div0 = element("div");

			if (trigger_slot) trigger_slot.c();
			t = space();
			div3 = element("div");
			div2 = element("div");
			div1 = element("div");

			if (contents_slot) contents_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			div4 = claim_element(nodes, "DIV", { class: true }, false);
			var div4_nodes = children(div4);

			div0 = claim_element(div4_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			if (trigger_slot) trigger_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(div4_nodes);

			div3 = claim_element(div4_nodes, "DIV", { class: true, style: true }, false);
			var div3_nodes = children(div3);

			div2 = claim_element(div3_nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			div1 = claim_element(div2_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			if (contents_slot) contents_slot.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div0, "class", "trigger");
			add_location(div0, file$5, 103, 2, 2365);

			attr_dev(div1, "class", "contents-inner svelte-1wmex1c");
			add_location(div1, file$5, 114, 6, 2763);
			attr_dev(div2, "class", "contents svelte-1wmex1c");
			add_location(div2, file$5, 113, 4, 2704);
			attr_dev(div3, "class", "contents-wrapper svelte-1wmex1c");
			set_style(div3, "transform", "translate(-50%,-50%) translate(" + ctx.translateX + "px, " + ctx.translateY + "px)");
			toggle_class(div3, "visible", ctx.open);
			toggle_class(div3, "shrink", ctx.shrink);
			add_location(div3, file$5, 107, 2, 2487);
			attr_dev(div4, "class", "sc-popover svelte-1wmex1c");
			add_location(div4, file$5, 102, 0, 2317);

			dispose = [
				listen_dev(window_1, "resize", ctx.onwindowresize),
				listen_dev(div0, "click", ctx.doOpen)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div0);

			if (trigger_slot) {
				trigger_slot.m(div0, null);
			}

			ctx.div0_binding(div0);
			append_dev(div4, t);
			append_dev(div4, div3);
			append_dev(div3, div2);
			append_dev(div2, div1);

			if (contents_slot) {
				contents_slot.m(div1, null);
			}

			ctx.div2_binding(div2);
			ctx.div3_binding(div3);
			ctx.div4_binding(div4);
			current = true;
		},

		p: function update(changed, ctx) {
			if (trigger_slot && trigger_slot.p && changed.$$scope) {
				trigger_slot.p(
					get_slot_changes(trigger_slot_template, ctx, changed, get_trigger_slot_changes),
					get_slot_context(trigger_slot_template, ctx, get_trigger_slot_context)
				);
			}

			if (contents_slot && contents_slot.p && changed.$$scope) {
				contents_slot.p(
					get_slot_changes(contents_slot_template, ctx, changed, get_contents_slot_changes),
					get_slot_context(contents_slot_template, ctx, get_contents_slot_context)
				);
			}

			if (!current || changed.translateX || changed.translateY) {
				set_style(div3, "transform", "translate(-50%,-50%) translate(" + ctx.translateX + "px, " + ctx.translateY + "px)");
			}

			if (changed.open) {
				toggle_class(div3, "visible", ctx.open);
			}

			if (changed.shrink) {
				toggle_class(div3, "shrink", ctx.shrink);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(trigger_slot, local);
			transition_in(contents_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(trigger_slot, local);
			transition_out(contents_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div4);
			}

			if (trigger_slot) trigger_slot.d(detaching);
			ctx.div0_binding(null);

			if (contents_slot) contents_slot.d(detaching);
			ctx.div2_binding(null);
			ctx.div3_binding(null);
			ctx.div4_binding(null);
			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$5.name, type: "component", source: "", ctx });
	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();

  let once = (el, evt, cb) => {
    function handler() {
      cb.apply(this, arguments);
      el.removeEventListener(evt, handler);
    }
    el.addEventListener(evt, handler);
  };

  let popover;
  let w;
  let triggerContainer;
  let contentsAnimated;
  let contentsWrapper;
  let translateY = 0;
  let translateX = 0;

  let { open = false, shrink, trigger } = $$props;
  const close = () => {
    $$invalidate('shrink', shrink = true);
    once(contentsAnimated, 'animationend', () => {
      $$invalidate('shrink', shrink = false);
      $$invalidate('open', open = false);
      dispatch('closed');
    });
  };

  function checkForFocusLoss(evt) {
    if (!open) return;
    let el = evt.target;
    // eslint-disable-next-line
    do {
      if (el === popover) return;
    // eslint-disable-next-line
    } while (el = el.parentNode);
    close();
  }

  onMount(() => {
    document.addEventListener('click', checkForFocusLoss);
    if (!trigger) return;
    triggerContainer.appendChild(trigger.parentNode.removeChild(trigger));

    // eslint-disable-next-line
    return () => {
      document.removeEventListener('click', checkForFocusLoss);
    };
  });

  const getDistanceToEdges = async () => {
    if (!open) { $$invalidate('open', open = true); }
    await tick();
    let rect = contentsWrapper.getBoundingClientRect();
    return {
      top: rect.top + (-1 * translateY),
      bottom: window.innerHeight - rect.bottom + translateY,
      left: rect.left + (-1 * translateX),
      right: document.body.clientWidth - rect.right + translateX
    };
  };

  const getTranslate = async () => {
    let dist = await getDistanceToEdges();
    let x; let
      y;
    if (w < 480) {
      y = dist.bottom;
    } else if (dist.top < 0) {
      y = Math.abs(dist.top);
    } else if (dist.bottom < 0) {
      y = dist.bottom;
    } else {
      y = 0;
    }
    if (dist.left < 0) {
      x = Math.abs(dist.left);
    } else if (dist.right < 0) {
      x = dist.right;
    } else {
      x = 0;
    }
    return { x, y };
  };

  const doOpen = async () => {
    const { x, y } = await getTranslate();

    $$invalidate('translateX', translateX = x);
    $$invalidate('translateY', translateY = y);
    $$invalidate('open', open = true);

    dispatch('opened');
  };

	const writable_props = ['open', 'shrink', 'trigger'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Popover> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	function onwindowresize() {
		w = window_1.innerWidth; $$invalidate('w', w);
	}

	function div0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('triggerContainer', triggerContainer = $$value);
		});
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('contentsAnimated', contentsAnimated = $$value);
		});
	}

	function div3_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('contentsWrapper', contentsWrapper = $$value);
		});
	}

	function div4_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('popover', popover = $$value);
		});
	}

	$$self.$set = $$props => {
		if ('open' in $$props) $$invalidate('open', open = $$props.open);
		if ('shrink' in $$props) $$invalidate('shrink', shrink = $$props.shrink);
		if ('trigger' in $$props) $$invalidate('trigger', trigger = $$props.trigger);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return { once, popover, w, triggerContainer, contentsAnimated, contentsWrapper, translateY, translateX, open, shrink, trigger };
	};

	$$self.$inject_state = $$props => {
		if ('once' in $$props) once = $$props.once;
		if ('popover' in $$props) $$invalidate('popover', popover = $$props.popover);
		if ('w' in $$props) $$invalidate('w', w = $$props.w);
		if ('triggerContainer' in $$props) $$invalidate('triggerContainer', triggerContainer = $$props.triggerContainer);
		if ('contentsAnimated' in $$props) $$invalidate('contentsAnimated', contentsAnimated = $$props.contentsAnimated);
		if ('contentsWrapper' in $$props) $$invalidate('contentsWrapper', contentsWrapper = $$props.contentsWrapper);
		if ('translateY' in $$props) $$invalidate('translateY', translateY = $$props.translateY);
		if ('translateX' in $$props) $$invalidate('translateX', translateX = $$props.translateX);
		if ('open' in $$props) $$invalidate('open', open = $$props.open);
		if ('shrink' in $$props) $$invalidate('shrink', shrink = $$props.shrink);
		if ('trigger' in $$props) $$invalidate('trigger', trigger = $$props.trigger);
	};

	return {
		popover,
		w,
		triggerContainer,
		contentsAnimated,
		contentsWrapper,
		translateY,
		translateX,
		open,
		shrink,
		trigger,
		close,
		doOpen,
		onwindowresize,
		div0_binding,
		div2_binding,
		div3_binding,
		div4_binding,
		$$slots,
		$$scope
	};
}

class Popover extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, ["open", "shrink", "trigger", "close"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Popover", options, id: create_fragment$5.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.shrink === undefined && !('shrink' in props)) {
			console.warn("<Popover> was created without expected prop 'shrink'");
		}
		if (ctx.trigger === undefined && !('trigger' in props)) {
			console.warn("<Popover> was created without expected prop 'trigger'");
		}
	}

	get open() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set open(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get shrink() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set shrink(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get trigger() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set trigger(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get close() {
		return this.$$.ctx.close;
	}

	set close(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/**
 * generic function to inject data into token-laden string
 * @param str {String} Required
 * @param name {String} Required
 * @param value {String|Integer} Required
 * @returns {String}
 *
 * @example
 * injectStringData("The following is a token: #{tokenName}", "tokenName", 123); 
 * @returns {String} "The following is a token: 123"
 *
 */
const injectStringData = (str,name,value) => str
  .replace(new RegExp('#{'+name+'}','g'), value);

/**
 * Generic function to enforce length of string. 
 * 
 * Pass a string or number to this function and specify the desired length.
 * This function will either pad the # with leading 0's (if str.length < length)
 * or remove data from the end (@fromBack==false) or beginning (@fromBack==true)
 * of the string when str.length > length.
 *
 * When length == str.length or typeof length == 'undefined', this function
 * returns the original @str parameter.
 * 
 * @param str {String} Required
 * @param length {Integer} Required
 * @param fromBack {Boolean} Optional
 * @returns {String}
 *
 */
const enforceLength = function(str,length,fromBack) {
  str = str.toString();
  if(typeof length == 'undefined') return str;
  if(str.length == length) return str;
  fromBack = (typeof fromBack == 'undefined') ? false : fromBack;
  if(str.length < length) {
    // pad the beginning of the string w/ enough 0's to reach desired length:
    while(length - str.length > 0) str = '0' + str;
  } else if(str.length > length) {
    if(fromBack) {
      // grab the desired #/chars from end of string: ex: '2015' -> '15'
      str = str.substring(str.length-length);
    } else {
      // grab the desired #/chars from beginning of string: ex: '2015' -> '20'
      str = str.substring(0,length);
    }
  }
  return str;
};

const daysOfWeek = [ 
  [ 'Sunday', 'Sun' ],
  [ 'Monday', 'Mon' ],
  [ 'Tuesday', 'Tue' ],
  [ 'Wednesday', 'Wed' ],
  [ 'Thursday', 'Thu' ],
  [ 'Friday', 'Fri' ],
  [ 'Saturday', 'Sat' ]
];

const monthsOfYear = [ 
  [ 'January', 'Jan' ],
  [ 'February', 'Feb' ],
  [ 'March', 'Mar' ],
  [ 'April', 'Apr' ],
  [ 'May', 'May' ],
  [ 'June', 'Jun' ],
  [ 'July', 'Jul' ],
  [ 'August', 'Aug' ],
  [ 'September', 'Sep' ],
  [ 'October', 'Oct' ],
  [ 'November', 'Nov' ],
  [ 'December', 'Dec' ]
];

let dictionary = { 
  daysOfWeek, 
  monthsOfYear
};

const extendDictionary = (conf) => 
  Object.keys(conf).forEach(key => {
    if(dictionary[key] && dictionary[key].length == conf[key].length) {
      dictionary[key] = conf[key];
    }
  });

var acceptedDateTokens = [
  { 
    // d: day of the month, 2 digits with leading zeros:
    key: 'd', 
    method: function(date) { return enforceLength(date.getDate(), 2); } 
  }, { 
    // D: textual representation of day, 3 letters: Sun thru Sat
    key: 'D', 
    method: function(date) { return dictionary.daysOfWeek[date.getDay()][1]; } 
  }, { 
    // j: day of month without leading 0's
    key: 'j', 
    method: function(date) { return date.getDate(); } 
  }, { 
    // l: full textual representation of day of week: Sunday thru Saturday
    key: 'l', 
    method: function(date) { return dictionary.daysOfWeek[date.getDay()][0]; } 
  }, { 
    // F: full text month: 'January' thru 'December'
    key: 'F', 
    method: function(date) { return dictionary.monthsOfYear[date.getMonth()][0]; } 
  }, { 
    // m: 2 digit numeric month: '01' - '12':
    key: 'm', 
    method: function(date) { return enforceLength(date.getMonth()+1,2); } 
  }, { 
    // M: a short textual representation of the month, 3 letters: 'Jan' - 'Dec'
    key: 'M', 
    method: function(date) { return dictionary.monthsOfYear[date.getMonth()][1]; } 
  }, { 
    // n: numeric represetation of month w/o leading 0's, '1' - '12':
    key: 'n', 
    method: function(date) { return date.getMonth() + 1; } 
  }, { 
    // Y: Full numeric year, 4 digits
    key: 'Y', 
    method: function(date) { return date.getFullYear(); } 
  }, { 
    // y: 2 digit numeric year:
    key: 'y', 
    method: function(date) { return enforceLength(date.getFullYear(),2,true); }
   }
];

var acceptedTimeTokens = [
  { 
    // a: lowercase ante meridiem and post meridiem 'am' or 'pm'
    key: 'a', 
    method: function(date) { return (date.getHours() > 11) ? 'pm' : 'am'; } 
  }, { 
    // A: uppercase ante merdiiem and post meridiem 'AM' or 'PM'
    key: 'A', 
    method: function(date) { return (date.getHours() > 11) ? 'PM' : 'AM'; } 
  }, { 
    // g: 12-hour format of an hour without leading zeros 1-12
    key: 'g', 
    method: function(date) { return date.getHours() % 12 || 12; } 
  }, { 
    // G: 24-hour format of an hour without leading zeros 0-23
    key: 'G', 
    method: function(date) { return date.getHours(); } 
  }, { 
    // h: 12-hour format of an hour with leading zeros 01-12
    key: 'h', 
    method: function(date) { return enforceLength(date.getHours()%12 || 12,2); } 
  }, { 
    // H: 24-hour format of an hour with leading zeros: 00-23
    key: 'H', 
    method: function(date) { return enforceLength(date.getHours(),2); } 
  }, { 
    // i: Minutes with leading zeros 00-59
    key: 'i', 
    method: function(date) { return enforceLength(date.getMinutes(),2); } 
  }, { 
    // s: Seconds with leading zeros 00-59
    key: 's', 
    method: function(date) { return enforceLength(date.getSeconds(),2); }
   }
];

/**
 * Internationalization object for timeUtils.internationalize().
 * @typedef internationalizeObj
 * @property {Array} [daysOfWeek=[ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ]] daysOfWeek Weekday labels as strings, starting with Sunday.
 * @property {Array} [monthsOfYear=[ 'January','February','March','April','May','June','July','August','September','October','November','December' ]] monthsOfYear Month labels as strings, starting with January.
 */

/**
 * This function can be used to support additional languages by passing an object with 
 * `daysOfWeek` and `monthsOfYear` attributes.  Each attribute should be an array of
 * strings (ex: `daysOfWeek: ['monday', 'tuesday', 'wednesday'...]`)
 *
 * @param {internationalizeObj} conf
 */
const internationalize = (conf={}) => { 
  extendDictionary(conf);
};

/**
 * generic formatDate function which accepts dynamic templates
 * @param date {Date} Required
 * @param template {String} Optional
 * @returns {String}
 *
 * @example
 * formatDate(new Date(), '#{M}. #{j}, #{Y}')
 * @returns {Number} Returns a formatted date
 *
 */
const formatDate = (date,template='#{m}/#{d}/#{Y}') => {
  acceptedDateTokens.forEach(token => {
    if(template.indexOf(`#{${token.key}}`) == -1) return; 
    template = injectStringData(template,token.key,token.method(date));
  }); 
  acceptedTimeTokens.forEach(token => {
    if(template.indexOf(`#{${token.key}}`) == -1) return;
    template = injectStringData(template,token.key,token.method(date));
  });
  return template;
};

const keyCodes = {
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  pgup: 33,
  pgdown: 34,
  enter: 13,
  escape: 27,
  tab: 9
};

const keyCodesArray = Object.keys(keyCodes).map(k => keyCodes[k]);

/* node_modules/svelte-calendar/src/Components/Datepicker.svelte generated by Svelte v3.12.1 */

const file$6 = "node_modules/svelte-calendar/src/Components/Datepicker.svelte";

function get_each_context$5(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.day = list[i];
	return child_ctx;
}

// (272:8) {#if !trigger}
function create_if_block$1(ctx) {
	var button, t;

	const block = {
		c: function create() {
			button = element("button");
			t = text(ctx.formattedSelected);
			this.h();
		},

		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true, type: true }, false);
			var button_nodes = children(button);

			t = claim_text(button_nodes, ctx.formattedSelected);
			button_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(button, "class", "calendar-button svelte-1lorc63");
			attr_dev(button, "type", "button");
			add_location(button, file$6, 272, 8, 7543);
		},

		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);
		},

		p: function update(changed, ctx) {
			if (changed.formattedSelected) {
				set_data_dev(t, ctx.formattedSelected);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(button);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$1.name, type: "if", source: "(272:8) {#if !trigger}", ctx });
	return block;
}

// (270:4) <div slot="trigger">
function create_trigger_slot(ctx) {
	var div, current;

	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	var if_block = (!ctx.trigger) && create_if_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");

			if (!default_slot) {
				if (if_block) if_block.c();
			}

			if (default_slot) default_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true, class: true }, false);
			var div_nodes = children(div);

			if (!default_slot) {
				if (if_block) if_block.l(div_nodes);
			}

			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "slot", "trigger");
			attr_dev(div, "class", "svelte-1lorc63");
			add_location(div, file$6, 269, 4, 7478);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (!default_slot) {
				if (if_block) if_block.m(div, null);
			}

			else {
				default_slot.m(div, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (!default_slot) {
				if (!ctx.trigger) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$1(ctx);
						if_block.c();
						if_block.m(div, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			}

			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(
					get_slot_changes(default_slot_template, ctx, changed, null),
					get_slot_context(default_slot_template, ctx, null)
				);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (!default_slot) {
				if (if_block) if_block.d();
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_trigger_slot.name, type: "slot", source: "(270:4) <div slot=\"trigger\">", ctx });
	return block;
}

// (293:10) {#each sortedDaysOfWeek as day}
function create_each_block$5(ctx) {
	var span, t_value = ctx.day[1] + "", t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "class", "svelte-1lorc63");
			add_location(span, file$6, 293, 10, 8112);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block$5.name, type: "each", source: "(293:10) {#each sortedDaysOfWeek as day}", ctx });
	return block;
}

// (279:4) <div slot="contents">
function create_contents_slot(ctx) {
	var div0, div2, t0, div1, t1, current;

	var navbar = new NavBar({
		props: {
		month: ctx.month,
		year: ctx.year,
		canIncrementMonth: ctx.canIncrementMonth,
		canDecrementMonth: ctx.canDecrementMonth,
		start: ctx.start,
		end: ctx.end,
		monthsOfYear: ctx.monthsOfYear
	},
		$$inline: true
	});
	navbar.$on("monthSelected", ctx.monthSelected_handler);
	navbar.$on("incrementMonth", ctx.incrementMonth_handler);

	let each_value = ctx.sortedDaysOfWeek;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	var month_1 = new Month({
		props: {
		visibleMonth: ctx.visibleMonth,
		selected: ctx.selected,
		highlighted: ctx.highlighted,
		shouldShakeDate: ctx.shouldShakeDate,
		id: ctx.visibleMonthId
	},
		$$inline: true
	});
	month_1.$on("dateSelected", ctx.dateSelected_handler);

	const block = {
		c: function create() {
			div0 = element("div");
			div2 = element("div");
			navbar.$$.fragment.c();
			t0 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			month_1.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { slot: true, class: true }, false);
			var div0_nodes = children(div0);

			div2 = claim_element(div0_nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			navbar.$$.fragment.l(div2_nodes);
			t0 = claim_space(div2_nodes);

			div1 = claim_element(div2_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div1_nodes);
			}

			div1_nodes.forEach(detach_dev);
			t1 = claim_space(div2_nodes);
			month_1.$$.fragment.l(div2_nodes);
			div2_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div1, "class", "legend svelte-1lorc63");
			add_location(div1, file$6, 291, 8, 8039);
			attr_dev(div2, "class", "calendar svelte-1lorc63");
			add_location(div2, file$6, 279, 6, 7709);
			attr_dev(div0, "slot", "contents");
			attr_dev(div0, "class", "svelte-1lorc63");
			add_location(div0, file$6, 278, 4, 7681);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, div2);
			mount_component(navbar, div2, null);
			append_dev(div2, t0);
			append_dev(div2, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append_dev(div2, t1);
			mount_component(month_1, div2, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var navbar_changes = {};
			if (changed.month) navbar_changes.month = ctx.month;
			if (changed.year) navbar_changes.year = ctx.year;
			if (changed.canIncrementMonth) navbar_changes.canIncrementMonth = ctx.canIncrementMonth;
			if (changed.canDecrementMonth) navbar_changes.canDecrementMonth = ctx.canDecrementMonth;
			if (changed.start) navbar_changes.start = ctx.start;
			if (changed.end) navbar_changes.end = ctx.end;
			if (changed.monthsOfYear) navbar_changes.monthsOfYear = ctx.monthsOfYear;
			navbar.$set(navbar_changes);

			if (changed.sortedDaysOfWeek) {
				each_value = ctx.sortedDaysOfWeek;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}

			var month_1_changes = {};
			if (changed.visibleMonth) month_1_changes.visibleMonth = ctx.visibleMonth;
			if (changed.selected) month_1_changes.selected = ctx.selected;
			if (changed.highlighted) month_1_changes.highlighted = ctx.highlighted;
			if (changed.shouldShakeDate) month_1_changes.shouldShakeDate = ctx.shouldShakeDate;
			if (changed.visibleMonthId) month_1_changes.id = ctx.visibleMonthId;
			month_1.$set(month_1_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(navbar.$$.fragment, local);

			transition_in(month_1.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(navbar.$$.fragment, local);
			transition_out(month_1.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div0);
			}

			destroy_component(navbar);

			destroy_each(each_blocks, detaching);

			destroy_component(month_1);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_contents_slot.name, type: "slot", source: "(279:4) <div slot=\"contents\">", ctx });
	return block;
}

// (262:2) <Popover     bind:this="{popover}"     bind:open="{isOpen}"     bind:shrink="{isClosing}"     {trigger}     on:opened="{registerOpen}"     on:closed="{registerClose}"   >
function create_default_slot(ctx) {
	var t;

	const block = {
		c: function create() {
			t = space();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot.name, type: "slot", source: "(262:2) <Popover     bind:this=\"{popover}\"     bind:open=\"{isOpen}\"     bind:shrink=\"{isClosing}\"     {trigger}     on:opened=\"{registerOpen}\"     on:closed=\"{registerClose}\"   >", ctx });
	return block;
}

function create_fragment$6(ctx) {
	var div, updating_open, updating_shrink, current;

	function popover_1_open_binding(value) {
		ctx.popover_1_open_binding.call(null, value);
		updating_open = true;
		add_flush_callback(() => updating_open = false);
	}

	function popover_1_shrink_binding(value_1) {
		ctx.popover_1_shrink_binding.call(null, value_1);
		updating_shrink = true;
		add_flush_callback(() => updating_shrink = false);
	}

	let popover_1_props = {
		trigger: ctx.trigger,
		$$slots: {
		default: [create_default_slot],
		contents: [create_contents_slot],
		trigger: [create_trigger_slot]
	},
		$$scope: { ctx }
	};
	if (ctx.isOpen !== void 0) {
		popover_1_props.open = ctx.isOpen;
	}
	if (ctx.isClosing !== void 0) {
		popover_1_props.shrink = ctx.isClosing;
	}
	var popover_1 = new Popover({ props: popover_1_props, $$inline: true });

	ctx.popover_1_binding(popover_1);
	binding_callbacks.push(() => bind(popover_1, 'open', popover_1_open_binding));
	binding_callbacks.push(() => bind(popover_1, 'shrink', popover_1_shrink_binding));
	popover_1.$on("opened", ctx.registerOpen);
	popover_1.$on("closed", ctx.registerClose);

	const block = {
		c: function create() {
			div = element("div");
			popover_1.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true }, false);
			var div_nodes = children(div);

			popover_1.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "datepicker svelte-1lorc63");
			attr_dev(div, "style", ctx.wrapperStyle);
			toggle_class(div, "open", ctx.isOpen);
			toggle_class(div, "closing", ctx.isClosing);
			add_location(div, file$6, 255, 0, 7193);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(popover_1, div, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var popover_1_changes = {};
			if (changed.trigger) popover_1_changes.trigger = ctx.trigger;
			if (changed.$$scope || changed.visibleMonth || changed.selected || changed.highlighted || changed.shouldShakeDate || changed.visibleMonthId || changed.month || changed.year || changed.canIncrementMonth || changed.canDecrementMonth || changed.start || changed.end || changed.monthsOfYear || changed.trigger || changed.formattedSelected) popover_1_changes.$$scope = { changed, ctx };
			if (!updating_open && changed.isOpen) {
				popover_1_changes.open = ctx.isOpen;
			}
			if (!updating_shrink && changed.isClosing) {
				popover_1_changes.shrink = ctx.isClosing;
			}
			popover_1.$set(popover_1_changes);

			if (!current || changed.wrapperStyle) {
				attr_dev(div, "style", ctx.wrapperStyle);
			}

			if (changed.isOpen) {
				toggle_class(div, "open", ctx.isOpen);
			}

			if (changed.isClosing) {
				toggle_class(div, "closing", ctx.isClosing);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(popover_1.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(popover_1.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			ctx.popover_1_binding(null);

			destroy_component(popover_1);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$6.name, type: "component", source: "", ctx });
	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	

  const dispatch = createEventDispatcher();
  const today = new Date();

  let popover;

  let { format = '#{m}/#{d}/#{Y}', start = new Date(1987, 9, 29), end = new Date(2020, 9, 29), selected = today, dateChosen = false, trigger = null, selectableCallback = null, weekStart = 0, daysOfWeek = [
    ['Sunday', 'Sun'],
    ['Monday', 'Mon'],
    ['Tuesday', 'Tue'],
    ['Wednesday', 'Wed'],
    ['Thursday', 'Thu'],
    ['Friday', 'Fri'],
    ['Saturday', 'Sat']
  ], monthsOfYear = [
    ['January', 'Jan'],
    ['February', 'Feb'],
    ['March', 'Mar'],
    ['April', 'Apr'],
    ['May', 'May'],
    ['June', 'Jun'],
    ['July', 'Jul'],
    ['August', 'Aug'],
    ['September', 'Sep'],
    ['October', 'Oct'],
    ['November', 'Nov'],
    ['December', 'Dec']
  ], style = '', buttonBackgroundColor = '#fff', buttonBorderColor = '#eee', buttonTextColor = '#333', highlightColor = '#f7901e', dayBackgroundColor = 'none', dayTextColor = '#4a4a4a', dayHighlightedBackgroundColor = '#efefef', dayHighlightedTextColor = '#4a4a4a' } = $$props;

  internationalize({ daysOfWeek, monthsOfYear });
  let sortedDaysOfWeek = weekStart === 0 ? daysOfWeek : (() => {
    let dow = daysOfWeek.slice();
    dow.push(dow.shift());
    return dow;
  })();

  let highlighted = today;
  let shouldShakeDate = false;
  let shakeHighlightTimeout;
  let month = today.getMonth();
  let year = today.getFullYear();

  let isOpen = false;
  let isClosing = false;

  today.setHours(0, 0, 0, 0);

  function assignmentHandler(formatted) {
    if (!trigger) return;
    $$invalidate('trigger', trigger.innerHTML = formatted, trigger);
  }

  let monthIndex = 0;

  let { formattedSelected } = $$props;

  onMount(() => {
    $$invalidate('month', month = selected.getMonth());
    $$invalidate('year', year = selected.getFullYear());
  });

  function changeMonth(selectedMonth) {
    $$invalidate('month', month = selectedMonth);
    $$invalidate('highlighted', highlighted = new Date(year, month, 1));
  }

  function incrementMonth(direction, day = 1) {
    if (direction === 1 && !canIncrementMonth) return;
    if (direction === -1 && !canDecrementMonth) return;
    let current = new Date(year, month, 1);
    current.setMonth(current.getMonth() + direction);
    $$invalidate('month', month = current.getMonth());
    $$invalidate('year', year = current.getFullYear());
    $$invalidate('highlighted', highlighted = new Date(year, month, day));
  }

  function getDefaultHighlighted() {
    return new Date(selected);
  }

  const getDay = (m, d, y) => {
    let theMonth = months.find(aMonth => aMonth.month === m && aMonth.year === y);
    if (!theMonth) return null;
    // eslint-disable-next-line
    for (let i = 0; i < theMonth.weeks.length; ++i) {
      // eslint-disable-next-line
      for (let j = 0; j < theMonth.weeks[i].days.length; ++j) {
        let aDay = theMonth.weeks[i].days[j];
        if (aDay.month === m && aDay.day === d && aDay.year === y) return aDay;
      }
    }
    return null;
  };

  function incrementDayHighlighted(amount) {
    let proposedDate = new Date(highlighted);
    proposedDate.setDate(highlighted.getDate() + amount);
    let correspondingDayObj = getDay(
      proposedDate.getMonth(),
      proposedDate.getDate(),
      proposedDate.getFullYear()
    );
    if (!correspondingDayObj || !correspondingDayObj.isInRange) return;
    $$invalidate('highlighted', highlighted = proposedDate);
    if (amount > 0 && highlighted > lastVisibleDate) {
      incrementMonth(1, highlighted.getDate());
    }
    if (amount < 0 && highlighted < firstVisibleDate) {
      incrementMonth(-1, highlighted.getDate());
    }
  }

  function checkIfVisibleDateIsSelectable(date) {
    const proposedDay = getDay(date.getMonth(), date.getDate(), date.getFullYear());
    return proposedDay && proposedDay.selectable;
  }

  function shakeDate(date) {
    clearTimeout(shakeHighlightTimeout);
    $$invalidate('shouldShakeDate', shouldShakeDate = date);
    shakeHighlightTimeout = setTimeout(() => {
      $$invalidate('shouldShakeDate', shouldShakeDate = false);
    }, 700);
  }

  function assignValueToTrigger(formatted) {
    assignmentHandler(formatted);
  }

  function registerSelection(chosen) {
    if (!checkIfVisibleDateIsSelectable(chosen)) return shakeDate(chosen);
    // eslint-disable-next-line
    close();
    $$invalidate('selected', selected = chosen);
    $$invalidate('dateChosen', dateChosen = true);
    assignValueToTrigger(formattedSelected);
    return dispatch('dateSelected', { date: chosen });
  }

  function handleKeyPress(evt) {
    if (keyCodesArray.indexOf(evt.keyCode) === -1) return;
    evt.preventDefault();
    switch (evt.keyCode) {
      case keyCodes.left:
        incrementDayHighlighted(-1);
        break;
      case keyCodes.up:
        incrementDayHighlighted(-7);
        break;
      case keyCodes.right:
        incrementDayHighlighted(1);
        break;
      case keyCodes.down:
        incrementDayHighlighted(7);
        break;
      case keyCodes.pgup:
        incrementMonth(-1);
        break;
      case keyCodes.pgdown:
        incrementMonth(1);
        break;
      case keyCodes.escape:
        // eslint-disable-next-line
        close();
        break;
      case keyCodes.enter:
        registerSelection(highlighted);
        break;
    }
  }

  function registerClose() {
    document.removeEventListener('keydown', handleKeyPress);
    dispatch('close');
  }

  function close() {
    popover.close();
    registerClose();
  }

  function registerOpen() {
    $$invalidate('highlighted', highlighted = getDefaultHighlighted());
    $$invalidate('month', month = selected.getMonth());
    $$invalidate('year', year = selected.getFullYear());
    document.addEventListener('keydown', handleKeyPress);
    dispatch('open');
  }

	const writable_props = ['format', 'start', 'end', 'selected', 'dateChosen', 'trigger', 'selectableCallback', 'weekStart', 'daysOfWeek', 'monthsOfYear', 'style', 'buttonBackgroundColor', 'buttonBorderColor', 'buttonTextColor', 'highlightColor', 'dayBackgroundColor', 'dayTextColor', 'dayHighlightedBackgroundColor', 'dayHighlightedTextColor', 'formattedSelected'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Datepicker> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	const monthSelected_handler = (e) => changeMonth(e.detail);

	const incrementMonth_handler = (e) => incrementMonth(e.detail);

	const dateSelected_handler = (e) => registerSelection(e.detail);

	function popover_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('popover', popover = $$value);
		});
	}

	function popover_1_open_binding(value) {
		isOpen = value;
		$$invalidate('isOpen', isOpen);
	}

	function popover_1_shrink_binding(value_1) {
		isClosing = value_1;
		$$invalidate('isClosing', isClosing);
	}

	$$self.$set = $$props => {
		if ('format' in $$props) $$invalidate('format', format = $$props.format);
		if ('start' in $$props) $$invalidate('start', start = $$props.start);
		if ('end' in $$props) $$invalidate('end', end = $$props.end);
		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
		if ('dateChosen' in $$props) $$invalidate('dateChosen', dateChosen = $$props.dateChosen);
		if ('trigger' in $$props) $$invalidate('trigger', trigger = $$props.trigger);
		if ('selectableCallback' in $$props) $$invalidate('selectableCallback', selectableCallback = $$props.selectableCallback);
		if ('weekStart' in $$props) $$invalidate('weekStart', weekStart = $$props.weekStart);
		if ('daysOfWeek' in $$props) $$invalidate('daysOfWeek', daysOfWeek = $$props.daysOfWeek);
		if ('monthsOfYear' in $$props) $$invalidate('monthsOfYear', monthsOfYear = $$props.monthsOfYear);
		if ('style' in $$props) $$invalidate('style', style = $$props.style);
		if ('buttonBackgroundColor' in $$props) $$invalidate('buttonBackgroundColor', buttonBackgroundColor = $$props.buttonBackgroundColor);
		if ('buttonBorderColor' in $$props) $$invalidate('buttonBorderColor', buttonBorderColor = $$props.buttonBorderColor);
		if ('buttonTextColor' in $$props) $$invalidate('buttonTextColor', buttonTextColor = $$props.buttonTextColor);
		if ('highlightColor' in $$props) $$invalidate('highlightColor', highlightColor = $$props.highlightColor);
		if ('dayBackgroundColor' in $$props) $$invalidate('dayBackgroundColor', dayBackgroundColor = $$props.dayBackgroundColor);
		if ('dayTextColor' in $$props) $$invalidate('dayTextColor', dayTextColor = $$props.dayTextColor);
		if ('dayHighlightedBackgroundColor' in $$props) $$invalidate('dayHighlightedBackgroundColor', dayHighlightedBackgroundColor = $$props.dayHighlightedBackgroundColor);
		if ('dayHighlightedTextColor' in $$props) $$invalidate('dayHighlightedTextColor', dayHighlightedTextColor = $$props.dayHighlightedTextColor);
		if ('formattedSelected' in $$props) $$invalidate('formattedSelected', formattedSelected = $$props.formattedSelected);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return { popover, format, start, end, selected, dateChosen, trigger, selectableCallback, weekStart, daysOfWeek, monthsOfYear, style, buttonBackgroundColor, buttonBorderColor, buttonTextColor, highlightColor, dayBackgroundColor, dayTextColor, dayHighlightedBackgroundColor, dayHighlightedTextColor, sortedDaysOfWeek, highlighted, shouldShakeDate, shakeHighlightTimeout, month, year, isOpen, isClosing, monthIndex, formattedSelected, months, visibleMonth, visibleMonthId, lastVisibleDate, firstVisibleDate, canIncrementMonth, canDecrementMonth, wrapperStyle };
	};

	$$self.$inject_state = $$props => {
		if ('popover' in $$props) $$invalidate('popover', popover = $$props.popover);
		if ('format' in $$props) $$invalidate('format', format = $$props.format);
		if ('start' in $$props) $$invalidate('start', start = $$props.start);
		if ('end' in $$props) $$invalidate('end', end = $$props.end);
		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
		if ('dateChosen' in $$props) $$invalidate('dateChosen', dateChosen = $$props.dateChosen);
		if ('trigger' in $$props) $$invalidate('trigger', trigger = $$props.trigger);
		if ('selectableCallback' in $$props) $$invalidate('selectableCallback', selectableCallback = $$props.selectableCallback);
		if ('weekStart' in $$props) $$invalidate('weekStart', weekStart = $$props.weekStart);
		if ('daysOfWeek' in $$props) $$invalidate('daysOfWeek', daysOfWeek = $$props.daysOfWeek);
		if ('monthsOfYear' in $$props) $$invalidate('monthsOfYear', monthsOfYear = $$props.monthsOfYear);
		if ('style' in $$props) $$invalidate('style', style = $$props.style);
		if ('buttonBackgroundColor' in $$props) $$invalidate('buttonBackgroundColor', buttonBackgroundColor = $$props.buttonBackgroundColor);
		if ('buttonBorderColor' in $$props) $$invalidate('buttonBorderColor', buttonBorderColor = $$props.buttonBorderColor);
		if ('buttonTextColor' in $$props) $$invalidate('buttonTextColor', buttonTextColor = $$props.buttonTextColor);
		if ('highlightColor' in $$props) $$invalidate('highlightColor', highlightColor = $$props.highlightColor);
		if ('dayBackgroundColor' in $$props) $$invalidate('dayBackgroundColor', dayBackgroundColor = $$props.dayBackgroundColor);
		if ('dayTextColor' in $$props) $$invalidate('dayTextColor', dayTextColor = $$props.dayTextColor);
		if ('dayHighlightedBackgroundColor' in $$props) $$invalidate('dayHighlightedBackgroundColor', dayHighlightedBackgroundColor = $$props.dayHighlightedBackgroundColor);
		if ('dayHighlightedTextColor' in $$props) $$invalidate('dayHighlightedTextColor', dayHighlightedTextColor = $$props.dayHighlightedTextColor);
		if ('sortedDaysOfWeek' in $$props) $$invalidate('sortedDaysOfWeek', sortedDaysOfWeek = $$props.sortedDaysOfWeek);
		if ('highlighted' in $$props) $$invalidate('highlighted', highlighted = $$props.highlighted);
		if ('shouldShakeDate' in $$props) $$invalidate('shouldShakeDate', shouldShakeDate = $$props.shouldShakeDate);
		if ('shakeHighlightTimeout' in $$props) shakeHighlightTimeout = $$props.shakeHighlightTimeout;
		if ('month' in $$props) $$invalidate('month', month = $$props.month);
		if ('year' in $$props) $$invalidate('year', year = $$props.year);
		if ('isOpen' in $$props) $$invalidate('isOpen', isOpen = $$props.isOpen);
		if ('isClosing' in $$props) $$invalidate('isClosing', isClosing = $$props.isClosing);
		if ('monthIndex' in $$props) $$invalidate('monthIndex', monthIndex = $$props.monthIndex);
		if ('formattedSelected' in $$props) $$invalidate('formattedSelected', formattedSelected = $$props.formattedSelected);
		if ('months' in $$props) $$invalidate('months', months = $$props.months);
		if ('visibleMonth' in $$props) $$invalidate('visibleMonth', visibleMonth = $$props.visibleMonth);
		if ('visibleMonthId' in $$props) $$invalidate('visibleMonthId', visibleMonthId = $$props.visibleMonthId);
		if ('lastVisibleDate' in $$props) lastVisibleDate = $$props.lastVisibleDate;
		if ('firstVisibleDate' in $$props) firstVisibleDate = $$props.firstVisibleDate;
		if ('canIncrementMonth' in $$props) $$invalidate('canIncrementMonth', canIncrementMonth = $$props.canIncrementMonth);
		if ('canDecrementMonth' in $$props) $$invalidate('canDecrementMonth', canDecrementMonth = $$props.canDecrementMonth);
		if ('wrapperStyle' in $$props) $$invalidate('wrapperStyle', wrapperStyle = $$props.wrapperStyle);
	};

	let months, visibleMonth, visibleMonthId, lastVisibleDate, firstVisibleDate, canIncrementMonth, canDecrementMonth, wrapperStyle;

	$$self.$$.update = ($$dirty = { start: 1, end: 1, selectableCallback: 1, weekStart: 1, months: 1, month: 1, year: 1, monthIndex: 1, visibleMonth: 1, buttonBackgroundColor: 1, buttonBorderColor: 1, buttonTextColor: 1, highlightColor: 1, dayBackgroundColor: 1, dayTextColor: 1, dayHighlightedBackgroundColor: 1, dayHighlightedTextColor: 1, style: 1, format: 1, selected: 1 }) => {
		if ($$dirty.start || $$dirty.end || $$dirty.selectableCallback || $$dirty.weekStart) { $$invalidate('months', months = getMonths(start, end, selectableCallback, weekStart)); }
		if ($$dirty.months || $$dirty.month || $$dirty.year) { {
        $$invalidate('monthIndex', monthIndex = 0);
        for (let i = 0; i < months.length; i += 1) {
          if (months[i].month === month && months[i].year === year) {
            $$invalidate('monthIndex', monthIndex = i);
          }
        }
      } }
		if ($$dirty.months || $$dirty.monthIndex) { $$invalidate('visibleMonth', visibleMonth = months[monthIndex]); }
		if ($$dirty.year || $$dirty.month) { $$invalidate('visibleMonthId', visibleMonthId = year + month / 100); }
		if ($$dirty.visibleMonth) { lastVisibleDate = visibleMonth.weeks[visibleMonth.weeks.length - 1].days[6].date; }
		if ($$dirty.visibleMonth) { firstVisibleDate = visibleMonth.weeks[0].days[0].date; }
		if ($$dirty.monthIndex || $$dirty.months) { $$invalidate('canIncrementMonth', canIncrementMonth = monthIndex < months.length - 1); }
		if ($$dirty.monthIndex) { $$invalidate('canDecrementMonth', canDecrementMonth = monthIndex > 0); }
		if ($$dirty.buttonBackgroundColor || $$dirty.buttonBorderColor || $$dirty.buttonTextColor || $$dirty.highlightColor || $$dirty.dayBackgroundColor || $$dirty.dayTextColor || $$dirty.dayHighlightedBackgroundColor || $$dirty.dayHighlightedTextColor || $$dirty.style) { $$invalidate('wrapperStyle', wrapperStyle = `
        --button-background-color: ${buttonBackgroundColor};
    --button-border-color: ${buttonBorderColor};
    --button-text-color: ${buttonTextColor};
    --highlight-color: ${highlightColor};
    --day-background-color: ${dayBackgroundColor};
    --day-text-color: ${dayTextColor};
    --day-highlighted-background-color: ${dayHighlightedBackgroundColor};
    --day-highlighted-text-color: ${dayHighlightedTextColor};
    ${style}
      `); }
		if ($$dirty.format || $$dirty.selected) { {
        $$invalidate('formattedSelected', formattedSelected = typeof format === 'function'
          ? format(selected)
          : formatDate(selected, format));
      } }
	};

	return {
		popover,
		format,
		start,
		end,
		selected,
		dateChosen,
		trigger,
		selectableCallback,
		weekStart,
		daysOfWeek,
		monthsOfYear,
		style,
		buttonBackgroundColor,
		buttonBorderColor,
		buttonTextColor,
		highlightColor,
		dayBackgroundColor,
		dayTextColor,
		dayHighlightedBackgroundColor,
		dayHighlightedTextColor,
		sortedDaysOfWeek,
		highlighted,
		shouldShakeDate,
		month,
		year,
		isOpen,
		isClosing,
		formattedSelected,
		changeMonth,
		incrementMonth,
		registerSelection,
		registerClose,
		registerOpen,
		visibleMonth,
		visibleMonthId,
		canIncrementMonth,
		canDecrementMonth,
		wrapperStyle,
		monthSelected_handler,
		incrementMonth_handler,
		dateSelected_handler,
		popover_1_binding,
		popover_1_open_binding,
		popover_1_shrink_binding,
		$$slots,
		$$scope
	};
}

class Datepicker extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, ["format", "start", "end", "selected", "dateChosen", "trigger", "selectableCallback", "weekStart", "daysOfWeek", "monthsOfYear", "style", "buttonBackgroundColor", "buttonBorderColor", "buttonTextColor", "highlightColor", "dayBackgroundColor", "dayTextColor", "dayHighlightedBackgroundColor", "dayHighlightedTextColor", "formattedSelected"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Datepicker", options, id: create_fragment$6.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.formattedSelected === undefined && !('formattedSelected' in props)) {
			console.warn("<Datepicker> was created without expected prop 'formattedSelected'");
		}
	}

	get format() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set format(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get start() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set start(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get end() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set end(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selected() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dateChosen() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dateChosen(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get trigger() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set trigger(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectableCallback() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectableCallback(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get weekStart() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set weekStart(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get daysOfWeek() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set daysOfWeek(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get monthsOfYear() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set monthsOfYear(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get buttonBackgroundColor() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set buttonBackgroundColor(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get buttonBorderColor() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set buttonBorderColor(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get buttonTextColor() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set buttonTextColor(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get highlightColor() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set highlightColor(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dayBackgroundColor() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dayBackgroundColor(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dayTextColor() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dayTextColor(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dayHighlightedBackgroundColor() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dayHighlightedBackgroundColor(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dayHighlightedTextColor() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dayHighlightedTextColor(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get formattedSelected() {
		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set formattedSelected(value) {
		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/migration/index.svelte generated by Svelte v3.12.1 */

const file$7 = "src/routes/migration/index.svelte";

// (9:4) <span slot="tip">
function create_tip_slot(ctx) {
	var span, t0, br0, t1, br1, t2;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text("여러 방송 사이에서 시청자의 흐름을 살펴볼 수 있습니다.");
			br0 = element("br");
			t1 = text(" \n    날짜와 스트리머를 선택해보세요.");
			br1 = element("br");
			t2 = text("\n    * 약 한시간 간격으로 업데이트 됩니다.");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { slot: true }, false);
			var span_nodes = children(span);

			t0 = claim_text(span_nodes, "여러 방송 사이에서 시청자의 흐름을 살펴볼 수 있습니다.");

			br0 = claim_element(span_nodes, "BR", {}, false);
			var br0_nodes = children(br0);

			br0_nodes.forEach(detach_dev);
			t1 = claim_text(span_nodes, " \n    날짜와 스트리머를 선택해보세요.");

			br1 = claim_element(span_nodes, "BR", {}, false);
			var br1_nodes = children(br1);

			br1_nodes.forEach(detach_dev);
			t2 = claim_text(span_nodes, "\n    * 약 한시간 간격으로 업데이트 됩니다.");
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			add_location(br0, file$7, 9, 35, 259);
			add_location(br1, file$7, 10, 21, 286);
			attr_dev(span, "slot", "tip");
			add_location(span, file$7, 8, 4, 205);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t0);
			append_dev(span, br0);
			append_dev(span, t1);
			append_dev(span, br1);
			append_dev(span, t2);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_tip_slot.name, type: "slot", source: "(9:4) <span slot=\"tip\">", ctx });
	return block;
}

// (8:2) <Tip >
function create_default_slot_1(ctx) {
	const block = {
		c: noop,
		l: noop,
		m: noop,
		p: noop,
		d: noop
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_1.name, type: "slot", source: "(8:2) <Tip >", ctx });
	return block;
}

// (28:8) <Datepicker             end={new Date()}             format={d=>d.toLocaleDateString()}             selected={date}             on:dateSelected={on_date_pick}             >
function create_default_slot$1(ctx) {
	var button, t_value = ctx.date.toLocaleDateString() + "", t;

	const block = {
		c: function create() {
			button = element("button");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true }, false);
			var button_nodes = children(button);

			t = claim_text(button_nodes, t_value);
			button_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(button, "class", "p-2 px-4 bg-white border w-full truncate");
			add_location(button, file$7, 33, 11, 795);
		},

		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);
		},

		p: function update(changed, ctx) {
			if ((changed.date) && t_value !== (t_value = ctx.date.toLocaleDateString() + "")) {
				set_data_dev(t, t_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(button);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot$1.name, type: "slot", source: "(28:8) <Datepicker             end={new Date()}             format={d=>d.toLocaleDateString()}             selected={date}             on:dateSelected={on_date_pick}             >", ctx });
	return block;
}

// (68:8) {:else}
function create_else_block_1(ctx) {
	var div0, t0, div1, span, t1;

	const block = {
		c: function create() {
			div0 = element("div");
			t0 = space();
			div1 = element("div");
			span = element("span");
			t1 = text("?");
			this.h();
		},

		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			div0_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);

			div1 = claim_element(nodes, "DIV", { class: true, style: true }, false);
			var div1_nodes = children(div1);

			span = claim_element(div1_nodes, "SPAN", {}, false);
			var span_nodes = children(span);

			t1 = claim_text(span_nodes, "?");
			span_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div0, "class", "rounded-full h-24 w-24 bg-gray-100");
			add_location(div0, file$7, 68, 10, 2297);
			add_location(span, file$7, 69, 86, 2440);
			attr_dev(div1, "class", "pt-2 text-transparent text-gray-400 absolute");
			set_style(div1, "top", "100%");
			add_location(div1, file$7, 69, 10, 2364);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, span);
			append_dev(span, t1);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div0);
				detach_dev(t0);
				detach_dev(div1);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block_1.name, type: "else", source: "(68:8) {:else}", ctx });
	return block;
}

// (65:8) {#if streamer1}
function create_if_block_1$1(ctx) {
	var img, img_src_value, t0, div, span, t1_value = ctx.streamer1.name + "", t1;

	const block = {
		c: function create() {
			img = element("img");
			t0 = space();
			div = element("div");
			span = element("span");
			t1 = text(t1_value);
			this.h();
		},

		l: function claim(nodes) {
			img = claim_element(nodes, "IMG", { class: true, src: true }, false);
			var img_nodes = children(img);

			img_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);

			div = claim_element(nodes, "DIV", { class: true, style: true }, false);
			var div_nodes = children(div);

			span = claim_element(div_nodes, "SPAN", {}, false);
			var span_nodes = children(span);

			t1 = claim_text(span_nodes, t1_value);
			span_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(img, "class", "rounded-full h-24 w-24 border border-gray-600");
			attr_dev(img, "src", img_src_value = ctx.streamer1.profile_image_url);
			add_location(img, file$7, 65, 10, 2084);
			add_location(span, file$7, 66, 55, 2235);
			attr_dev(div, "class", "pt-2 absolute");
			set_style(div, "top", "100%");
			add_location(div, file$7, 66, 10, 2190);
		},

		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, span);
			append_dev(span, t1);
		},

		p: function update(changed, ctx) {
			if ((changed.streamer1) && img_src_value !== (img_src_value = ctx.streamer1.profile_image_url)) {
				attr_dev(img, "src", img_src_value);
			}

			if ((changed.streamer1) && t1_value !== (t1_value = ctx.streamer1.name + "")) {
				set_data_dev(t1, t1_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(img);
				detach_dev(t0);
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1$1.name, type: "if", source: "(65:8) {#if streamer1}", ctx });
	return block;
}

// (95:8) {:else}
function create_else_block$1(ctx) {
	var div0, t0, div1, span, t1;

	const block = {
		c: function create() {
			div0 = element("div");
			t0 = space();
			div1 = element("div");
			span = element("span");
			t1 = text("?");
			this.h();
		},

		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			div0_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);

			div1 = claim_element(nodes, "DIV", { class: true, style: true }, false);
			var div1_nodes = children(div1);

			span = claim_element(div1_nodes, "SPAN", {}, false);
			var span_nodes = children(span);

			t1 = claim_text(span_nodes, "?");
			span_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div0, "class", "rounded-full h-24 w-24 bg-gray-100");
			add_location(div0, file$7, 95, 10, 3363);
			add_location(span, file$7, 96, 86, 3506);
			attr_dev(div1, "class", "pt-2 text-transparent text-gray-400 absolute");
			set_style(div1, "top", "100%");
			add_location(div1, file$7, 96, 10, 3430);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, span);
			append_dev(span, t1);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div0);
				detach_dev(t0);
				detach_dev(div1);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block$1.name, type: "else", source: "(95:8) {:else}", ctx });
	return block;
}

// (92:8) {#if streamer2}
function create_if_block$2(ctx) {
	var img, img_src_value, t0, div, span, t1_value = ctx.streamer2.name + "", t1;

	const block = {
		c: function create() {
			img = element("img");
			t0 = space();
			div = element("div");
			span = element("span");
			t1 = text(t1_value);
			this.h();
		},

		l: function claim(nodes) {
			img = claim_element(nodes, "IMG", { class: true, src: true }, false);
			var img_nodes = children(img);

			img_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);

			div = claim_element(nodes, "DIV", { class: true, style: true }, false);
			var div_nodes = children(div);

			span = claim_element(div_nodes, "SPAN", {}, false);
			var span_nodes = children(span);

			t1 = claim_text(span_nodes, t1_value);
			span_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(img, "class", "rounded-full h-24 w-24 border border-gray-600");
			attr_dev(img, "src", img_src_value = ctx.streamer2.profile_image_url);
			add_location(img, file$7, 92, 10, 3150);
			add_location(span, file$7, 93, 55, 3301);
			attr_dev(div, "class", "pt-2 absolute");
			set_style(div, "top", "100%");
			add_location(div, file$7, 93, 10, 3256);
		},

		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, span);
			append_dev(span, t1);
		},

		p: function update(changed, ctx) {
			if ((changed.streamer2) && img_src_value !== (img_src_value = ctx.streamer2.profile_image_url)) {
				attr_dev(img, "src", img_src_value);
			}

			if ((changed.streamer2) && t1_value !== (t1_value = ctx.streamer2.name + "")) {
				set_data_dev(t1, t1_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(img);
				detach_dev(t0);
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$2.name, type: "if", source: "(92:8) {#if streamer2}", ctx });
	return block;
}

function create_fragment$7(ctx) {
	var title_value, t0, div0, h1, t1, t2, t3, div7, table, thead, tr0, th0, t4, t5, th1, t6, t7, th2, t8, t9, tbody, tr1, td0, t10, td1, updating_onselect, t11, td2, updating_onselect_1, t12, div2, div1, a0, a0_href_value, t13, t14, div4, div3, t15, t16, div6, div5, a1, a1_href_value, t17, current;

	document.title = title_value = " 트수gg - 시청자 이동" + ctx.title_sufix;

	var tip = new Tip({
		props: {
		$$slots: {
		default: [create_default_slot_1],
		tip: [create_tip_slot]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	var datepicker = new Datepicker({
		props: {
		end: new ctx.Date(),
		format: func,
		selected: ctx.date,
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	},
		$$inline: true
	});
	datepicker.$on("dateSelected", ctx.on_date_pick);

	function streamerautocomplete0_onselect_binding(value) {
		ctx.streamerautocomplete0_onselect_binding.call(null, value);
		updating_onselect = true;
		add_flush_callback(() => updating_onselect = false);
	}

	let streamerautocomplete0_props = {
		placeholder: "스트리머 선택1",
		id: "migration-streamer-search1",
		inputid: "migration-streamer-search1-input",
		input_value: ctx.streamer1? ctx.streamer1.name: "",
		input_class: "bg-white text-sm w-full transition-all transition-100 pl-7 py-2 truncate border"
	};
	if (ctx.on_streamer_search1 !== void 0) {
		streamerautocomplete0_props.onselect = ctx.on_streamer_search1;
	}
	var streamerautocomplete0 = new StreamerAutoComplete({
		props: streamerautocomplete0_props,
		$$inline: true
	});

	binding_callbacks.push(() => bind(streamerautocomplete0, 'onselect', streamerautocomplete0_onselect_binding));

	function streamerautocomplete1_onselect_binding(value_1) {
		ctx.streamerautocomplete1_onselect_binding.call(null, value_1);
		updating_onselect_1 = true;
		add_flush_callback(() => updating_onselect_1 = false);
	}

	let streamerautocomplete1_props = {
		placeholder: "스트리머 선택2",
		id: "migration-streamer-search2",
		inputid: "migration-streamer-search2-input",
		input_value: ctx.streamer2? ctx.streamer2.name: "",
		input_class: "bg-white text-sm w-full transition-all transition-100 pl-7 py-2 truncate border"
	};
	if (ctx.on_streamer_search2 !== void 0) {
		streamerautocomplete1_props.onselect = ctx.on_streamer_search2;
	}
	var streamerautocomplete1 = new StreamerAutoComplete({
		props: streamerautocomplete1_props,
		$$inline: true
	});

	binding_callbacks.push(() => bind(streamerautocomplete1, 'onselect', streamerautocomplete1_onselect_binding));

	function select_block_type(changed, ctx) {
		if (ctx.streamer1) return create_if_block_1$1;
		return create_else_block_1;
	}

	var current_block_type = select_block_type(null, ctx);
	var if_block0 = current_block_type(ctx);

	var migrationtimeline0 = new MigrationTimeline({
		props: {
		streamer: ctx.streamer1,
		height: "150",
		date: ctx.date
	},
		$$inline: true
	});

	var migrations = new Migrations({
		props: {
		migrations: ctx.viewer_migrations,
		class: "flex-1",
		id1: ctx.streamer1 && ctx.streamer1.id,
		id2: ctx.streamer2 && ctx.streamer2.id
	},
		$$inline: true
	});

	function select_block_type_1(changed, ctx) {
		if (ctx.streamer2) return create_if_block$2;
		return create_else_block$1;
	}

	var current_block_type_1 = select_block_type_1(null, ctx);
	var if_block1 = current_block_type_1(ctx);

	var migrationtimeline1 = new MigrationTimeline({
		props: {
		streamer: ctx.streamer2,
		height: "150",
		date: ctx.date
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			t0 = space();
			div0 = element("div");
			h1 = element("h1");
			t1 = text("시청자 이동");
			t2 = space();
			tip.$$.fragment.c();
			t3 = space();
			div7 = element("div");
			table = element("table");
			thead = element("thead");
			tr0 = element("tr");
			th0 = element("th");
			t4 = text("날짜");
			t5 = space();
			th1 = element("th");
			t6 = text("스트리머1");
			t7 = space();
			th2 = element("th");
			t8 = text("스트리머2");
			t9 = space();
			tbody = element("tbody");
			tr1 = element("tr");
			td0 = element("td");
			datepicker.$$.fragment.c();
			t10 = space();
			td1 = element("td");
			streamerautocomplete0.$$.fragment.c();
			t11 = space();
			td2 = element("td");
			streamerautocomplete1.$$.fragment.c();
			t12 = space();
			div2 = element("div");
			div1 = element("div");
			a0 = element("a");
			if_block0.c();
			t13 = space();
			migrationtimeline0.$$.fragment.c();
			t14 = space();
			div4 = element("div");
			div3 = element("div");
			t15 = space();
			migrations.$$.fragment.c();
			t16 = space();
			div6 = element("div");
			div5 = element("div");
			a1 = element("a");
			if_block1.c();
			t17 = space();
			migrationtimeline1.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			t0 = claim_space(nodes);

			div0 = claim_element(nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			h1 = claim_element(div0_nodes, "H1", { class: true }, false);
			var h1_nodes = children(h1);

			t1 = claim_text(h1_nodes, "시청자 이동");
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(div0_nodes);
			tip.$$.fragment.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);

			div7 = claim_element(nodes, "DIV", { class: true }, false);
			var div7_nodes = children(div7);

			table = claim_element(div7_nodes, "TABLE", { class: true }, false);
			var table_nodes = children(table);

			thead = claim_element(table_nodes, "THEAD", {}, false);
			var thead_nodes = children(thead);

			tr0 = claim_element(thead_nodes, "TR", {}, false);
			var tr0_nodes = children(tr0);

			th0 = claim_element(tr0_nodes, "TH", {}, false);
			var th0_nodes = children(th0);

			t4 = claim_text(th0_nodes, "날짜");
			th0_nodes.forEach(detach_dev);
			t5 = claim_space(tr0_nodes);

			th1 = claim_element(tr0_nodes, "TH", {}, false);
			var th1_nodes = children(th1);

			t6 = claim_text(th1_nodes, "스트리머1");
			th1_nodes.forEach(detach_dev);
			t7 = claim_space(tr0_nodes);

			th2 = claim_element(tr0_nodes, "TH", {}, false);
			var th2_nodes = children(th2);

			t8 = claim_text(th2_nodes, "스트리머2");
			th2_nodes.forEach(detach_dev);
			tr0_nodes.forEach(detach_dev);
			thead_nodes.forEach(detach_dev);
			t9 = claim_space(table_nodes);

			tbody = claim_element(table_nodes, "TBODY", {}, false);
			var tbody_nodes = children(tbody);

			tr1 = claim_element(tbody_nodes, "TR", {}, false);
			var tr1_nodes = children(tr1);

			td0 = claim_element(tr1_nodes, "TD", {}, false);
			var td0_nodes = children(td0);

			datepicker.$$.fragment.l(td0_nodes);
			td0_nodes.forEach(detach_dev);
			t10 = claim_space(tr1_nodes);

			td1 = claim_element(tr1_nodes, "TD", {}, false);
			var td1_nodes = children(td1);

			streamerautocomplete0.$$.fragment.l(td1_nodes);
			td1_nodes.forEach(detach_dev);
			t11 = claim_space(tr1_nodes);

			td2 = claim_element(tr1_nodes, "TD", {}, false);
			var td2_nodes = children(td2);

			streamerautocomplete1.$$.fragment.l(td2_nodes);
			td2_nodes.forEach(detach_dev);
			tr1_nodes.forEach(detach_dev);
			tbody_nodes.forEach(detach_dev);
			table_nodes.forEach(detach_dev);
			t12 = claim_space(div7_nodes);

			div2 = claim_element(div7_nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			div1 = claim_element(div2_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			a0 = claim_element(div1_nodes, "A", { href: true, for: true, class: true }, false);
			var a0_nodes = children(a0);

			if_block0.l(a0_nodes);
			a0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t13 = claim_space(div2_nodes);
			migrationtimeline0.$$.fragment.l(div2_nodes);
			div2_nodes.forEach(detach_dev);
			t14 = claim_space(div7_nodes);

			div4 = claim_element(div7_nodes, "DIV", { class: true }, false);
			var div4_nodes = children(div4);

			div3 = claim_element(div4_nodes, "DIV", { class: true }, false);
			var div3_nodes = children(div3);

			div3_nodes.forEach(detach_dev);
			t15 = claim_space(div4_nodes);
			migrations.$$.fragment.l(div4_nodes);
			div4_nodes.forEach(detach_dev);
			t16 = claim_space(div7_nodes);

			div6 = claim_element(div7_nodes, "DIV", { class: true }, false);
			var div6_nodes = children(div6);

			div5 = claim_element(div6_nodes, "DIV", {}, false);
			var div5_nodes = children(div5);

			a1 = claim_element(div5_nodes, "A", { href: true, for: true, class: true }, false);
			var a1_nodes = children(a1);

			if_block1.l(a1_nodes);
			a1_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			t17 = claim_space(div6_nodes);
			migrationtimeline1.$$.fragment.l(div6_nodes);
			div6_nodes.forEach(detach_dev);
			div7_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(h1, "class", "md:text-3xl text-2xl inline-block");
			add_location(h1, file$7, 6, 2, 134);
			attr_dev(div0, "class", "p-6 xl:absolute relative container m-auto");
			add_location(div0, file$7, 5, 0, 76);
			add_location(th0, file$7, 19, 8, 482);
			add_location(th1, file$7, 20, 8, 504);
			add_location(th2, file$7, 21, 8, 529);
			add_location(tr0, file$7, 18, 6, 469);
			add_location(thead, file$7, 17, 4, 455);
			add_location(td0, file$7, 26, 6, 598);
			add_location(td1, file$7, 38, 6, 955);
			add_location(td2, file$7, 47, 6, 1353);
			add_location(tr1, file$7, 25, 4, 587);
			add_location(tbody, file$7, 24, 4, 575);
			attr_dev(table, "class", "text-center mb-12 mt-6");
			add_location(table, file$7, 16, 2, 412);
			attr_dev(a0, "href", a0_href_value = ctx.streamer1? '/streamer/' + ctx.streamer1.id : '');
			attr_dev(a0, "for", "migration-streamer-search1-input");
			attr_dev(a0, "class", "w-24 flex flex-col items-center justify-center overflow-visible relative");
			add_location(a0, file$7, 61, 6, 1857);
			attr_dev(div1, "class", "");
			add_location(div1, file$7, 60, 4, 1836);
			attr_dev(div2, "class", "flex flex-row w-full items-center z-20");
			add_location(div2, file$7, 59, 2, 1779);
			attr_dev(div3, "class", "w-24");
			add_location(div3, file$7, 79, 4, 2637);
			attr_dev(div4, "class", "flex flex-row w-full");
			add_location(div4, file$7, 78, 2, 2598);
			attr_dev(a1, "href", a1_href_value = ctx.streamer2? '/streamer/' + ctx.streamer2.id : '');
			attr_dev(a1, "for", "migration-streamer-search2-input");
			attr_dev(a1, "class", "w-24 flex flex-col items-center justify-center overflow-visible cursor-pointer relative");
			add_location(a1, file$7, 88, 6, 2908);
			add_location(div5, file$7, 87, 4, 2896);
			attr_dev(div6, "class", "flex flex-row w-full items-center z-10");
			add_location(div6, file$7, 86, 2, 2839);
			attr_dev(div7, "class", "container m-auto flex flex-col items-stretch pb-8");
			add_location(div7, file$7, 15, 0, 346);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, div0, anchor);
			append_dev(div0, h1);
			append_dev(h1, t1);
			append_dev(div0, t2);
			mount_component(tip, div0, null);
			insert_dev(target, t3, anchor);
			insert_dev(target, div7, anchor);
			append_dev(div7, table);
			append_dev(table, thead);
			append_dev(thead, tr0);
			append_dev(tr0, th0);
			append_dev(th0, t4);
			append_dev(tr0, t5);
			append_dev(tr0, th1);
			append_dev(th1, t6);
			append_dev(tr0, t7);
			append_dev(tr0, th2);
			append_dev(th2, t8);
			append_dev(table, t9);
			append_dev(table, tbody);
			append_dev(tbody, tr1);
			append_dev(tr1, td0);
			mount_component(datepicker, td0, null);
			append_dev(tr1, t10);
			append_dev(tr1, td1);
			mount_component(streamerautocomplete0, td1, null);
			append_dev(tr1, t11);
			append_dev(tr1, td2);
			mount_component(streamerautocomplete1, td2, null);
			append_dev(div7, t12);
			append_dev(div7, div2);
			append_dev(div2, div1);
			append_dev(div1, a0);
			if_block0.m(a0, null);
			append_dev(div2, t13);
			mount_component(migrationtimeline0, div2, null);
			append_dev(div7, t14);
			append_dev(div7, div4);
			append_dev(div4, div3);
			append_dev(div4, t15);
			mount_component(migrations, div4, null);
			append_dev(div7, t16);
			append_dev(div7, div6);
			append_dev(div6, div5);
			append_dev(div5, a1);
			if_block1.m(a1, null);
			append_dev(div6, t17);
			mount_component(migrationtimeline1, div6, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.title_sufix) && title_value !== (title_value = " 트수gg - 시청자 이동" + ctx.title_sufix)) {
				document.title = title_value;
			}

			var tip_changes = {};
			if (changed.$$scope) tip_changes.$$scope = { changed, ctx };
			tip.$set(tip_changes);

			var datepicker_changes = {};
			if (changed.date) datepicker_changes.selected = ctx.date;
			if (changed.$$scope || changed.date) datepicker_changes.$$scope = { changed, ctx };
			datepicker.$set(datepicker_changes);

			var streamerautocomplete0_changes = {};
			if (changed.streamer1) streamerautocomplete0_changes.input_value = ctx.streamer1? ctx.streamer1.name: "";
			if (!updating_onselect && changed.on_streamer_search1) {
				streamerautocomplete0_changes.onselect = ctx.on_streamer_search1;
			}
			streamerautocomplete0.$set(streamerautocomplete0_changes);

			var streamerautocomplete1_changes = {};
			if (changed.streamer2) streamerautocomplete1_changes.input_value = ctx.streamer2? ctx.streamer2.name: "";
			if (!updating_onselect_1 && changed.on_streamer_search2) {
				streamerautocomplete1_changes.onselect = ctx.on_streamer_search2;
			}
			streamerautocomplete1.$set(streamerautocomplete1_changes);

			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block0) {
				if_block0.p(changed, ctx);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);
				if (if_block0) {
					if_block0.c();
					if_block0.m(a0, null);
				}
			}

			if ((!current || changed.streamer1) && a0_href_value !== (a0_href_value = ctx.streamer1? '/streamer/' + ctx.streamer1.id : '')) {
				attr_dev(a0, "href", a0_href_value);
			}

			var migrationtimeline0_changes = {};
			if (changed.streamer1) migrationtimeline0_changes.streamer = ctx.streamer1;
			if (changed.date) migrationtimeline0_changes.date = ctx.date;
			migrationtimeline0.$set(migrationtimeline0_changes);

			var migrations_changes = {};
			if (changed.viewer_migrations) migrations_changes.migrations = ctx.viewer_migrations;
			if (changed.streamer1) migrations_changes.id1 = ctx.streamer1 && ctx.streamer1.id;
			if (changed.streamer2) migrations_changes.id2 = ctx.streamer2 && ctx.streamer2.id;
			migrations.$set(migrations_changes);

			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(changed, ctx)) && if_block1) {
				if_block1.p(changed, ctx);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);
				if (if_block1) {
					if_block1.c();
					if_block1.m(a1, null);
				}
			}

			if ((!current || changed.streamer2) && a1_href_value !== (a1_href_value = ctx.streamer2? '/streamer/' + ctx.streamer2.id : '')) {
				attr_dev(a1, "href", a1_href_value);
			}

			var migrationtimeline1_changes = {};
			if (changed.streamer2) migrationtimeline1_changes.streamer = ctx.streamer2;
			if (changed.date) migrationtimeline1_changes.date = ctx.date;
			migrationtimeline1.$set(migrationtimeline1_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(tip.$$.fragment, local);

			transition_in(datepicker.$$.fragment, local);

			transition_in(streamerautocomplete0.$$.fragment, local);

			transition_in(streamerautocomplete1.$$.fragment, local);

			transition_in(migrationtimeline0.$$.fragment, local);

			transition_in(migrations.$$.fragment, local);

			transition_in(migrationtimeline1.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(tip.$$.fragment, local);
			transition_out(datepicker.$$.fragment, local);
			transition_out(streamerautocomplete0.$$.fragment, local);
			transition_out(streamerautocomplete1.$$.fragment, local);
			transition_out(migrationtimeline0.$$.fragment, local);
			transition_out(migrations.$$.fragment, local);
			transition_out(migrationtimeline1.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(div0);
			}

			destroy_component(tip);

			if (detaching) {
				detach_dev(t3);
				detach_dev(div7);
			}

			destroy_component(datepicker);

			destroy_component(streamerautocomplete0);

			destroy_component(streamerautocomplete1);

			if_block0.d();

			destroy_component(migrationtimeline0);

			destroy_component(migrations);

			if_block1.d();

			destroy_component(migrationtimeline1);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$7.name, type: "component", source: "", ctx });
	return block;
}

async function preload(page, session) {
  if(page.query.id1 && page.query.id2 && page.query.date) {
    let [streamer1, streamer2] = await API.thin_streamers([page.query.id1, page.query.id2]);
    let time = new Date(page.query.date-0); time.setHours(0,0,0,0);
    let from = time,
        to = new Date(time.getTime() + 1000*60*60*24);
    let viewer_migrations = await API.viewer_migration_counts(page.query.id1, page.query.id2, from, to);
    let date = new Date(page.query.date-0);
    return { streamer1, streamer2, viewer_migrations, date };
  }
  else {
    let date = new Date(); date.setHours(0,0,0,0);
    return { date };
  }
}

const func = (d) => d.toLocaleDateString();

function instance$7($$self, $$props, $$invalidate) {
	

  let { streamer1, streamer2, viewer_migrations = [], date = new Date() } = $$props;
  let title_sufix = streamer1 && streamer2? `| ${streamer1.name} <-> ${streamer2.name}`: '';



  function try_load(){
    if(streamer1 && streamer2 && date){
      window.location.search = `id1=${streamer1.id}&id2=${streamer2.id}&date=${date.getTime()}`;
    }
  }

  function on_date_pick(e) {
    if(e.detail.date != date){
      $$invalidate('date', date = e.detail.date);
      try_load();
    }
  }
  function on_streamer_search1(target) {
    if(streamer1 != target){
      $$invalidate('streamer1', streamer1 = target);
      try_load();
    }
  }
  function on_streamer_search2(target) {
    if(streamer2 != target){
      $$invalidate('streamer2', streamer2 = target);
      try_load();
    }
  }

	const writable_props = ['streamer1', 'streamer2', 'viewer_migrations', 'date'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Index> was created with unknown prop '${key}'`);
	});

	function streamerautocomplete0_onselect_binding(value) {
		on_streamer_search1 = value;
		$$invalidate('on_streamer_search1', on_streamer_search1);
	}

	function streamerautocomplete1_onselect_binding(value_1) {
		on_streamer_search2 = value_1;
		$$invalidate('on_streamer_search2', on_streamer_search2);
	}

	$$self.$set = $$props => {
		if ('streamer1' in $$props) $$invalidate('streamer1', streamer1 = $$props.streamer1);
		if ('streamer2' in $$props) $$invalidate('streamer2', streamer2 = $$props.streamer2);
		if ('viewer_migrations' in $$props) $$invalidate('viewer_migrations', viewer_migrations = $$props.viewer_migrations);
		if ('date' in $$props) $$invalidate('date', date = $$props.date);
	};

	$$self.$capture_state = () => {
		return { streamer1, streamer2, viewer_migrations, date, title_sufix };
	};

	$$self.$inject_state = $$props => {
		if ('streamer1' in $$props) $$invalidate('streamer1', streamer1 = $$props.streamer1);
		if ('streamer2' in $$props) $$invalidate('streamer2', streamer2 = $$props.streamer2);
		if ('viewer_migrations' in $$props) $$invalidate('viewer_migrations', viewer_migrations = $$props.viewer_migrations);
		if ('date' in $$props) $$invalidate('date', date = $$props.date);
		if ('title_sufix' in $$props) $$invalidate('title_sufix', title_sufix = $$props.title_sufix);
	};

	return {
		Date,
		streamer1,
		streamer2,
		viewer_migrations,
		date,
		title_sufix,
		on_date_pick,
		on_streamer_search1,
		on_streamer_search2,
		streamerautocomplete0_onselect_binding,
		streamerautocomplete1_onselect_binding
	};
}

class Index extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, ["streamer1", "streamer2", "viewer_migrations", "date"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Index", options, id: create_fragment$7.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.streamer1 === undefined && !('streamer1' in props)) {
			console.warn("<Index> was created without expected prop 'streamer1'");
		}
		if (ctx.streamer2 === undefined && !('streamer2' in props)) {
			console.warn("<Index> was created without expected prop 'streamer2'");
		}
	}

	get streamer1() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set streamer1(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get streamer2() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set streamer2(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get viewer_migrations() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set viewer_migrations(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get date() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set date(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Index;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNjAyN2M5ZGUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL01pZ3JhdGlvblRpbWVsaW5lLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL01pZ3JhdGlvbnMuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1jYWxlbmRhci9zcmMvQ29tcG9uZW50cy9saWIvaGVscGVycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvdHJhbnNpdGlvbi9pbmRleC5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWNhbGVuZGFyL3NyYy9Db21wb25lbnRzL1dlZWsuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1jYWxlbmRhci9zcmMvQ29tcG9uZW50cy9Nb250aC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWNhbGVuZGFyL3NyYy9Db21wb25lbnRzL05hdkJhci5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWNhbGVuZGFyL3NyYy9Db21wb25lbnRzL1BvcG92ZXIuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RpbWVVdGlscy9kaXN0L3RpbWVVdGlscy5lc20uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWNhbGVuZGFyL3NyYy9Db21wb25lbnRzL2xpYi9rZXlDb2Rlcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtY2FsZW5kYXIvc3JjL0NvbXBvbmVudHMvRGF0ZXBpY2tlci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL21pZ3JhdGlvbi9pbmRleC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPGRpdiBjbGFzcz1cInctZnVsbCByZWxhdGl2ZVwiPlxuICA8ZGl2IGNsYXNzPVwidy1mdWxsXCI+XG4gICAgPHN2ZyBjbGFzcz1cImZsZXgtZ3JvdyBib3JkZXItZ3JheS05MDAgdy1mdWxsXCIgd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0gYmluZDp0aGlzPXtzdmd9PlxuICAgICAgPGRlZnM+XG4gICAgICAgIHsjZWFjaCBPYmplY3QudmFsdWVzKGdhbWVzKSBhcyBnYW1lfVxuICAgICAgICA8cGF0dGVybiBpZD1cImdhbWUtYm94LWFydC17Z2FtZS5pZH1cIiB3aWR0aD17Z2FtZV9ib3hfYXJ0X3dpZHRofSBoZWlnaHQ9e2dhbWVfYm94X2FydF9oZWlnaHR9IHBhdHRlcm5Vbml0cz1cInVzZXJTcGFjZU9uVXNlXCIgeT17aGVpZ2h0KjAuMjV9PlxuICAgICAgICAgIHsjaWYgZ2FtZS5ib3hfYXJ0X3VybH1cbiAgICAgICAgICAgIDxpbWFnZSB4bGluazpocmVmPXtnYW1lLmJveF9hcnRfdXJsLnJlcGxhY2UoXCJ7d2lkdGh9XCIsIGdhbWVfYm94X2FydF93aWR0aCkucmVwbGFjZShcIntoZWlnaHR9XCIsIGdhbWVfYm94X2FydF9oZWlnaHQpfSB3aWR0aD17Z2FtZV9ib3hfYXJ0X3dpZHRofSBoZWlnaHQ9e2dhbWVfYm94X2FydF9oZWlnaHR9IHg9MCB5PTAgPiA8L2ltYWdlPlxuICAgICAgICAgIHsvaWZ9XG4gICAgICAgIDwvcGF0dGVybj5cbiAgICAgICAgey9lYWNofVxuICAgICAgICA8bWFya2VyIGlkPVwiYmlnaGVhZFwiIFxuICAgICAgICAgIG1hcmtlcldpZHRoPVwiNFwiIG1hcmtlckhlaWdodD1cIjhcIiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmWD1cIjAuMVwiIHJlZlk9XCI0XCIgb3JpZW50PVwiYXV0b1wiID5cbiAgICAgICAgICA8cGF0aCBkPVwiTTAsMCBWOCBMNCw0IFpcIiBmaWxsPVwiIzQ0NFwiIC8+XG4gICAgICAgIDwvbWFya2VyPlxuICAgICAgPC9kZWZzPlxuICAgICAgPCEtLTxnIHNoYXBlLXJlbmRlcmluZz1cImNyaXNwRWRnZXNcIj5cbiAgICAgICAgPGxpbmUgeDE9XCJ7d2lkdGgqMC84fVwiIHgyPVwie3dpZHRoKjAvOH1cIiB5MT1cIjBcIiB5Mj1cIntoZWlnaHR9XCIgc3Ryb2tlLXdpZHRoPVwiMS4wXCIgc3Ryb2tlPVwiIzQ0NFwiPjwvbGluZT5cbiAgICAgICAgPHRleHQgeD1cIjBcIiB5PVwiMFwiIGZpbGw9XCIjNDQ0XCIgZm9udC1zaXplPVwiMTBcIiBmb250LWZhbWlseT1cIkFyaWFsXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKHt3aWR0aCowLzggKyAzfSwgMykgcm90YXRlKDkwKVwiPlxuICAgICAgICAgIDBhbVxuICAgICAgICA8L3RleHQ+XG4gICAgICAgIDxsaW5lIHgxPVwie3dpZHRoKjEvOH1cIiB4Mj1cInt3aWR0aCoxLzh9XCIgeTE9XCIwXCIgeTI9XCJ7aGVpZ2h0fVwiIHN0cm9rZS13aWR0aD1cIjEuMFwiIHN0cm9rZT1cIiNhYWFcIj48L2xpbmU+XG4gICAgICAgIDx0ZXh0IHg9XCIwXCIgeT1cIjBcIiBmaWxsPVwiI2FhYVwiIGZvbnQtc2l6ZT1cIjEwXCIgZm9udC1mYW1pbHk9XCJBcmlhbFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSh7d2lkdGgqMS84ICsgM30sIDMpIHJvdGF0ZSg5MClcIj5cbiAgICAgICAgICAzYW1cbiAgICAgICAgPC90ZXh0PlxuICAgICAgICA8bGluZSB4MT1cInt3aWR0aCoyLzh9XCIgeDI9XCJ7d2lkdGgqMi84fVwiIHkxPVwiMFwiIHkyPVwie2hlaWdodH1cIiBzdHJva2Utd2lkdGg9XCIxLjBcIiBzdHJva2U9XCIjNjY2XCI+PC9saW5lPlxuICAgICAgICA8dGV4dCBmaWxsPVwiIzY2NlwiIGZvbnQtc2l6ZT1cIjEwXCIgZm9udC1mYW1pbHk9XCJBcmlhbFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSh7d2lkdGgqMi84ICsgM30sIDMpIHJvdGF0ZSg5MClcIj5cbiAgICAgICAgICA2YW1cbiAgICAgICAgPC90ZXh0PlxuICAgICAgICA8bGluZSB4MT1cInt3aWR0aCozLzh9XCIgeDI9XCJ7d2lkdGgqMy84fVwiIHkxPVwiMFwiIHkyPVwie2hlaWdodH1cIiBzdHJva2Utd2lkdGg9XCIxLjBcIiBzdHJva2U9XCIjYWFhXCI+PC9saW5lPlxuICAgICAgICA8dGV4dCBmaWxsPVwiI2FhYVwiIGZvbnQtc2l6ZT1cIjEwXCIgZm9udC1mYW1pbHk9XCJBcmlhbFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSh7d2lkdGgqMy84ICsgM30sIDMpIHJvdGF0ZSg5MClcIj5cbiAgICAgICAgICA5YW1cbiAgICAgICAgPC90ZXh0PlxuICAgICAgICA8bGluZSB4MT1cInt3aWR0aCo0Lzh9XCIgeDI9XCJ7d2lkdGgqNC84fVwiIHkxPVwiMFwiIHkyPVwie2hlaWdodH1cIiBzdHJva2Utd2lkdGg9XCIxLjBcIiBzdHJva2U9XCIjNDQ0XCI+PC9saW5lPlxuICAgICAgICA8dGV4dCBmaWxsPVwiIzQ0NFwiIGZvbnQtc2l6ZT1cIjEwXCIgZm9udC1mYW1pbHk9XCJBcmlhbFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSh7d2lkdGgqNC84ICsgM30sIDMpIHJvdGF0ZSg5MClcIj5cbiAgICAgICAgICDsoJXsmKRcbiAgICAgICAgPC90ZXh0PlxuICAgICAgICA8bGluZSB4MT1cInt3aWR0aCo1Lzh9XCIgeDI9XCJ7d2lkdGgqNS84fVwiIHkxPVwiMFwiIHkyPVwie2hlaWdodH1cIiBzdHJva2Utd2lkdGg9XCIxLjBcIiBzdHJva2U9XCIjYWFhXCI+PC9saW5lPlxuICAgICAgICA8dGV4dCBmaWxsPVwiI2FhYVwiIGZvbnQtc2l6ZT1cIjEwXCIgZm9udC1mYW1pbHk9XCJBcmlhbFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSh7d2lkdGgqNS84ICsgM30sIDMpIHJvdGF0ZSg5MClcIj5cbiAgICAgICAgICAzcG1cbiAgICAgICAgPC90ZXh0PlxuICAgICAgICA8bGluZSB4MT1cInt3aWR0aCo2Lzh9XCIgeDI9XCJ7d2lkdGgqNi84fVwiIHkxPVwiMFwiIHkyPVwie2hlaWdodH1cIiBzdHJva2Utd2lkdGg9XCIxLjBcIiBzdHJva2U9XCIjNjY2XCI+PC9saW5lPlxuICAgICAgICA8dGV4dCBmaWxsPVwiIzY2NlwiIGZvbnQtc2l6ZT1cIjEwXCIgZm9udC1mYW1pbHk9XCJBcmlhbFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSh7d2lkdGgqNi84ICsgM30sIDMpIHJvdGF0ZSg5MClcIj5cbiAgICAgICAgICA2cG1cbiAgICAgICAgPC90ZXh0PlxuICAgICAgICA8bGluZSB4MT1cInt3aWR0aCo3Lzh9XCIgeDI9XCJ7d2lkdGgqNy84fVwiIHkxPVwiMFwiIHkyPVwie2hlaWdodH1cIiBzdHJva2Utd2lkdGg9XCIxLjBcIiBzdHJva2U9XCIjYWFhXCI+PC9saW5lPlxuICAgICAgICA8dGV4dCBmaWxsPVwiI2FhYVwiIGZvbnQtc2l6ZT1cIjEwXCIgZm9udC1mYW1pbHk9XCJBcmlhbFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSh7d2lkdGgqNy84ICsgM30sIDMpIHJvdGF0ZSg5MClcIj5cbiAgICAgICAgICA5cG1cbiAgICAgICAgPC90ZXh0PlxuICAgICAgICA8bGluZSB4MT1cInt3aWR0aCo4Lzh9XCIgeDI9XCJ7d2lkdGgqOC84fVwiIHkxPVwiMFwiIHkyPVwie2hlaWdodH1cIiBzdHJva2Utd2lkdGg9XCIxLjBcIiBzdHJva2U9XCIjNDQ0XCI+PC9saW5lPlxuICAgICAgICA8dGV4dCB4PVwiMFwiIHk9XCIwXCIgZmlsbD1cIiM0NDRcIiBmb250LXNpemU9XCIxMFwiIGZvbnQtZmFtaWx5PVwiQXJpYWxcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoe3dpZHRoKjgvOCArIDN9LCAzKSByb3RhdGUoOTApXCI+XG4gICAgICAgICAgMTJwbVxuICAgICAgICA8L3RleHQ+XG4gICAgICA8L2c+LS0+XG4gICAgICA8ZyBzdHJva2U9XCIjQTBBRUMwXCIgc3Ryb2tlLXdpZHRoPTEuMD5cbiAgICAgIDxwYXRoIFxuICAgICAgICAgZD1cIk0wLHtoZWlnaHQqMC41fSBMe3dpZHRoIC0gNH0se2hlaWdodCowLjV9XCIgXG4gICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICBtYXJrZXItZW5kPVwidXJsKCNiaWdoZWFkKVwiXG4gICAgICAvPiBcbiAgICAgICAgeyNlYWNoIGRhdGFfY2h1bmtzIGFzIGRhdGF9XG4gICAgICAgICAgeyNpZiBkYXRhWzBdICYmIGRhdGFbMF1bNV0gJiYgZGF0YVswXVs1XS5nYW1lICYmIGdhbWVzW2RhdGFbMF1bNV0uZ2FtZS5pZF0gJiYgZGF0YVswXVs1XS5nYW1lLmJveF9hcnRfdXJsfVxuICAgICAgICAgICAgPHBhdGggXG4gICAgICAgICAgICAgIHN0eWxlPVwiZmlsbDp1cmwoI2dhbWUtYm94LWFydC17ZGF0YVswXVs1XS5nYW1lLmlkfSk7IHN0cm9rZS1saW5lam9pbjogcm91bmQ7XCJcbiAgICAgICAgICAgICAgIGQ9XCJ7ZGF0YS5wYXRofVwiIC8+XG4gICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgPHBhdGggXG4gICAgICAgICAgICAgIHN0eWxlPVwic3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcIlxuICAgICAgICAgICAgICBmaWxsPVwiIzAwMDAwMFwiIFxuICAgICAgICAgICAgICAgZD1cIntkYXRhLnBhdGh9XCIgLz5cbiAgICAgICAgICB7L2lmfVxuICAgICAgICB7L2VhY2h9XG4gICAgICA8L2c+XG4gICAgICA8ZyBzaGFwZS1yZW5kZXJpbmc9XCJjcmlzcEVkZ2VzXCI+XG4gICAgICAgIDxsaW5lIGNsYXNzOmhpZGRlbj17dG9vbHRpcF9kYXRhID09IG51bGx9IHgxPXt0b29sdGlwX3h9IHgyPXt0b29sdGlwX3h9IHkxPXswfSB5Mj17aGVpZ2h0fSBzdHJva2U9XCIjMDAwMDAwXCIgc3Ryb2tlLXdpZHRoPTAuNSBcbiAgICAgICAgICBzdHJva2UtZGFzaGFycmF5PVwiNCAxXCJcbiAgICAgICAgICAvPlxuICAgICAgPC9nPlxuICAgIDwvc3ZnPlxuICA8L2Rpdj5cblx0eyNpZiB0b29sdGlwX2RhdGF9IFxuICAgIDxkaXYgY2xhc3M9XCJhYnNvbHV0ZSBiZy13aGl0ZSBvcGFjaXR5LTc1IHotNTBcIiBzdHlsZT1cInt0b29sdGlwX3ggPCB3aWR0aCowLjU/ICdsZWZ0OicgKyAodG9vbHRpcF94KzUpICsgJ3B4JzogJ3JpZ2h0OicgKyAoKHdpZHRoLXRvb2x0aXBfeCkrNSkgKyAncHgnfTsgdG9wOiB7dG9vbHRpcF95ICsgNX1weFwiPiBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmbGV4IGZsZXgtY29sIGZvbnQtc2FucyBjdXN0b20tdG9vbHRpcCBwLTMgdy00OCBmbGV4LXVud3JhcFwiPiBcblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cInRleHQtZ3JheS02MDAgdGV4dC14cyBmb250LXNlbWlib2xkIHRyYWNraW5nLXdpZGVcIj5cblx0XHRcdFx0XHRcdFx0XHR7dG9vbHRpcF9kYXRhX3RpbWVfZm9ybWF0KHRvb2x0aXBfZGF0YSl9XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuICAgICAgICAgICAgICA8cCBjbGFzcz1cImJyZWFrLWFsbCBtdC0xIHRleHQtZ3JheSBpdGFsaWMgdHJhY2tpbmctdGlnaHRcIiBzdHlsZT1cImZvbnQtc2l6ZTogMC41cmVtXCI+XG5cdFx0XHRcdFx0XHRcdFx0e3Rvb2x0aXBfZGF0YVs1XS50aXRsZX1cbiAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtdC0xIGZsZXggZmxleC1yb3cgZmxleC13cmFwIGl0ZW1zLWNlbnRlciB0ZXh0LWdyYXktOTAwXCI+XG4gICAgICAgICAgICAgICAgICA8c3ZnIGFyZWEtaGlkZGVuPVwidHJ1ZVwiIHJvbGU9XCJpbWdcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCB7ZmFVc2VyLmljb25bMF19IHtmYVVzZXIuaWNvblsxXX1cIiBjbGFzcz1cInctNCBoLTQgbXItMiBvdmVyZmxvdy12aXNpYmxlIGlubGluZS1ibG9ja1wiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBmaWxsPVwiY3VycmVudENvbG9yXCIgZD1cIntmYVVzZXIuaWNvbls0XX1cIi8+XG4gICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICAgIDxiPnt0b29sdGlwX2RhdGFbMV1966qFPC9iPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmbGV4IGZsZXgtcm93IGZsZXgtd3JhcCBpdGVtcy1jZW50ZXIgdGV4dC1ncmF5LTYwMCB0ZXh0LXhzXCI+XG4gICAgICAgICAgICAgICAgICA8c3ZnIGFyZWEtaGlkZGVuPVwidHJ1ZVwiIHJvbGU9XCJpbWdcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCB7ZmFVc2VyU2VjcmV0Lmljb25bMF19IHtmYVVzZXJTZWNyZXQuaWNvblsxXX1cIiBjbGFzcz1cInctMyBoLTMgbXItMiBvdmVyZmxvdy12aXNpYmxlIGlubGluZS1ibG9ja1wiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBmaWxsPVwiY3VycmVudENvbG9yXCIgZD1cIntmYVVzZXJTZWNyZXQuaWNvbls0XX1cIi8+XG4gICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICAgIDxiPnt0b29sdGlwX2RhdGFbMV0gLSB0b29sdGlwX2RhdGFbMl1966qFPC9iPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmbGV4IGZsZXgtcm93IGZsZXgtd3JhcCBpdGVtcy1jZW50ZXIgdGV4dC15ZWxsb3ctNzAwIHRleHQteHNcIj5cbiAgICAgICAgICAgICAgICAgIDxzdmcgYXJlYS1oaWRkZW49XCJ0cnVlXCIgcm9sZT1cImltZ1wiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIHtmYUtleS5pY29uWzBdfSB7ZmFLZXkuaWNvblsxXX1cIiBjbGFzcz1cInctMyBoLTMgbXItMiBvdmVyZmxvdy12aXNpYmxlIGlubGluZS1ibG9ja1wiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBmaWxsPVwiY3VycmVudENvbG9yXCIgZD1cIntmYUtleS5pY29uWzRdfVwiLz5cbiAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgICAgPGI+e3Rvb2x0aXBfZGF0YVsyXX3rqoU8L2I+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm10LTEgZmxleCBmbGV4LXJvdyBmbGV4LXdyYXAgaXRlbXMtY2VudGVyXCIgc3R5bGU9XCJjb2xvcjogI0ZGNkY2MVwiPlxuICAgICAgICAgICAgICAgICAgPHN2ZyBhcmVhLWhpZGRlbj1cInRydWVcIiByb2xlPVwiaW1nXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAge2ZhQ29tbWVudERvdHMuaWNvblswXX0ge2ZhQ29tbWVudERvdHMuaWNvblsxXX1cIiBjbGFzcz1cInctNCBoLTQgbXItMiBvdmVyZmxvdy12aXNpYmxlIGlubGluZS1ibG9ja1wiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBmaWxsPVwiY3VycmVudENvbG9yXCIgZD1cIntmYUNvbW1lbnREb3RzLmljb25bNF19XCIvPlxuICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgICA8Yj57dG9vbHRpcF9kYXRhWzRdLnRvRml4ZWQoMSl97LGE7YyFL+y0iDwvYj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibXQtMSBmbGV4IGZsZXgtcm93IGZsZXgtd3JhcCBpdGVtcy1jZW50ZXIgdGV4dC1wdXJwbGUtNjAwXCI+XG4gICAgICAgICAgICAgICAgICA8c3ZnIGFyZWEtaGlkZGVuPVwidHJ1ZVwiIHJvbGU9XCJpbWdcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCB7ZmFIaXN0b3J5Lmljb25bMF19IHtmYUhpc3RvcnkuaWNvblsxXX1cIiBjbGFzcz1cInctNCBoLTQgbXItMiBvdmVyZmxvdy12aXNpYmxlIGlubGluZS1ibG9ja1wiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBmaWxsPVwiY3VycmVudENvbG9yXCIgZD1cIntmYUhpc3RvcnkuaWNvbls0XX1cIi8+XG4gICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICAgIDxiPuyXhe2DgOyehCB7TWF0aC5mbG9vcigodG9vbHRpcF9kYXRhWzBdIC0gdG9vbHRpcF9kYXRhWzVdLnN0YXJ0ZWRfYXQpIC8gMzYwMCl97Iuc6rCEe01hdGgucm91bmQoKHRvb2x0aXBfZGF0YVswXSAtIHRvb2x0aXBfZGF0YVs1XS5zdGFydGVkX2F0KSAlIDM2MDAgLyA2MCl967aEPC9iPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8cCBjbGFzcz1cIm10LTIgdGV4dC14cyBweC0xIGJvcmRlciByb3VuZGVkLWZ1bGwgdGV4dC13aGl0ZSB0ZXh0LWNlbnRlclwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjoge2RhcmtfcmFuZG9tX2NvbG9yKHRvb2x0aXBfZGF0YVs1XS5nYW1lICYmIHRvb2x0aXBfZGF0YVs1XS5nYW1lLmlkIHx8IDApfVwiPlxuICAgICAgICAgICAgICAgIHt0b29sdGlwX2RhdGFbNV0uZ2FtZSAhPSBudWxsPyB0b29sdGlwX2RhdGFbNV0uZ2FtZS5uYW1lIDogXCJcIn1cbiAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuXHR7L2lmfVxuPC9kaXY+XG5cbjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiPlxuICBpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XG4gIGxldCBtYXhfeV9heGlzID0gd3JpdGFibGUoMCk7XG4gIGxldCBtYXhfeV9heGlzX3JpZ2h0ID0gd3JpdGFibGUoMCk7XG5cblx0ZnVuY3Rpb24gdG9vbHRpcF9kYXRhX3RpbWVfZm9ybWF0KGRhdGEpIHtcblx0XHRsZXQgZCA9IG5ldyBEYXRlKGRhdGFbMF0qMTAwMCksXG5cdFx0XHRcdGggPSBkLmdldEhvdXJzKCksIG0gPSBkLmdldE1pbnV0ZXMoKTtcblx0XHRyZXR1cm4gYCR7aDwxMj8gXCJBTVwiOiBcIlBNXCJ9ICR7KFwiMFwiKyhoPjEyPyBoLTEyOiBoKSkuc2xpY2UoLTIpfTokeyhcIjBcIittKS5zbGljZSgtMil9YDtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuaW1wb3J0IHsgZmFVc2VyIH0gZnJvbSAnQGZvcnRhd2Vzb21lL2ZyZWUtc29saWQtc3ZnLWljb25zL2ZhVXNlcidcbmltcG9ydCB7IGZhVXNlckxvY2sgfSBmcm9tICdAZm9ydGF3ZXNvbWUvZnJlZS1zb2xpZC1zdmctaWNvbnMvZmFVc2VyTG9jaydcbmltcG9ydCB7IGZhVXNlclNlY3JldCB9IGZyb20gJ0Bmb3J0YXdlc29tZS9mcmVlLXNvbGlkLXN2Zy1pY29ucy9mYVVzZXJTZWNyZXQnXG5pbXBvcnQgeyBmYVVzZXJDaGVjayB9IGZyb20gJ0Bmb3J0YXdlc29tZS9mcmVlLXNvbGlkLXN2Zy1pY29ucy9mYVVzZXJDaGVjaydcbmltcG9ydCB7IGZhQ29tbWVudERvdHMgfSBmcm9tICdAZm9ydGF3ZXNvbWUvZnJlZS1zb2xpZC1zdmctaWNvbnMvZmFDb21tZW50RG90cydcbmltcG9ydCB7IGZhS2V5IH0gZnJvbSAnQGZvcnRhd2Vzb21lL2ZyZWUtc29saWQtc3ZnLWljb25zL2ZhS2V5J1xuaW1wb3J0IHsgZmFTdW4gfSBmcm9tICdAZm9ydGF3ZXNvbWUvZnJlZS1zb2xpZC1zdmctaWNvbnMvZmFTdW4nXG5pbXBvcnQgeyBmYU1vb24gfSBmcm9tICdAZm9ydGF3ZXNvbWUvZnJlZS1zb2xpZC1zdmctaWNvbnMvZmFNb29uJ1xuaW1wb3J0IHsgZmFFeHRlcm5hbExpbmtBbHQgfSBmcm9tICdAZm9ydGF3ZXNvbWUvZnJlZS1zb2xpZC1zdmctaWNvbnMvZmFFeHRlcm5hbExpbmtBbHQnXG5pbXBvcnQgeyBmYUhpc3RvcnkgfSBmcm9tICdAZm9ydGF3ZXNvbWUvZnJlZS1zb2xpZC1zdmctaWNvbnMvZmFIaXN0b3J5JztcbmltcG9ydCB7IGRhcmtfcmFuZG9tX2NvbG9yLCBmaW5kTGFzdEluZGV4IH0gZnJvbSBcIi4uL3V0aWwuanNcIjtcbmltcG9ydCB7IEFQSSB9IGZyb20gJy4uL2FwaS5qcyc7XG5cbmV4cG9ydCBsZXQgZGF0ZTtcbmV4cG9ydCBsZXQgc3RyZWFtZXI7XG5cblxuXG5sZXQgdG9vbHRpcF94PTAsIFxuXHRcdHRvb2x0aXBfeT0wLCBcblx0XHR0b29sdGlwX2RhdGE9bnVsbDtcblxubGV0IHRvZGF5ID0gbmV3IERhdGUoZGF0ZSk7IHRvZGF5LnNldEhvdXJzKDAsMCwwLDApO1xubGV0IHRvID0gbmV3IERhdGUodG9kYXkuZ2V0VGltZSgpICsgMTAwMCo2MCo2MCoyNCk7XG5sZXQgZnJvbSA9IHRvZGF5O1xuXG5leHBvcnQgbGV0IGhlaWdodCA9IDEwMDtcbmxldCB3aWR0aCA9IDUwMDtcblxubGV0IGdhbWVzID0ge307XG5sZXQgZGF0YV9jaHVua3MgPSBbXTtcbmxldCBsYXN0X2RhdGEgPSBudWxsO1xuJDogZ2FtZV9ib3hfYXJ0X3dpZHRoID0gaGVpZ2h0KjAuNDtcbiQ6IGdhbWVfYm94X2FydF9oZWlnaHQgPSBoZWlnaHQqMC41O1xuXG5sZXQgc3ZnO1xuXG5sZXQgdG9fdGltZXN0YW1wID0gdG8uZ2V0VGltZSgpLzEwMDA7XG5sZXQgZnJvbV90aW1lc3RhbXAgPSBmcm9tLmdldFRpbWUoKS8xMDAwO1xuZnVuY3Rpb24geHNjYWxlKHgpIHtcbiAgcmV0dXJuIHdpZHRoICogKHggLSBmcm9tX3RpbWVzdGFtcCkgLyAoMjQqNjAqNjApO1xufVxuZnVuY3Rpb24gaXhzY2FsZSh4KSB7XG4gIHJldHVybiB4IC8gd2lkdGggKiAoMjQqNjAqNjApICsgZnJvbV90aW1lc3RhbXBcbn1cbmZ1bmN0aW9uIHlzY2FsZSh4KSB7XG4gIHJldHVybiBoZWlnaHQgKiAoJG1heF95X2F4aXMgLSB4KSAvICRtYXhfeV9heGlzO1xufVxuZnVuY3Rpb24geXNjYWxlX3JpZ2h0KHgpIHtcbiAgcmV0dXJuIGhlaWdodCAqICgkbWF4X3lfYXhpc19yaWdodCAtIHgpIC8gJG1heF95X2F4aXNfcmlnaHQgKyAzO1xufVxuZnVuY3Rpb24gdXBkYXRlX3BhdGgoKSB7XG4gIGZvcihsZXQgZGF0YSBvZiBkYXRhX2NodW5rcyl7XG4gICAgZGF0YS5wYXRoID0gXG4gICAgICBgTSR7eHNjYWxlKGRhdGFbMF1bMF0pfSwke2hlaWdodCowLjV9YCArXG4gICAgICBkYXRhLm1hcChkPT5cbiAgICAgICAgYEwke3hzY2FsZShkWzBdKX0sJHt5c2NhbGUoZFsyXSkqMC41fWBcbiAgICAgICkuam9pbihcIlwiKSArIFxuICAgICAgZGF0YS5tYXAoKF8sIGksIGFycikgPT5cbiAgICAgICAgYEwke3hzY2FsZShhcnJbYXJyLmxlbmd0aCAtIGkgLSAxXVswXSl9LCR7eXNjYWxlKGFyclthcnIubGVuZ3RoIC0gaSAtIDFdWzJdKSotMC41ICsgaGVpZ2h0KjEuMH1gXG4gICAgICApLmpvaW4oXCJcIikgKyBcbiAgICAgIGBMJHt4c2NhbGUoZGF0YVswXVswXSl9LCR7aGVpZ2h0KjAuNX1gO1xuICB9XG4gIGRhdGFfY2h1bmtzID0gZGF0YV9jaHVua3M7XG59XG5sZXQgbGFzdF9tYXhfeV9heGlzID0gJG1heF95X2F4aXM7XG5sZXQgbGFzdF9tYXhfeV9heGlzX3JpZ2h0ID0gJG1heF95X2F4aXNfcmlnaHQ7XG4kOiBpZihkYXRhX2NodW5rcyAmJiAoKGxhc3RfbWF4X3lfYXhpcyAhPSAkbWF4X3lfYXhpcykgfHwgKGxhc3RfbWF4X3lfYXhpc19yaWdodCAhPSAkbWF4X3lfYXhpc19yaWdodCkpKSB7XG4gIGxhc3RfbWF4X3lfYXhpcyA9ICRtYXhfeV9heGlzO1xuICBsYXN0X21heF95X2F4aXNfcmlnaHQgPSAkbWF4X3lfYXhpc19yaWdodDtcbiAgdXBkYXRlX3BhdGgoKTtcbn1cblxubGV0IG5vd194ID0gbnVsbDtcblxub25Nb3VudChhc3luYyAoKT0+IHtcblx0d2lkdGggPSBzdmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gIG5vd194ID0geHNjYWxlKG5ldyBEYXRlKCkuZ2V0VGltZSgpLzEwMDApO1xuICBpZihzdHJlYW1lciA9PSBudWxsKVxuICAgIHJldHVybjtcbiAgbGV0IHtzdHJlYW1fY2hhbmdlcywgc3RyZWFtX21ldGFkYXRhX2NoYW5nZXN9ID0gYXdhaXQgQVBJLnRpbWVsaW5lKHN0cmVhbWVyLmlkLCBmcm9tLCB0byk7XG4gIGxhc3RfZGF0YSA9IHN0cmVhbV9jaGFuZ2VzW3N0cmVhbV9jaGFuZ2VzLmxlbmd0aC0xXTtcbiAgbWF4X3lfYXhpcy51cGRhdGUoeCA9PiBNYXRoLm1heCh4LCAuLi5zdHJlYW1fY2hhbmdlcy5tYXAoZD0+TWF0aC5tYXgoZFsyXSkpKSk7XG4gIG1heF95X2F4aXNfcmlnaHQudXBkYXRlKHggPT4gTWF0aC5tYXgoeCwgLi4uc3RyZWFtX2NoYW5nZXMubWFwKGQ9PmRbNF0pKSk7XG4gIGxldCBqPTA7XG4gIGxldCBtZXRhZGF0YXMgPSBzdHJlYW1fY2hhbmdlcy5tYXAoeCA9PiB7XG4gICAgd2hpbGUoc3RyZWFtX21ldGFkYXRhX2NoYW5nZXMubGVuZ3RoID4gaiAmJiB4WzBdID49IHN0cmVhbV9tZXRhZGF0YV9jaGFuZ2VzW2pdLnRpbWUpICsrajtcbiAgICBpZih4WzFdID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICBlbHNlIGlmKGo+MCkgcmV0dXJuIHN0cmVhbV9tZXRhZGF0YV9jaGFuZ2VzW2otMV07XG4gICAgZWxzZSByZXR1cm4gbnVsbDtcbiAgfSk7XG4gIHN0cmVhbV9jaGFuZ2VzID0gc3RyZWFtX2NoYW5nZXMubWFwKChkLCBpKT0+Wy4uLmQsIG1ldGFkYXRhc1tpXV0pO1xuICBsZXQgc21fbiA9IDIwLCBjaGF0dGluZ19zcGVlZF9zbSA9IFtzdHJlYW1fY2hhbmdlcy5zbGljZSgwLCBzbV9uKS5yZWR1Y2UoKGEsYik9PmErYls0XSwgMCkvc21fbl07XG4gIGZvcihsZXQgaT1zbV9uLCBsPXN0cmVhbV9jaGFuZ2VzLmxlbmd0aCwgc209Y2hhdHRpbmdfc3BlZWRfc21bMF07IGk8bDsgKytpKXtcbiAgICBzbSA9IHNtICsgKHN0cmVhbV9jaGFuZ2VzW2ldWzRdIC0gc3RyZWFtX2NoYW5nZXNbaS1zbV9uXVs0XSkvc21fbjtcbiAgICBjaGF0dGluZ19zcGVlZF9zbS5wdXNoKHNtKTtcbiAgfVxuICBmb3IobGV0IGk9MCwgc209MDsgaTxNYXRoLm1pbihzbV9uLCBzdHJlYW1fY2hhbmdlcy5sZW5ndGgpOyArK2kpe1xuICAgIHNtID0gc20qaS8oaSsxKSArIHN0cmVhbV9jaGFuZ2VzW2ldWzRdLyhpKzEpO1xuICAgIHN0cmVhbV9jaGFuZ2VzW2ldWzRdID0gc207XG4gIH1cbiAgZm9yKGxldCBpPTAsIGw9Y2hhdHRpbmdfc3BlZWRfc20ubGVuZ3RoOyBpPGw7ICsraSlcbiAgICBzdHJlYW1fY2hhbmdlc1tNYXRoLm1pbihzdHJlYW1fY2hhbmdlcy5sZW5ndGgtMSwgaSArIHNtX24tMSldWzRdID0gY2hhdHRpbmdfc3BlZWRfc21baV07XG5cblx0c3ZnLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oZSl7XG5cdFx0bGV0IHggPSBlLmNsaWVudFggLSBzdmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkueCwgXG5cdFx0XHRcdHkgPSBlLmNsaWVudFkgLSBzdmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkueTtcbiAgICB0b29sdGlwX3ggPSB4OyBcbiAgICB0b29sdGlwX3kgPSB5O1xuICAgIGxldCB0YXJnZXRfZGF0ZSA9IGl4c2NhbGUoeCk7XG4gICAgbGV0IHJpZ2h0X2luZGV4ID0gc3RyZWFtX2NoYW5nZXMuZmluZEluZGV4KGQgPT4gZFswXSA+PSB0YXJnZXRfZGF0ZSksXG4gICAgICAgIGxlZnRfaW5kZXggPSBmaW5kTGFzdEluZGV4KHN0cmVhbV9jaGFuZ2VzLCBkID0+IGRbMF0gPD0gdGFyZ2V0X2RhdGUpO1xuICAgIGxldCBuZWFyZXN0X2luZGV4OyBcbiAgICBpZihyaWdodF9pbmRleCA+PSAwICYmIGxlZnRfaW5kZXggPj0gMCkgXG4gICAgICBuZWFyZXN0X2luZGV4ID0gTWF0aC5hYnMoc3RyZWFtX2NoYW5nZXNbbGVmdF9pbmRleF1bMF0gLSB0YXJnZXRfZGF0ZSkgPD0gTWF0aC5hYnMoc3RyZWFtX2NoYW5nZXNbcmlnaHRfaW5kZXhdWzBdIC0gdGFyZ2V0X2RhdGUpP1xuICAgICAgICBsZWZ0X2luZGV4OiByaWdodF9pbmRleDtcbiAgICBlbHNlIGlmKHJpZ2h0X2luZGV4ID49IDApXG4gICAgICBuZWFyZXN0X2luZGV4ID0gcmlnaHRfaW5kZXg7XG4gICAgZWxzZSBpZihsZWZ0X2luZGV4ID49IDApXG4gICAgICBuZWFyZXN0X2luZGV4ID0gbGVmdF9pbmRleDtcbiAgICBlbHNlIHtcbiAgICAgIHRvb2x0aXBfZGF0YSA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoTWF0aC5hYnMoc3RyZWFtX2NoYW5nZXNbbmVhcmVzdF9pbmRleF1bMF0gLSB0YXJnZXRfZGF0ZSkgPCA2MCo2MCkgey8vIHx8IHJpZ2h0X2luZGV4ICE9IDAgJiYgbWV0YWRhdGFzW3JpZ2h0X2luZGV4XS5zdGFydGVkX2F0ID09IG1ldGFkYXRhc1tyaWdodF9pbmRleC0xXS5zdGFydGVkX2F0KSB7XG4gICAgICB0b29sdGlwX2RhdGEgPSBzdHJlYW1fY2hhbmdlc1tuZWFyZXN0X2luZGV4XTtcbiAgICB9XG4gICAgZWxzZSBcbiAgICAgIHRvb2x0aXBfZGF0YSA9IG51bGw7XG4gIH1cbiAgc3ZnLm9ubW91c2VsZWF2ZSA9IGZ1bmN0aW9uKGUpe1xuICAgIHRvb2x0aXBfZGF0YSA9IG51bGw7XG4gIH1cbiAgZGF0YV9jaHVua3MucHVzaChbXSk7XG5cdGZvcihsZXQgaT0wLCBsPXN0cmVhbV9jaGFuZ2VzLmxlbmd0aCwgaj0wOyBpPGw7ICsraSkge1xuICAgXHQgIGlmKGk+MCAmJiBtZXRhZGF0YXNbaV0gIT0gbWV0YWRhdGFzW2ktMV0gJiYgXG4gICAgICAgICAgKChtZXRhZGF0YXNbaV0gPT0gbnVsbCB8fCBtZXRhZGF0YXNbaS0xXSA9PSBudWxsKSB8fCBcbiAgICAgICAgICAgIG1ldGFkYXRhc1tpXS5zdGFydGVkX2F0ICE9IG1ldGFkYXRhc1tpLTFdLnN0YXJ0ZWRfYXQgfHwgXG4gICAgICAgICAgICAobWV0YWRhdGFzW2ldLmdhbWUgJiYgbWV0YWRhdGFzW2ldLmdhbWUuaWQpICE9IChtZXRhZGF0YXNbaS0xXS5nYW1lICYmIG1ldGFkYXRhc1tpLTFdLmdhbWUuaWQpIHx8XG4gICAgICAgICAgICBtZXRhZGF0YXNbaV0udGl0bGUgIT0gbWV0YWRhdGFzW2ktMV0udGl0bGUpKXtcbiAgICAgICAgKytqO1xuICAgICAgICBkYXRhX2NodW5rcy5wdXNoKFtdKTtcbiAgICAgICAgaWYobWV0YWRhdGFzW2ldICYmIG1ldGFkYXRhc1tpLTFdICYmIG1ldGFkYXRhc1tpXS5zdGFydGVkX2F0ID09IG1ldGFkYXRhc1tpLTFdLnN0YXJ0ZWRfYXQpe1xuICAgICAgICAgIGxldCBtaWQgPSBzdHJlYW1fY2hhbmdlc1tpXS5zbGljZSgwLCA1KS5tYXAoKGQsIGopID0+IE1hdGguZmxvb3IoKGQgKyBzdHJlYW1fY2hhbmdlc1tpLTFdW2pdKSowLjUpKTtcbiAgICAgICAgICBkYXRhX2NodW5rc1tqLTFdLnB1c2goWy4uLm1pZCwgbWV0YWRhdGFzW2ktMV1dKVxuICAgICAgICAgIGRhdGFfY2h1bmtzW2pdLnB1c2goWy4uLm1pZCwgbWV0YWRhdGFzW2ldXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGF0YV9jaHVua3Nbal0ucHVzaChzdHJlYW1fY2hhbmdlc1tpXSlcbiAgfVxuICB1cGRhdGVfcGF0aCgpO1xuICBkYXRhX2NodW5rcyA9IGRhdGFfY2h1bmtzO1xuICBmb3IobGV0IGRhdGEgb2YgZGF0YV9jaHVua3Mpe1xuICBcdGlmKGRhdGFbMF0gPT0gbnVsbCB8fCBkYXRhWzBdWzVdID09IG51bGwgfHwgZGF0YVswXVs1XS5nYW1lID09IG51bGwpIGNvbnRpbnVlO1xuXHRcdGdhbWVzW2RhdGFbMF1bNV0uZ2FtZS5pZF0gPSBkYXRhWzBdWzVdLmdhbWU7XG5cdH1cbn0pO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbi5pc19zdHJlYW1pbmdfbGFiZWwge1xuICBhbmltYXRpb246IGJsaW5rZXIgMXMgbGluZWFyIGluZmluaXRlO1xufVxuQGtleWZyYW1lcyBibGlua2VyIHtcbiAgNTAlIHtcbiAgICBvcGFjaXR5OiAwO1xuICB9XG59XG48L3N0eWxlPlxuIiwiPHN2ZyBjbGFzcz1cInctZnVsbCBvdmVyZmxvdy12aXNpYmxlIG9wYWNpdHktNTAgeyQkcHJvcHMuY2xhc3N9XCIgdmlld0JveD1cIjAgMCB7d2lkdGh9IHtoZWlnaHR9XCIgd2lkdGg9XCJ7d2lkdGh9XCIgaGVpZ2h0PVwie2hlaWdodH1cIiBiaW5kOnRoaXM9e3N2Z30+XG4gIDxkZWZzPlxuICAgIDxtYXJrZXIgaWQ9XCJoZWFkXCIgXG4gICAgICBtYXJrZXJXaWR0aD1cIjJcIiBtYXJrZXJIZWlnaHQ9XCI0XCIgXG4gICAgICAgICAgICAgICAgICAgICAgcmVmWD1cIjAuMVwiIHJlZlk9XCIyXCIgb3JpZW50PVwiYXV0b1wiID5cbiAgICAgIDxwYXRoIGQ9XCJNMCwwIFY0IEwyLDIgWlwiIGZpbGw9XCIjNzE4MDk2XCIgLz5cbiAgICA8L21hcmtlcj5cbiAgPC9kZWZzPlxuICA8Zz5cbiAgICB7I2VhY2ggcGF0aHMgYXMgcGF0aH1cbiAgICA8cGF0aFxuICAgICAgbWFya2VyLWVuZD1cInVybCgjaGVhZClcIlxuICAgICAgc3Ryb2tlLXdpZHRoPVwie3BhdGgud2lkdGh9XCIgXG4gICAgICBmaWxsPVwibm9uZVwiIFxuICAgICAgc3Ryb2tlPVwiIzcxODA5NlwiIFxuICAgICAgZD1cIntwYXRoLnBhdGh9XCJcbiAgICAgIC8+XG4gICAgICA8dGV4dCBcbiAgICAgICAgZmlsbD1cIiM3MTgwOTZcIiBcbiAgICAgICAgZm9udC1zaXplPVwiezEwICsgcGF0aC53aWR0aCoyfVwiIFxuICAgICAgICBmb250LWZhbWlseT1cIkFyaWFsXCIgXG4gICAgICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSh7cGF0aC54ICsgcGF0aC53aWR0aH0sIHtoZWlnaHQqMC41fSkgcm90YXRlKDkwKVwiXG4gICAgICAgIHRleHQtYW5jaG9yPVwibWlkZGxlXCJcbiAgICAgICAgPlxuICAgICAgICB7cGF0aC5jb3VudH3rqoVcbiAgICAgIDwvdGV4dD5cbiAgICB7L2VhY2h9XG4gIDwvZz5cbjwvc3ZnPlxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgY29uc3QgbGVuZ3RoID0gMTA7XG4gIGxldCB3aWR0aCA9IDE7XG4gIGxldCBzdmc7XG4gIGV4cG9ydCBsZXQgaGVpZ2h0ID0gMTAwO1xuICBleHBvcnQgbGV0IHRpbWVsaW5lX2hlaWdodCA9IDE1MDtcbiAgZXhwb3J0IGxldCBtaWdyYXRpb25zO1xuICBleHBvcnQgbGV0IGlkMTtcbiAgZXhwb3J0IGxldCBpZDI7XG4gIGxldCB0b2RheTtcbiAgb25Nb3VudCgoKT0+IHtcbiAgICB3aWR0aCA9IHN2Zy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgfSk7XG4gICQ6IHtcbiAgICBpZihtaWdyYXRpb25zLmxlbmd0aCl7XG4gICAgICB0b2RheSA9IG5ldyBEYXRlKG1pZ3JhdGlvbnNbMF0udGltZSk7XG4gICAgICB0b2RheS5zZXRIb3VycygwLDAsMCwwKVxuICAgIH1cbiAgfVxuICAkOiBwYXRocyA9IG1pZ3JhdGlvbnMubWFwKG0gPT4ge1xuICAgIGxldCB4ID0gKG5ldyBEYXRlKG0udGltZSkuZ2V0VGltZSgpIC0gdG9kYXkuZ2V0VGltZSgpIC0gMzAqNjAqMTAwMCkqd2lkdGgvKDI0KjYwKjYwKjEwMDApO1xuICAgIGxldCB3ID0gTWF0aC5tYXgoMSwgKE1hdGguc3FydChtLm1pZ3JhdGlvbl9jb3VudCkgLyA1KSp3aWR0aC8xMDAwKTtcbiAgICBpZihtLnNvdXJjZSA9PSBpZDEpXG4gICAgICAvL3JldHVybiBgTSR7eH0sJHswfSBDJHt4ICsgbGVuZ3RofSwkezB9ICR7eH0sJHtoZWlnaHR9ICR7eCArIGxlbmd0aH0sJHtoZWlnaHR9YDtcbiAgICAgIHJldHVybiB7XCJwYXRoXCI6IGBNJHt4fSwkey10aW1lbGluZV9oZWlnaHQqMC41fSBMJHt4fSwke2hlaWdodCoyLzMgLSB3KjEuNX1gLCBcIndpZHRoXCI6IHcsIFwiY291bnRcIjogbS5taWdyYXRpb25fY291bnQsIFwieFwiOiB4fTtcbiAgICBlbHNlXG4gICAgICAvL3JldHVybiBgTSR7eH0sJHtoZWlnaHR9IEMke3ggKyBsZW5ndGh9LCR7aGVpZ2h0fSAke3h9LCR7MH0gJHt4ICsgbGVuZ3RofSwkezB9YDtcbiAgICAgIHJldHVybiB7XCJwYXRoXCI6IGBNJHt4fSwke2hlaWdodCt0aW1lbGluZV9oZWlnaHQqMC41fSBMJHt4fSwke2hlaWdodCoxLzMgKyB3KjEuNX1gLCBcIndpZHRoXCI6IHcsIFwiY291bnRcIjogbS5taWdyYXRpb25fY291bnQsIFwieFwiOiB4fTtcbiAgfSk7XG48L3NjcmlwdD5cbiIsImNvbnN0IGdldENhbGVuZGFyUGFnZSA9IChtb250aCwgeWVhciwgZGF5UHJvcHMsIHdlZWtTdGFydCA9IDApID0+IHtcbiAgbGV0IGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSk7XG4gIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIGRhdGUuZ2V0RGF5KCkgKyB3ZWVrU3RhcnQpO1xuICBsZXQgbmV4dE1vbnRoID0gbW9udGggPT09IDExID8gMCA6IG1vbnRoICsgMTtcbiAgLy8gZW5zdXJlIGRheXMgc3RhcnRzIG9uIFN1bmRheVxuICAvLyBhbmQgZW5kIG9uIHNhdHVyZGF5XG4gIGxldCB3ZWVrcyA9IFtdO1xuICB3aGlsZSAoZGF0ZS5nZXRNb250aCgpICE9PSBuZXh0TW9udGggfHwgZGF0ZS5nZXREYXkoKSAhPT0gd2Vla1N0YXJ0IHx8IHdlZWtzLmxlbmd0aCAhPT0gNikge1xuICAgIGlmIChkYXRlLmdldERheSgpID09PSB3ZWVrU3RhcnQpIHdlZWtzLnVuc2hpZnQoeyBkYXlzOiBbXSwgaWQ6IGAke3llYXJ9JHttb250aH0ke3llYXJ9JHt3ZWVrcy5sZW5ndGh9YCB9KTtcbiAgICBjb25zdCB1cGRhdGVkID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBwYXJ0T2ZNb250aDogZGF0ZS5nZXRNb250aCgpID09PSBtb250aCxcbiAgICAgIGRheTogZGF0ZS5nZXREYXRlKCksXG4gICAgICBtb250aDogZGF0ZS5nZXRNb250aCgpLFxuICAgICAgeWVhcjogZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgZGF0ZTogbmV3IERhdGUoZGF0ZSlcbiAgICB9LCBkYXlQcm9wcyhkYXRlKSk7XG4gICAgd2Vla3NbMF0uZGF5cy5wdXNoKHVwZGF0ZWQpO1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIDEpO1xuICB9XG4gIHdlZWtzLnJldmVyc2UoKTtcbiAgcmV0dXJuIHsgbW9udGgsIHllYXIsIHdlZWtzIH07XG59O1xuXG5jb25zdCBnZXREYXlQcm9wc0hhbmRsZXIgPSAoc3RhcnQsIGVuZCwgc2VsZWN0YWJsZUNhbGxiYWNrKSA9PiB7XG4gIGxldCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gIHRvZGF5LnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gZGF0ZSA9PiB7XG4gICAgY29uc3QgaXNJblJhbmdlID0gZGF0ZSA+PSBzdGFydCAmJiBkYXRlIDw9IGVuZDtcbiAgICByZXR1cm4ge1xuICAgICAgaXNJblJhbmdlLFxuICAgICAgc2VsZWN0YWJsZTogaXNJblJhbmdlICYmICghc2VsZWN0YWJsZUNhbGxiYWNrIHx8IHNlbGVjdGFibGVDYWxsYmFjayhkYXRlKSksXG4gICAgICBpc1RvZGF5OiBkYXRlLmdldFRpbWUoKSA9PT0gdG9kYXkuZ2V0VGltZSgpXG4gICAgfTtcbiAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNb250aHMoc3RhcnQsIGVuZCwgc2VsZWN0YWJsZUNhbGxiYWNrID0gbnVsbCwgd2Vla1N0YXJ0ID0gMCkge1xuICBzdGFydC5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgZW5kLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBsZXQgZW5kRGF0ZSA9IG5ldyBEYXRlKGVuZC5nZXRGdWxsWWVhcigpLCBlbmQuZ2V0TW9udGgoKSArIDEsIDEpO1xuICBsZXQgbW9udGhzID0gW107XG4gIGxldCBkYXRlID0gbmV3IERhdGUoc3RhcnQuZ2V0RnVsbFllYXIoKSwgc3RhcnQuZ2V0TW9udGgoKSwgMSk7XG4gIGxldCBkYXlQcm9wc0hhbmRsZXIgPSBnZXREYXlQcm9wc0hhbmRsZXIoc3RhcnQsIGVuZCwgc2VsZWN0YWJsZUNhbGxiYWNrKTtcbiAgd2hpbGUgKGRhdGUgPCBlbmREYXRlKSB7XG4gICAgbW9udGhzLnB1c2goZ2V0Q2FsZW5kYXJQYWdlKGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXlQcm9wc0hhbmRsZXIsIHdlZWtTdGFydCkpO1xuICAgIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgMSk7XG4gIH1cbiAgcmV0dXJuIG1vbnRocztcbn1cblxuZXhwb3J0IGNvbnN0IGFyZURhdGVzRXF1aXZhbGVudCA9IChhLCBiKSA9PiBhLmdldERhdGUoKSA9PT0gYi5nZXREYXRlKClcbiAgJiYgYS5nZXRNb250aCgpID09PSBiLmdldE1vbnRoKClcbiAgJiYgYS5nZXRGdWxsWWVhcigpID09PSBiLmdldEZ1bGxZZWFyKCk7XG4iLCJpbXBvcnQgeyBjdWJpY0luT3V0LCBjdWJpY091dCB9IGZyb20gJy4uL2Vhc2luZyc7XG5pbXBvcnQgeyBpc19mdW5jdGlvbiwgYXNzaWduIH0gZnJvbSAnLi4vaW50ZXJuYWwnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XG5cbmZ1bmN0aW9uIGJsdXIobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY0luT3V0LCBhbW91bnQgPSA1LCBvcGFjaXR5ID0gMCB9KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgZiA9IHN0eWxlLmZpbHRlciA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS5maWx0ZXI7XG4gICAgY29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKF90LCB1KSA9PiBgb3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIChvZCAqIHUpfTsgZmlsdGVyOiAke2Z9IGJsdXIoJHt1ICogYW1vdW50fXB4KTtgXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZhZGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwIH0pIHtcbiAgICBjb25zdCBvID0gK2dldENvbXB1dGVkU3R5bGUobm9kZSkub3BhY2l0eTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGNzczogdCA9PiBgb3BhY2l0eTogJHt0ICogb31gXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZseShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0LCB4ID0gMCwgeSA9IDAsIG9wYWNpdHkgPSAwIH0pIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuICAgIGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6ICh0LCB1KSA9PiBgXG5cdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHsoMSAtIHQpICogeH1weCwgJHsoMSAtIHQpICogeX1weCk7XG5cdFx0XHRvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gKG9kICogdSl9YFxuICAgIH07XG59XG5mdW5jdGlvbiBzbGlkZShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0IH0pIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3Qgb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IGhlaWdodCA9IHBhcnNlRmxvYXQoc3R5bGUuaGVpZ2h0KTtcbiAgICBjb25zdCBwYWRkaW5nX3RvcCA9IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ1RvcCk7XG4gICAgY29uc3QgcGFkZGluZ19ib3R0b20gPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdCb3R0b20pO1xuICAgIGNvbnN0IG1hcmdpbl90b3AgPSBwYXJzZUZsb2F0KHN0eWxlLm1hcmdpblRvcCk7XG4gICAgY29uc3QgbWFyZ2luX2JvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luQm90dG9tKTtcbiAgICBjb25zdCBib3JkZXJfdG9wX3dpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCk7XG4gICAgY29uc3QgYm9yZGVyX2JvdHRvbV93aWR0aCA9IHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6IHQgPT4gYG92ZXJmbG93OiBoaWRkZW47YCArXG4gICAgICAgICAgICBgb3BhY2l0eTogJHtNYXRoLm1pbih0ICogMjAsIDEpICogb3BhY2l0eX07YCArXG4gICAgICAgICAgICBgaGVpZ2h0OiAke3QgKiBoZWlnaHR9cHg7YCArXG4gICAgICAgICAgICBgcGFkZGluZy10b3A6ICR7dCAqIHBhZGRpbmdfdG9wfXB4O2AgK1xuICAgICAgICAgICAgYHBhZGRpbmctYm90dG9tOiAke3QgKiBwYWRkaW5nX2JvdHRvbX1weDtgICtcbiAgICAgICAgICAgIGBtYXJnaW4tdG9wOiAke3QgKiBtYXJnaW5fdG9wfXB4O2AgK1xuICAgICAgICAgICAgYG1hcmdpbi1ib3R0b206ICR7dCAqIG1hcmdpbl9ib3R0b219cHg7YCArXG4gICAgICAgICAgICBgYm9yZGVyLXRvcC13aWR0aDogJHt0ICogYm9yZGVyX3RvcF93aWR0aH1weDtgICtcbiAgICAgICAgICAgIGBib3JkZXItYm90dG9tLXdpZHRoOiAke3QgKiBib3JkZXJfYm90dG9tX3dpZHRofXB4O2BcbiAgICB9O1xufVxuZnVuY3Rpb24gc2NhbGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY091dCwgc3RhcnQgPSAwLCBvcGFjaXR5ID0gMCB9KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICBjb25zdCBzZCA9IDEgLSBzdGFydDtcbiAgICBjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiAoX3QsIHUpID0+IGBcblx0XHRcdHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHNjYWxlKCR7MSAtIChzZCAqIHUpfSk7XG5cdFx0XHRvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gKG9kICogdSl9XG5cdFx0YFxuICAgIH07XG59XG5mdW5jdGlvbiBkcmF3KG5vZGUsIHsgZGVsYXkgPSAwLCBzcGVlZCwgZHVyYXRpb24sIGVhc2luZyA9IGN1YmljSW5PdXQgfSkge1xuICAgIGNvbnN0IGxlbiA9IG5vZGUuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICBpZiAoZHVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc3BlZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSA4MDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IGxlbiAvIHNwZWVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uKGxlbik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6ICh0LCB1KSA9PiBgc3Ryb2tlLWRhc2hhcnJheTogJHt0ICogbGVufSAke3UgKiBsZW59YFxuICAgIH07XG59XG5mdW5jdGlvbiBjcm9zc2ZhZGUoX2EpIHtcbiAgICB2YXIgeyBmYWxsYmFjayB9ID0gX2EsIGRlZmF1bHRzID0gX19yZXN0KF9hLCBbXCJmYWxsYmFja1wiXSk7XG4gICAgY29uc3QgdG9fcmVjZWl2ZSA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCB0b19zZW5kID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGNyb3NzZmFkZShmcm9tLCBub2RlLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gZCA9PiBNYXRoLnNxcnQoZCkgKiAzMCwgZWFzaW5nID0gY3ViaWNPdXQgfSA9IGFzc2lnbihhc3NpZ24oe30sIGRlZmF1bHRzKSwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBkeCA9IGZyb20ubGVmdCAtIHRvLmxlZnQ7XG4gICAgICAgIGNvbnN0IGR5ID0gZnJvbS50b3AgLSB0by50b3A7XG4gICAgICAgIGNvbnN0IGR3ID0gZnJvbS53aWR0aCAvIHRvLndpZHRoO1xuICAgICAgICBjb25zdCBkaCA9IGZyb20uaGVpZ2h0IC8gdG8uaGVpZ2h0O1xuICAgICAgICBjb25zdCBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBpc19mdW5jdGlvbihkdXJhdGlvbikgPyBkdXJhdGlvbihkKSA6IGR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nLFxuICAgICAgICAgICAgY3NzOiAodCwgdSkgPT4gYFxuXHRcdFx0XHRvcGFjaXR5OiAke3QgKiBvcGFjaXR5fTtcblx0XHRcdFx0dHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7XG5cdFx0XHRcdHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke3UgKiBkeH1weCwke3UgKiBkeX1weCkgc2NhbGUoJHt0ICsgKDEgLSB0KSAqIGR3fSwgJHt0ICsgKDEgLSB0KSAqIGRofSk7XG5cdFx0XHRgXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zaXRpb24oaXRlbXMsIGNvdW50ZXJwYXJ0cywgaW50cm8pIHtcbiAgICAgICAgcmV0dXJuIChub2RlLCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGl0ZW1zLnNldChwYXJhbXMua2V5LCB7XG4gICAgICAgICAgICAgICAgcmVjdDogbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVycGFydHMuaGFzKHBhcmFtcy5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVjdCB9ID0gY291bnRlcnBhcnRzLmdldChwYXJhbXMua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnBhcnRzLmRlbGV0ZShwYXJhbXMua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzZmFkZShyZWN0LCBub2RlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbm9kZSBpcyBkaXNhcHBlYXJpbmcgYWx0b2dldGhlclxuICAgICAgICAgICAgICAgIC8vIChpLmUuIHdhc24ndCBjbGFpbWVkIGJ5IHRoZSBvdGhlciBsaXN0KVxuICAgICAgICAgICAgICAgIC8vIHRoZW4gd2UgbmVlZCB0byBzdXBwbHkgYW4gb3V0cm9cbiAgICAgICAgICAgICAgICBpdGVtcy5kZWxldGUocGFyYW1zLmtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrICYmIGZhbGxiYWNrKG5vZGUsIHBhcmFtcywgaW50cm8pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdHJhbnNpdGlvbih0b19zZW5kLCB0b19yZWNlaXZlLCBmYWxzZSksXG4gICAgICAgIHRyYW5zaXRpb24odG9fcmVjZWl2ZSwgdG9fc2VuZCwgdHJ1ZSlcbiAgICBdO1xufVxuXG5leHBvcnQgeyBibHVyLCBjcm9zc2ZhZGUsIGRyYXcsIGZhZGUsIGZseSwgc2NhbGUsIHNsaWRlIH07XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBhcmVEYXRlc0VxdWl2YWxlbnQgfSBmcm9tICcuL2xpYi9oZWxwZXJzJztcbiAgaW1wb3J0IHsgZmx5LCBmYWRlIH0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nO1xuICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xuXG4gIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgZXhwb3J0IGxldCBkYXlzO1xuICBleHBvcnQgbGV0IHNlbGVjdGVkO1xuICBleHBvcnQgbGV0IGhpZ2hsaWdodGVkO1xuICBleHBvcnQgbGV0IHNob3VsZFNoYWtlRGF0ZTtcbiAgZXhwb3J0IGxldCBkaXJlY3Rpb247XG48L3NjcmlwdD5cclxuXHJcbjxkaXYgXHJcbiAgY2xhc3M9XCJ3ZWVrXCIgXHJcbiAgaW46Zmx5PXt7IHg6IGRpcmVjdGlvbiAqIDUwLCBkdXJhdGlvbjogMTgwLCBkZWxheTogOTAgfX1cclxuICBvdXQ6ZmFkZT17eyBkdXJhdGlvbjogMTgwIH19XHJcbj5cclxuICB7I2VhY2ggZGF5cyBhcyBkYXl9XHJcbiAgICA8ZGl2IFxyXG4gICAgICBjbGFzcz1cImRheVwiIFxyXG4gICAgICBjbGFzczpvdXRzaWRlLW1vbnRoPXshZGF5LnBhcnRPZk1vbnRofVxyXG4gICAgICBjbGFzczppcy10b2RheT17ZGF5LmlzVG9kYXl9XHJcbiAgICAgIGNsYXNzOmlzLWRpc2FibGVkPXshZGF5LnNlbGVjdGFibGV9XHJcbiAgICA+XHJcbiAgICAgIDxidXR0b24gXHJcbiAgICAgICAgY2xhc3M9XCJkYXktLWxhYmVsXCIgXHJcbiAgICAgICAgY2xhc3M6c2VsZWN0ZWQ9e2FyZURhdGVzRXF1aXZhbGVudChkYXkuZGF0ZSwgc2VsZWN0ZWQpfVxyXG4gICAgICAgIGNsYXNzOmhpZ2hsaWdodGVkPXthcmVEYXRlc0VxdWl2YWxlbnQoZGF5LmRhdGUsIGhpZ2hsaWdodGVkKX1cclxuICAgICAgICBjbGFzczpzaGFrZS1kYXRlPXtzaG91bGRTaGFrZURhdGUgJiYgYXJlRGF0ZXNFcXVpdmFsZW50KGRheS5kYXRlLCBzaG91bGRTaGFrZURhdGUpfVxyXG4gICAgICAgIGNsYXNzOmRpc2FibGVkPXshZGF5LnNlbGVjdGFibGV9XHJcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXHJcbiAgICAgICAgb246Y2xpY2s9eygpID0+IGRpc3BhdGNoKCdkYXRlU2VsZWN0ZWQnLCBkYXkuZGF0ZSl9XHJcbiAgICAgID5cclxuICAgICAgICB7ZGF5LmRhdGUuZ2V0RGF0ZSgpfVxyXG4gICAgICA8L2J1dHRvbj5cclxuICAgIDwvZGl2PlxyXG4gIHsvZWFjaH1cclxuPC9kaXY+XHJcblxyXG48c3R5bGU+XHJcbiAgLndlZWsgeyBcclxuICAgIHBhZGRpbmc6IDA7XHJcbiAgICBtYXJnaW46IDA7XHJcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcclxuICAgIGRpc3BsYXk6IC1tb3otYm94O1xyXG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XHJcbiAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgZmxleC1mbG93OiByb3c7XHJcbiAgICAtd2Via2l0LWZsZXgtZmxvdzogcm93O1xyXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XHJcbiAgICAtbXMtZ3JpZC1jb2x1bW46IDE7XHJcbiAgICBncmlkLWNvbHVtbjogMTsgXHJcbiAgfVxyXG4gIC53ZWVrOm50aC1jaGlsZCg2biArIDEpIHsgXHJcbiAgICAtbXMtZ3JpZC1yb3c6IDE7IFxyXG4gICAgZ3JpZC1yb3c6IDE7IFxyXG4gIH1cclxuICAud2VlazpudGgtY2hpbGQoNm4gKyAyKSB7IFxyXG4gICAgLW1zLWdyaWQtcm93OiAyOyBcclxuICAgIGdyaWQtcm93OiAyOyBcclxuICB9XHJcbiAgLndlZWs6bnRoLWNoaWxkKDZuICsgMykgeyBcclxuICAgIC1tcy1ncmlkLXJvdzogMzsgXHJcbiAgICBncmlkLXJvdzogMzsgXHJcbiAgfVxyXG4gIC53ZWVrOm50aC1jaGlsZCg2biArIDQpIHsgXHJcbiAgICAtbXMtZ3JpZC1yb3c6IDQ7IFxyXG4gICAgZ3JpZC1yb3c6IDQ7IFxyXG4gIH1cclxuICAud2VlazpudGgtY2hpbGQoNm4gKyA1KSB7IFxyXG4gICAgLW1zLWdyaWQtcm93OiA1OyBcclxuICAgIGdyaWQtcm93OiA1OyBcclxuICB9XHJcbiAgLndlZWs6bnRoLWNoaWxkKDZuICsgNikgeyBcclxuICAgIC1tcy1ncmlkLXJvdzogNjsgXHJcbiAgICBncmlkLXJvdzogNjsgXHJcbiAgfVxyXG4gIC5kYXkgeyBcclxuICAgIG1hcmdpbjogMnB4O1xyXG4gICAgY29sb3I6IHZhcigtLWRheS10ZXh0LWNvbG9yKTtcclxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgZm9udC1zaXplOiAxNnB4O1xyXG4gICAgZmxleDogMSAwIGF1dG87XHJcbiAgICBoZWlnaHQ6IGF1dG87XHJcbiAgICBkaXNwbGF5OiBmbGV4OyBcclxuICAgIGZsZXgtYmFzaXM6IDA7XHJcbiAgfVxyXG4gIC5kYXkub3V0c2lkZS1tb250aCwgXHJcbiAgLmRheS5pcy1kaXNhYmxlZCB7IFxyXG4gICAgb3BhY2l0eTogMC4zNTtcclxuICB9XHJcbiAgLmRheTpiZWZvcmUgeyBcclxuICAgIGNvbnRlbnQ6ICcnO1xyXG4gICAgZmxvYXQ6IGxlZnQ7XHJcbiAgICBwYWRkaW5nLXRvcDogMTAwJTtcclxuICB9XHJcbiAgLmRheS0tbGFiZWwgeyBcclxuICAgIGNvbG9yOiB2YXIoLS1kYXktdGV4dC1jb2xvcik7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZmZmO1xyXG4gICAgYm9yZGVyLXJhZGl1czogNTAlOyBcclxuICAgIG1hcmdpbjogMTAlO1xyXG4gICAgcGFkZGluZzogMDtcclxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1kYXktYmFja2dyb3VuZC1jb2xvcik7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICB0cmFuc2l0aW9uOiBhbGwgMTAwbXMgbGluZWFyO1xyXG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcclxuICB9XHJcbiAgLmRheS0tbGFiZWwuZGlzYWJsZWQgeyBcclxuICAgIGN1cnNvcjogZGVmYXVsdDtcclxuICB9XHJcbiAgQG1lZGlhIChtaW4td2lkdGg6IDQ4MHB4KSB7IFxyXG4gICAgLmRheS0tbGFiZWwuaGlnaGxpZ2h0ZWQsXHJcbiAgICAuZGF5LS1sYWJlbDpub3QoLmRpc2FibGVkKTpob3ZlciB7IFxyXG4gICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1kYXktaGlnaGxpZ2h0ZWQtYmFja2dyb3VuZC1jb2xvcik7XHJcbiAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tZGF5LWhpZ2hsaWdodGVkLWJhY2tncm91bmQtY29sb3IpO1xyXG4gICAgICBjb2xvcjogdmFyKC0tZGF5LWhpZ2hsaWdodGVkLXRleHQtY29sb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuICAuZGF5LS1sYWJlbC5zaGFrZS1kYXRlIHsgXHJcbiAgICBhbmltYXRpb246IHNoYWtlIDAuNHMgMSBsaW5lYXI7XHJcbiAgfVxyXG4gIC5kYXktLWxhYmVsLnNlbGVjdGVkOmhvdmVyLFxyXG4gIC5kYXktLWxhYmVsLnNlbGVjdGVkLFxyXG4gIC5kYXktLWxhYmVsOmFjdGl2ZTpub3QoLmRpc2FibGVkKSB7IFxyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0taGlnaGxpZ2h0LWNvbG9yKTtcclxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0taGlnaGxpZ2h0LWNvbG9yKTtcclxuICAgIGNvbG9yOiAjZmZmO1xyXG4gIH1cclxuICAuZGF5LmlzLXRvZGF5IC5kYXktLWxhYmVsLCBcclxuICAuZGF5LmlzLXRvZGF5IC5kYXktLWxhYmVsOmhvdmVyIHsgXHJcbiAgICBvcGFjaXR5OiAxOyBcclxuICAgIGJhY2tncm91bmQ6IG5vbmU7XHJcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWhpZ2hsaWdodC1jb2xvcik7XHJcbiAgICBjb2xvcjogIzAwMDtcclxuICB9XHJcblxyXG4gIEBrZXlmcmFtZXMgc2hha2Uge1xyXG4gICAgMCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSg3cHgpOyB9XHJcbiAgICAyMCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtN3B4KTsgfVxyXG4gICAgNDAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoM3B4KTsgfVxyXG4gICAgNjAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTNweCk7IH1cclxuICAgIDgwJSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKDFweCk7IH1cclxuICAgIDEwMCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwcHgpOyB9XHJcbiAgfVxyXG48L3N0eWxlPlxyXG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgV2VlayBmcm9tICcuL1dlZWsuc3ZlbHRlJztcblxuICBleHBvcnQgbGV0IGlkO1xuICBleHBvcnQgbGV0IHZpc2libGVNb250aDtcbiAgZXhwb3J0IGxldCBzZWxlY3RlZDtcbiAgZXhwb3J0IGxldCBoaWdobGlnaHRlZDtcbiAgZXhwb3J0IGxldCBzaG91bGRTaGFrZURhdGU7XG5cbiAgbGV0IGxhc3RJZCA9IGlkO1xuICBsZXQgZGlyZWN0aW9uO1xuXG4gICQ6IHtcbiAgICBkaXJlY3Rpb24gPSBsYXN0SWQgPCBpZCA/IDEgOiAtMTtcbiAgICBsYXN0SWQgPSBpZDtcbiAgfVxuPC9zY3JpcHQ+XHJcblxyXG48ZGl2IGNsYXNzPVwibW9udGgtY29udGFpbmVyXCI+XHJcbiAgeyNlYWNoIHZpc2libGVNb250aC53ZWVrcyBhcyB3ZWVrICh3ZWVrLmlkKSB9XHJcbiAgICA8V2VlayBcclxuICAgICAgZGF5cz17d2Vlay5kYXlzfSBcclxuICAgICAge3NlbGVjdGVkfSBcclxuICAgICAge2hpZ2hsaWdodGVkfSBcclxuICAgICAge3Nob3VsZFNoYWtlRGF0ZX0gXHJcbiAgICAgIHtkaXJlY3Rpb259XHJcbiAgICAgIG9uOmRhdGVTZWxlY3RlZCBcclxuICAgIC8+XHJcbiAgey9lYWNofVxyXG48L2Rpdj5cclxuXHJcbjxzdHlsZT5cclxuICAubW9udGgtY29udGFpbmVyIHsgXHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIGRpc3BsYXk6IC1tcy1ncmlkO1xyXG4gICAgZGlzcGxheTogZ3JpZDtcclxuICAgIC1tcy1ncmlkLWNvbHVtbnM6IDFmcjtcclxuICAgIC1tcy1ncmlkLXJvd3M6IDFmcjtcclxuICB9XHJcbjwvc3R5bGU+XHJcbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSc7XG5cbiAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICBleHBvcnQgbGV0IG1vbnRoO1xuICBleHBvcnQgbGV0IHllYXI7XG4gIGV4cG9ydCBsZXQgc3RhcnQ7XG4gIGV4cG9ydCBsZXQgZW5kO1xuICBleHBvcnQgbGV0IGNhbkluY3JlbWVudE1vbnRoO1xuICBleHBvcnQgbGV0IGNhbkRlY3JlbWVudE1vbnRoO1xuICBleHBvcnQgbGV0IG1vbnRoc09mWWVhcjtcblxuICBsZXQgbW9udGhTZWxlY3Rvck9wZW4gPSBmYWxzZTtcbiAgbGV0IGF2YWlsYWJsZU1vbnRocztcblxuICAkOiB7XG4gICAgbGV0IGlzT25Mb3dlckJvdW5kYXJ5ID0gc3RhcnQuZ2V0RnVsbFllYXIoKSA9PT0geWVhcjtcbiAgICBsZXQgaXNPblVwcGVyQm91bmRhcnkgPSBlbmQuZ2V0RnVsbFllYXIoKSA9PT0geWVhcjtcbiAgICBhdmFpbGFibGVNb250aHMgPSBtb250aHNPZlllYXIubWFwKChtLCBpKSA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICBuYW1lOiBtWzBdLFxuICAgICAgICBhYmJyZXY6IG1bMV1cbiAgICAgIH0sIHtcbiAgICAgICAgc2VsZWN0YWJsZTpcbiAgICAgICAgICAoIWlzT25Mb3dlckJvdW5kYXJ5ICYmICFpc09uVXBwZXJCb3VuZGFyeSlcbiAgICAgICAgICB8fCAoXG4gICAgICAgICAgICAoIWlzT25Mb3dlckJvdW5kYXJ5IHx8IGkgPj0gc3RhcnQuZ2V0TW9udGgoKSlcbiAgICAgICAgICAgICYmICghaXNPblVwcGVyQm91bmRhcnkgfHwgaSA8PSBlbmQuZ2V0TW9udGgoKSlcbiAgICAgICAgICApXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvZ2dsZU1vbnRoU2VsZWN0b3JPcGVuKCkge1xuICAgIG1vbnRoU2VsZWN0b3JPcGVuID0gIW1vbnRoU2VsZWN0b3JPcGVuO1xuICB9XG5cbiAgZnVuY3Rpb24gbW9udGhTZWxlY3RlZChldmVudCwgeyBtLCBpIH0pIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAoIW0uc2VsZWN0YWJsZSkgcmV0dXJuO1xuICAgIGRpc3BhdGNoKCdtb250aFNlbGVjdGVkJywgaSk7XG4gICAgdG9nZ2xlTW9udGhTZWxlY3Rvck9wZW4oKTtcbiAgfVxuPC9zY3JpcHQ+XHJcblxyXG48ZGl2IGNsYXNzPVwidGl0bGVcIj5cclxuICA8ZGl2IGNsYXNzPVwiaGVhZGluZy1zZWN0aW9uXCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiIFxyXG4gICAgICBjbGFzczplbmFibGVkPXtjYW5EZWNyZW1lbnRNb250aH1cclxuICAgICAgb246Y2xpY2s9eygpID0+IGRpc3BhdGNoKCdpbmNyZW1lbnRNb250aCcsIC0xKX0+XHJcbiAgICAgIDxpIGNsYXNzPVwiYXJyb3cgbGVmdFwiPjwvaT5cclxuICAgIDwvZGl2PlxyXG4gICAgPGRpdiBjbGFzcz1cImxhYmVsXCIgb246Y2xpY2s9e3RvZ2dsZU1vbnRoU2VsZWN0b3JPcGVufT5cclxuICAgICAge21vbnRoc09mWWVhclttb250aF1bMF19IHt5ZWFyfVxyXG4gICAgPC9kaXY+IFxyXG4gICAgPGRpdiBjbGFzcz1cImNvbnRyb2xcIlxyXG4gICAgICBjbGFzczplbmFibGVkPXtjYW5JbmNyZW1lbnRNb250aH1cclxuICAgICAgb246Y2xpY2s9eygpID0+IGRpc3BhdGNoKCdpbmNyZW1lbnRNb250aCcsIDEpfT5cclxuICAgICAgPGkgY2xhc3M9XCJhcnJvdyByaWdodFwiPjwvaT5cclxuICAgIDwvZGl2PlxyXG4gIDwvZGl2PlxyXG4gIDxkaXYgY2xhc3M9XCJtb250aC1zZWxlY3RvclwiIGNsYXNzOm9wZW49e21vbnRoU2VsZWN0b3JPcGVufT5cclxuICAgIHsjZWFjaCBhdmFpbGFibGVNb250aHMgYXMgbW9udGhEZWZpbml0aW9uLCBpbmRleH1cclxuICAgICAgPGRpdiBcclxuICAgICAgICBjbGFzcz1cIm1vbnRoLXNlbGVjdG9yLS1tb250aFwiIFxyXG4gICAgICAgIGNsYXNzOnNlbGVjdGVkPXtpbmRleCA9PT0gbW9udGh9XHJcbiAgICAgICAgY2xhc3M6c2VsZWN0YWJsZT17bW9udGhEZWZpbml0aW9uLnNlbGVjdGFibGV9XHJcbiAgICAgICAgb246Y2xpY2s9e2UgPT4gbW9udGhTZWxlY3RlZChlLCB7IG06IG1vbnRoRGVmaW5pdGlvbiwgaTogaW5kZXggfSl9XHJcbiAgICAgID5cclxuICAgICAgICA8c3Bhbj57bW9udGhEZWZpbml0aW9uLmFiYnJldn08L3NwYW4+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgey9lYWNofVxyXG4gIDwvZGl2PlxyXG48L2Rpdj5cclxuXHJcbjxzdHlsZT5cclxuICAuaGVhZGluZy1zZWN0aW9uIHsgXHJcbiAgICBmb250LXNpemU6IDIwcHg7XHJcbiAgICBwYWRkaW5nOiAyNHB4IDE1cHg7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xyXG4gICAgY29sb3I6ICMzZDQ1NDg7XHJcbiAgICBmb250LXdlaWdodDogYm9sZDtcclxuICB9XHJcbiAgLmxhYmVsIHsgXHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgfVxyXG4gIC5tb250aC1zZWxlY3RvciB7IFxyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgdG9wOiA3NXB4OyBcclxuICAgIGxlZnQ6IDA7IFxyXG4gICAgcmlnaHQ6IDA7IFxyXG4gICAgYm90dG9tOiAwOyBcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XHJcbiAgICB0cmFuc2l0aW9uOiBhbGwgMzAwbXM7IFxyXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjIpOyBcclxuICAgIG9wYWNpdHk6IDA7IFxyXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xyXG4gICAgei1pbmRleDogMTtcclxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICB9XHJcbiAgLm1vbnRoLXNlbGVjdG9yLm9wZW4geyBcclxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7IFxyXG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcclxuICAgIG9wYWNpdHk6IDE7XHJcbiAgfVxyXG4gIC5tb250aC1zZWxlY3Rvci0tbW9udGggeyBcclxuICAgIHdpZHRoOiAzMS4zMzMlOyBcclxuICAgIG1hcmdpbjogLjUlOyBcclxuICAgIGhlaWdodDogMjMlO1xyXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xyXG4gICAgY29sb3I6ICM0YTRhNGE7XHJcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZWZlZmVmO1xyXG4gICAgb3BhY2l0eTogMC4yO1xyXG4gIH1cclxuICAubW9udGgtc2VsZWN0b3ItLW1vbnRoLnNlbGVjdGFibGUgeyBcclxuICAgIG9wYWNpdHk6IDE7IFxyXG4gIH1cclxuICAubW9udGgtc2VsZWN0b3ItLW1vbnRoLnNlbGVjdGFibGU6aG92ZXIgeyBcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIGJveC1zaGFkb3c6IDBweCAwcHggM3B4IHJnYmEoMCwwLDAsMC4xNSk7XHJcbiAgfVxyXG4gIC5tb250aC1zZWxlY3Rvci0tbW9udGguc2VsZWN0ZWQgeyBcclxuICAgIGJhY2tncm91bmQ6IHZhcigtLWhpZ2hsaWdodC1jb2xvcik7XHJcbiAgICBjb2xvcjogI2ZmZjtcclxuICB9XHJcbiAgLm1vbnRoLXNlbGVjdG9yLS1tb250aDpiZWZvcmUgeyBcclxuICAgIGNvbnRlbnQ6ICcgJztcclxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcclxuICAgIGhlaWdodDogMTAwJTtcclxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XHJcbiAgfVxyXG4gIC5tb250aC1zZWxlY3Rvci0tbW9udGggc3BhbiB7IFxyXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgXHJcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgfVxyXG5cclxuICAuY29udHJvbCB7IFxyXG4gICAgcGFkZGluZzogMCA4cHg7XHJcbiAgICBvcGFjaXR5OiAwLjI7XHJcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoM3B4KTtcclxuICB9XHJcblxyXG4gIC5jb250cm9sLmVuYWJsZWQgeyBcclxuICAgIG9wYWNpdHk6IDE7IFxyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gIH1cclxuXHJcbiAgLmFycm93IHtcclxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcclxuICAgIHdpZHRoOiAxOHB4O1xyXG4gICAgaGVpZ2h0OiAxOHB4O1xyXG4gICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcclxuICAgIGJvcmRlci1jb2xvcjogI2E5YTlhOTtcclxuICAgIGJvcmRlci13aWR0aDogMDtcclxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDJweDtcclxuICAgIGJvcmRlci1yaWdodC13aWR0aDogMnB4O1xyXG4gIH1cclxuXHJcbiAgLmFycm93LnJpZ2h0IHtcclxuICAgIHRyYW5zZm9ybTogcm90YXRlKC00NWRlZyk7XHJcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKC00NWRlZyk7XHJcbiAgfVxyXG5cclxuICAuYXJyb3cubGVmdCB7XHJcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxMzVkZWcpO1xyXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgxMzVkZWcpO1xyXG4gIH1cclxuXHJcbjwvc3R5bGU+XHJcbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IG9uTW91bnQsIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgdGljayB9IGZyb20gJ3N2ZWx0ZSc7XG5cbiAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICBsZXQgb25jZSA9IChlbCwgZXZ0LCBjYikgPT4ge1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIpO1xuICAgIH1cbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcik7XG4gIH07XG5cbiAgbGV0IHBvcG92ZXI7XG4gIGxldCB3O1xuICBsZXQgdHJpZ2dlckNvbnRhaW5lcjtcbiAgbGV0IGNvbnRlbnRzQW5pbWF0ZWQ7XG4gIGxldCBjb250ZW50c1dyYXBwZXI7XG4gIGxldCB0cmFuc2xhdGVZID0gMDtcbiAgbGV0IHRyYW5zbGF0ZVggPSAwO1xuXG4gIGV4cG9ydCBsZXQgb3BlbiA9IGZhbHNlO1xuICBleHBvcnQgbGV0IHNocmluaztcbiAgZXhwb3J0IGxldCB0cmlnZ2VyO1xuICBleHBvcnQgY29uc3QgY2xvc2UgPSAoKSA9PiB7XG4gICAgc2hyaW5rID0gdHJ1ZTtcbiAgICBvbmNlKGNvbnRlbnRzQW5pbWF0ZWQsICdhbmltYXRpb25lbmQnLCAoKSA9PiB7XG4gICAgICBzaHJpbmsgPSBmYWxzZTtcbiAgICAgIG9wZW4gPSBmYWxzZTtcbiAgICAgIGRpc3BhdGNoKCdjbG9zZWQnKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja0ZvckZvY3VzTG9zcyhldnQpIHtcbiAgICBpZiAoIW9wZW4pIHJldHVybjtcbiAgICBsZXQgZWwgPSBldnQudGFyZ2V0O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGRvIHtcclxuICAgICAgaWYgKGVsID09PSBwb3BvdmVyKSByZXR1cm47XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgfSB3aGlsZSAoZWwgPSBlbC5wYXJlbnROb2RlKTtcclxuICAgIGNsb3NlKCk7XG4gIH1cblxuICBvbk1vdW50KCgpID0+IHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNoZWNrRm9yRm9jdXNMb3NzKTtcbiAgICBpZiAoIXRyaWdnZXIpIHJldHVybjtcbiAgICB0cmlnZ2VyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRyaWdnZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0cmlnZ2VyKSk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNoZWNrRm9yRm9jdXNMb3NzKTtcbiAgICB9O1xuICB9KTtcblxuICBjb25zdCBnZXREaXN0YW5jZVRvRWRnZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFvcGVuKSB7IG9wZW4gPSB0cnVlOyB9XG4gICAgYXdhaXQgdGljaygpO1xuICAgIGxldCByZWN0ID0gY29udGVudHNXcmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHJlY3QudG9wICsgKC0xICogdHJhbnNsYXRlWSksXG4gICAgICBib3R0b206IHdpbmRvdy5pbm5lckhlaWdodCAtIHJlY3QuYm90dG9tICsgdHJhbnNsYXRlWSxcbiAgICAgIGxlZnQ6IHJlY3QubGVmdCArICgtMSAqIHRyYW5zbGF0ZVgpLFxuICAgICAgcmlnaHQ6IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGggLSByZWN0LnJpZ2h0ICsgdHJhbnNsYXRlWFxuICAgIH07XG4gIH07XG5cbiAgY29uc3QgZ2V0VHJhbnNsYXRlID0gYXN5bmMgKCkgPT4ge1xuICAgIGxldCBkaXN0ID0gYXdhaXQgZ2V0RGlzdGFuY2VUb0VkZ2VzKCk7XG4gICAgbGV0IHg7IGxldFxuICAgICAgeTtcbiAgICBpZiAodyA8IDQ4MCkge1xuICAgICAgeSA9IGRpc3QuYm90dG9tO1xuICAgIH0gZWxzZSBpZiAoZGlzdC50b3AgPCAwKSB7XG4gICAgICB5ID0gTWF0aC5hYnMoZGlzdC50b3ApO1xuICAgIH0gZWxzZSBpZiAoZGlzdC5ib3R0b20gPCAwKSB7XG4gICAgICB5ID0gZGlzdC5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSAwO1xuICAgIH1cbiAgICBpZiAoZGlzdC5sZWZ0IDwgMCkge1xuICAgICAgeCA9IE1hdGguYWJzKGRpc3QubGVmdCk7XG4gICAgfSBlbHNlIGlmIChkaXN0LnJpZ2h0IDwgMCkge1xuICAgICAgeCA9IGRpc3QucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAwO1xuICAgIH1cbiAgICByZXR1cm4geyB4LCB5IH07XG4gIH07XG5cbiAgY29uc3QgZG9PcGVuID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYXdhaXQgZ2V0VHJhbnNsYXRlKCk7XG5cbiAgICB0cmFuc2xhdGVYID0geDtcbiAgICB0cmFuc2xhdGVZID0geTtcbiAgICBvcGVuID0gdHJ1ZTtcblxuICAgIGRpc3BhdGNoKCdvcGVuZWQnKTtcbiAgfTtcbjwvc2NyaXB0PlxyXG5cclxuPHN2ZWx0ZTp3aW5kb3cgYmluZDppbm5lcldpZHRoPXt3fSAvPlxyXG48ZGl2IGNsYXNzPVwic2MtcG9wb3ZlclwiIGJpbmQ6dGhpcz17cG9wb3Zlcn0+XHJcbiAgPGRpdiBjbGFzcz1cInRyaWdnZXJcIiBvbjpjbGljaz17ZG9PcGVufSBiaW5kOnRoaXM9e3RyaWdnZXJDb250YWluZXJ9PlxyXG4gICAgPHNsb3QgbmFtZT1cInRyaWdnZXJcIj5cclxuICAgIDwvc2xvdD5cclxuICA8L2Rpdj5cclxuICA8ZGl2IFxyXG4gICAgY2xhc3M9XCJjb250ZW50cy13cmFwcGVyXCIgXHJcbiAgICBjbGFzczp2aXNpYmxlPXtvcGVufVxyXG4gICAgY2xhc3M6c2hyaW5rPXtzaHJpbmt9XHJcbiAgICBzdHlsZT1cInRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsLTUwJSkgdHJhbnNsYXRlKHt0cmFuc2xhdGVYfXB4LCB7dHJhbnNsYXRlWX1weClcIiBcclxuICAgIGJpbmQ6dGhpcz17Y29udGVudHNXcmFwcGVyfT5cclxuICAgIDxkaXYgY2xhc3M9XCJjb250ZW50c1wiIGJpbmQ6dGhpcz17Y29udGVudHNBbmltYXRlZH0+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50cy1pbm5lclwiPlxyXG4gICAgICAgIDxzbG90IG5hbWU9XCJjb250ZW50c1wiPjwvc2xvdD5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuPC9kaXY+XHJcblxyXG48c3R5bGU+XHJcbiAgLnNjLXBvcG92ZXIgeyBcclxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICB9XHJcblxyXG4gIC5jb250ZW50cy13cmFwcGVyIHsgXHJcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTsgXHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB0b3A6IDUwJTsgXHJcbiAgICBsZWZ0OiA1MCU7IFxyXG4gICAgdHJhbnNpdGlvbjogbm9uZTtcclxuICAgIHotaW5kZXg6IDI7XHJcbiAgICBkaXNwbGF5OiBub25lO1xyXG4gIH1cclxuXHJcbiAgLmNvbnRlbnRzIHsgXHJcbiAgICBiYWNrZ3JvdW5kOiAjZmZmO1xyXG4gICAgYm94LXNoYWRvdzogMHB4IDEwcHggMjZweCByZ2JhKDAsMCwwLDAuNCkgO1xyXG4gICAgb3BhY2l0eTogLjg7IFxyXG4gICAgcGFkZGluZy10b3A6IDA7XHJcbiAgICBkaXNwbGF5OiBub25lO1xyXG4gICAgYW5pbWF0aW9uOiBncm93IDIwMG1zIGZvcndhcmRzIGN1YmljLWJlemllciguOTIsLjA5LC4xOCwxLjA1KTtcclxuICB9XHJcblxyXG4gIC5jb250ZW50cy1pbm5lciB7IFxyXG4gICAgYW5pbWF0aW9uOiBmYWRlSW4gNDAwbXMgZm9yd2FyZHM7XHJcbiAgfVxyXG5cclxuICAuY29udGVudHMtd3JhcHBlci52aXNpYmxlIHsgXHJcbiAgICBkaXNwbGF5OiBibG9jaztcclxuICB9XHJcblxyXG4gIC5jb250ZW50cy13cmFwcGVyLnZpc2libGUgLmNvbnRlbnRzIHsgXHJcbiAgICBvcGFjaXR5OiAxOyBcclxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XHJcbiAgICBkaXNwbGF5OiBibG9jaztcclxuICB9XHJcblxyXG4gIC5jb250ZW50cy13cmFwcGVyLnNocmluayAuY29udGVudHMgeyBcclxuICAgIGFuaW1hdGlvbjogc2hyaW5rIDE1MG1zIGZvcndhcmRzIGN1YmljLWJlemllciguOTIsLjA5LC4xOCwxLjA1KTtcclxuICB9XHJcblxyXG4gIEBrZXlmcmFtZXMgZ3JvdyB7IFxyXG4gICAgMCUgeyBcclxuICAgICAgdHJhbnNmb3JtOiBzY2FsZSguOSwuMSk7IFxyXG4gICAgICBvcGFjaXR5OiAwOyBcclxuICAgIH1cclxuICAgIDMwJSB7IFxyXG4gICAgICBvcGFjaXR5OiAxOyBcclxuICAgIH1cclxuICAgIDEwMCUgeyBcclxuICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIEBrZXlmcmFtZXMgc2hyaW5rIHsgXHJcbiAgICAwJSB7IFxyXG4gICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpOyBcclxuICAgICAgb3BhY2l0eTogMTsgXHJcbiAgICB9XHJcbiAgICA3MCUgeyBcclxuICAgICAgb3BhY2l0eTogMTsgXHJcbiAgICB9XHJcbiAgICAxMDAlIHsgXHJcbiAgICAgIG9wYWNpdHk6IDA7IFxyXG4gICAgICB0cmFuc2Zvcm06IHNjYWxlKC45LC4xKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIEBrZXlmcmFtZXMgZmFkZUluIHsgXHJcbiAgICAwJSB7IFxyXG4gICAgICBvcGFjaXR5OiAwOyBcclxuICAgIH1cclxuICAgIDUwJSB7IFxyXG4gICAgICBvcGFjaXR5OiAwO1xyXG4gICAgfVxyXG4gICAgMTAwJSB7IFxyXG4gICAgICBvcGFjaXR5OiAxOyBcclxuICAgIH1cclxuICB9XHJcbjwvc3R5bGU+XHJcbiIsIi8qKlxyXG4gKiBnZW5lcmljIGZ1bmN0aW9uIHRvIGluamVjdCBkYXRhIGludG8gdG9rZW4tbGFkZW4gc3RyaW5nXHJcbiAqIEBwYXJhbSBzdHIge1N0cmluZ30gUmVxdWlyZWRcclxuICogQHBhcmFtIG5hbWUge1N0cmluZ30gUmVxdWlyZWRcclxuICogQHBhcmFtIHZhbHVlIHtTdHJpbmd8SW50ZWdlcn0gUmVxdWlyZWRcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICpcclxuICogQGV4YW1wbGVcclxuICogaW5qZWN0U3RyaW5nRGF0YShcIlRoZSBmb2xsb3dpbmcgaXMgYSB0b2tlbjogI3t0b2tlbk5hbWV9XCIsIFwidG9rZW5OYW1lXCIsIDEyMyk7IFxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBcIlRoZSBmb2xsb3dpbmcgaXMgYSB0b2tlbjogMTIzXCJcclxuICpcclxuICovXHJcbmNvbnN0IGluamVjdFN0cmluZ0RhdGEgPSAoc3RyLG5hbWUsdmFsdWUpID0+IHN0clxyXG4gIC5yZXBsYWNlKG5ldyBSZWdFeHAoJyN7JytuYW1lKyd9JywnZycpLCB2YWx1ZSk7XHJcblxyXG4vKipcclxuICogR2VuZXJpYyBmdW5jdGlvbiB0byBlbmZvcmNlIGxlbmd0aCBvZiBzdHJpbmcuIFxyXG4gKiBcclxuICogUGFzcyBhIHN0cmluZyBvciBudW1iZXIgdG8gdGhpcyBmdW5jdGlvbiBhbmQgc3BlY2lmeSB0aGUgZGVzaXJlZCBsZW5ndGguXHJcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBlaXRoZXIgcGFkIHRoZSAjIHdpdGggbGVhZGluZyAwJ3MgKGlmIHN0ci5sZW5ndGggPCBsZW5ndGgpXHJcbiAqIG9yIHJlbW92ZSBkYXRhIGZyb20gdGhlIGVuZCAoQGZyb21CYWNrPT1mYWxzZSkgb3IgYmVnaW5uaW5nIChAZnJvbUJhY2s9PXRydWUpXHJcbiAqIG9mIHRoZSBzdHJpbmcgd2hlbiBzdHIubGVuZ3RoID4gbGVuZ3RoLlxyXG4gKlxyXG4gKiBXaGVuIGxlbmd0aCA9PSBzdHIubGVuZ3RoIG9yIHR5cGVvZiBsZW5ndGggPT0gJ3VuZGVmaW5lZCcsIHRoaXMgZnVuY3Rpb25cclxuICogcmV0dXJucyB0aGUgb3JpZ2luYWwgQHN0ciBwYXJhbWV0ZXIuXHJcbiAqIFxyXG4gKiBAcGFyYW0gc3RyIHtTdHJpbmd9IFJlcXVpcmVkXHJcbiAqIEBwYXJhbSBsZW5ndGgge0ludGVnZXJ9IFJlcXVpcmVkXHJcbiAqIEBwYXJhbSBmcm9tQmFjayB7Qm9vbGVhbn0gT3B0aW9uYWxcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICpcclxuICovXHJcbmNvbnN0IGVuZm9yY2VMZW5ndGggPSBmdW5jdGlvbihzdHIsbGVuZ3RoLGZyb21CYWNrKSB7XHJcbiAgc3RyID0gc3RyLnRvU3RyaW5nKCk7XHJcbiAgaWYodHlwZW9mIGxlbmd0aCA9PSAndW5kZWZpbmVkJykgcmV0dXJuIHN0cjtcclxuICBpZihzdHIubGVuZ3RoID09IGxlbmd0aCkgcmV0dXJuIHN0cjtcclxuICBmcm9tQmFjayA9ICh0eXBlb2YgZnJvbUJhY2sgPT0gJ3VuZGVmaW5lZCcpID8gZmFsc2UgOiBmcm9tQmFjaztcclxuICBpZihzdHIubGVuZ3RoIDwgbGVuZ3RoKSB7XHJcbiAgICAvLyBwYWQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nIHcvIGVub3VnaCAwJ3MgdG8gcmVhY2ggZGVzaXJlZCBsZW5ndGg6XHJcbiAgICB3aGlsZShsZW5ndGggLSBzdHIubGVuZ3RoID4gMCkgc3RyID0gJzAnICsgc3RyO1xyXG4gIH0gZWxzZSBpZihzdHIubGVuZ3RoID4gbGVuZ3RoKSB7XHJcbiAgICBpZihmcm9tQmFjaykge1xyXG4gICAgICAvLyBncmFiIHRoZSBkZXNpcmVkICMvY2hhcnMgZnJvbSBlbmQgb2Ygc3RyaW5nOiBleDogJzIwMTUnIC0+ICcxNSdcclxuICAgICAgc3RyID0gc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoLWxlbmd0aCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBncmFiIHRoZSBkZXNpcmVkICMvY2hhcnMgZnJvbSBiZWdpbm5pbmcgb2Ygc3RyaW5nOiBleDogJzIwMTUnIC0+ICcyMCdcclxuICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLGxlbmd0aCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBzdHI7XHJcbn07XG5cbmNvbnN0IGRheXNPZldlZWsgPSBbIFxyXG4gIFsgJ1N1bmRheScsICdTdW4nIF0sXHJcbiAgWyAnTW9uZGF5JywgJ01vbicgXSxcclxuICBbICdUdWVzZGF5JywgJ1R1ZScgXSxcclxuICBbICdXZWRuZXNkYXknLCAnV2VkJyBdLFxyXG4gIFsgJ1RodXJzZGF5JywgJ1RodScgXSxcclxuICBbICdGcmlkYXknLCAnRnJpJyBdLFxyXG4gIFsgJ1NhdHVyZGF5JywgJ1NhdCcgXVxyXG5dO1xyXG5cclxuY29uc3QgbW9udGhzT2ZZZWFyID0gWyBcclxuICBbICdKYW51YXJ5JywgJ0phbicgXSxcclxuICBbICdGZWJydWFyeScsICdGZWInIF0sXHJcbiAgWyAnTWFyY2gnLCAnTWFyJyBdLFxyXG4gIFsgJ0FwcmlsJywgJ0FwcicgXSxcclxuICBbICdNYXknLCAnTWF5JyBdLFxyXG4gIFsgJ0p1bmUnLCAnSnVuJyBdLFxyXG4gIFsgJ0p1bHknLCAnSnVsJyBdLFxyXG4gIFsgJ0F1Z3VzdCcsICdBdWcnIF0sXHJcbiAgWyAnU2VwdGVtYmVyJywgJ1NlcCcgXSxcclxuICBbICdPY3RvYmVyJywgJ09jdCcgXSxcclxuICBbICdOb3ZlbWJlcicsICdOb3YnIF0sXHJcbiAgWyAnRGVjZW1iZXInLCAnRGVjJyBdXHJcbl07XHJcblxyXG5sZXQgZGljdGlvbmFyeSA9IHsgXHJcbiAgZGF5c09mV2VlaywgXHJcbiAgbW9udGhzT2ZZZWFyXHJcbn07XHJcblxyXG5jb25zdCBleHRlbmREaWN0aW9uYXJ5ID0gKGNvbmYpID0+IFxyXG4gIE9iamVjdC5rZXlzKGNvbmYpLmZvckVhY2goa2V5ID0+IHtcclxuICAgIGlmKGRpY3Rpb25hcnlba2V5XSAmJiBkaWN0aW9uYXJ5W2tleV0ubGVuZ3RoID09IGNvbmZba2V5XS5sZW5ndGgpIHtcclxuICAgICAgZGljdGlvbmFyeVtrZXldID0gY29uZltrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuY29uc3QgcmVzZXREaWN0aW9uYXJ5ID0gKCkgPT4gZXh0ZW5kRGljdGlvbmFyeSh7ZGF5c09mV2Vlayxtb250aHNPZlllYXJ9KTtcblxudmFyIGFjY2VwdGVkRGF0ZVRva2VucyA9IFtcclxuICB7IFxyXG4gICAgLy8gZDogZGF5IG9mIHRoZSBtb250aCwgMiBkaWdpdHMgd2l0aCBsZWFkaW5nIHplcm9zOlxyXG4gICAga2V5OiAnZCcsIFxyXG4gICAgbWV0aG9kOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBlbmZvcmNlTGVuZ3RoKGRhdGUuZ2V0RGF0ZSgpLCAyKTsgfSBcclxuICB9LCB7IFxyXG4gICAgLy8gRDogdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiBkYXksIDMgbGV0dGVyczogU3VuIHRocnUgU2F0XHJcbiAgICBrZXk6ICdEJywgXHJcbiAgICBtZXRob2Q6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRpY3Rpb25hcnkuZGF5c09mV2Vla1tkYXRlLmdldERheSgpXVsxXTsgfSBcclxuICB9LCB7IFxyXG4gICAgLy8gajogZGF5IG9mIG1vbnRoIHdpdGhvdXQgbGVhZGluZyAwJ3NcclxuICAgIGtleTogJ2onLCBcclxuICAgIG1ldGhvZDogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXREYXRlKCk7IH0gXHJcbiAgfSwgeyBcclxuICAgIC8vIGw6IGZ1bGwgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiBkYXkgb2Ygd2VlazogU3VuZGF5IHRocnUgU2F0dXJkYXlcclxuICAgIGtleTogJ2wnLCBcclxuICAgIG1ldGhvZDogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGljdGlvbmFyeS5kYXlzT2ZXZWVrW2RhdGUuZ2V0RGF5KCldWzBdOyB9IFxyXG4gIH0sIHsgXHJcbiAgICAvLyBGOiBmdWxsIHRleHQgbW9udGg6ICdKYW51YXJ5JyB0aHJ1ICdEZWNlbWJlcidcclxuICAgIGtleTogJ0YnLCBcclxuICAgIG1ldGhvZDogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGljdGlvbmFyeS5tb250aHNPZlllYXJbZGF0ZS5nZXRNb250aCgpXVswXTsgfSBcclxuICB9LCB7IFxyXG4gICAgLy8gbTogMiBkaWdpdCBudW1lcmljIG1vbnRoOiAnMDEnIC0gJzEyJzpcclxuICAgIGtleTogJ20nLCBcclxuICAgIG1ldGhvZDogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZW5mb3JjZUxlbmd0aChkYXRlLmdldE1vbnRoKCkrMSwyKTsgfSBcclxuICB9LCB7IFxyXG4gICAgLy8gTTogYSBzaG9ydCB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb250aCwgMyBsZXR0ZXJzOiAnSmFuJyAtICdEZWMnXHJcbiAgICBrZXk6ICdNJywgXHJcbiAgICBtZXRob2Q6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRpY3Rpb25hcnkubW9udGhzT2ZZZWFyW2RhdGUuZ2V0TW9udGgoKV1bMV07IH0gXHJcbiAgfSwgeyBcclxuICAgIC8vIG46IG51bWVyaWMgcmVwcmVzZXRhdGlvbiBvZiBtb250aCB3L28gbGVhZGluZyAwJ3MsICcxJyAtICcxMic6XHJcbiAgICBrZXk6ICduJywgXHJcbiAgICBtZXRob2Q6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKSArIDE7IH0gXHJcbiAgfSwgeyBcclxuICAgIC8vIFk6IEZ1bGwgbnVtZXJpYyB5ZWFyLCA0IGRpZ2l0c1xyXG4gICAga2V5OiAnWScsIFxyXG4gICAgbWV0aG9kOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7IH0gXHJcbiAgfSwgeyBcclxuICAgIC8vIHk6IDIgZGlnaXQgbnVtZXJpYyB5ZWFyOlxyXG4gICAga2V5OiAneScsIFxyXG4gICAgbWV0aG9kOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBlbmZvcmNlTGVuZ3RoKGRhdGUuZ2V0RnVsbFllYXIoKSwyLHRydWUpOyB9XHJcbiAgIH1cclxuXTtcclxuXHJcbnZhciBhY2NlcHRlZFRpbWVUb2tlbnMgPSBbXHJcbiAgeyBcclxuICAgIC8vIGE6IGxvd2VyY2FzZSBhbnRlIG1lcmlkaWVtIGFuZCBwb3N0IG1lcmlkaWVtICdhbScgb3IgJ3BtJ1xyXG4gICAga2V5OiAnYScsIFxyXG4gICAgbWV0aG9kOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiAoZGF0ZS5nZXRIb3VycygpID4gMTEpID8gJ3BtJyA6ICdhbSc7IH0gXHJcbiAgfSwgeyBcclxuICAgIC8vIEE6IHVwcGVyY2FzZSBhbnRlIG1lcmRpaWVtIGFuZCBwb3N0IG1lcmlkaWVtICdBTScgb3IgJ1BNJ1xyXG4gICAga2V5OiAnQScsIFxyXG4gICAgbWV0aG9kOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiAoZGF0ZS5nZXRIb3VycygpID4gMTEpID8gJ1BNJyA6ICdBTSc7IH0gXHJcbiAgfSwgeyBcclxuICAgIC8vIGc6IDEyLWhvdXIgZm9ybWF0IG9mIGFuIGhvdXIgd2l0aG91dCBsZWFkaW5nIHplcm9zIDEtMTJcclxuICAgIGtleTogJ2cnLCBcclxuICAgIG1ldGhvZDogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRIb3VycygpICUgMTIgfHwgMTI7IH0gXHJcbiAgfSwgeyBcclxuICAgIC8vIEc6IDI0LWhvdXIgZm9ybWF0IG9mIGFuIGhvdXIgd2l0aG91dCBsZWFkaW5nIHplcm9zIDAtMjNcclxuICAgIGtleTogJ0cnLCBcclxuICAgIG1ldGhvZDogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRIb3VycygpOyB9IFxyXG4gIH0sIHsgXHJcbiAgICAvLyBoOiAxMi1ob3VyIGZvcm1hdCBvZiBhbiBob3VyIHdpdGggbGVhZGluZyB6ZXJvcyAwMS0xMlxyXG4gICAga2V5OiAnaCcsIFxyXG4gICAgbWV0aG9kOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBlbmZvcmNlTGVuZ3RoKGRhdGUuZ2V0SG91cnMoKSUxMiB8fCAxMiwyKTsgfSBcclxuICB9LCB7IFxyXG4gICAgLy8gSDogMjQtaG91ciBmb3JtYXQgb2YgYW4gaG91ciB3aXRoIGxlYWRpbmcgemVyb3M6IDAwLTIzXHJcbiAgICBrZXk6ICdIJywgXHJcbiAgICBtZXRob2Q6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGVuZm9yY2VMZW5ndGgoZGF0ZS5nZXRIb3VycygpLDIpOyB9IFxyXG4gIH0sIHsgXHJcbiAgICAvLyBpOiBNaW51dGVzIHdpdGggbGVhZGluZyB6ZXJvcyAwMC01OVxyXG4gICAga2V5OiAnaScsIFxyXG4gICAgbWV0aG9kOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBlbmZvcmNlTGVuZ3RoKGRhdGUuZ2V0TWludXRlcygpLDIpOyB9IFxyXG4gIH0sIHsgXHJcbiAgICAvLyBzOiBTZWNvbmRzIHdpdGggbGVhZGluZyB6ZXJvcyAwMC01OVxyXG4gICAga2V5OiAncycsIFxyXG4gICAgbWV0aG9kOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBlbmZvcmNlTGVuZ3RoKGRhdGUuZ2V0U2Vjb25kcygpLDIpOyB9XHJcbiAgIH1cclxuXTtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hdGlvbmFsaXphdGlvbiBvYmplY3QgZm9yIHRpbWVVdGlscy5pbnRlcm5hdGlvbmFsaXplKCkuXHJcbiAqIEB0eXBlZGVmIGludGVybmF0aW9uYWxpemVPYmpcclxuICogQHByb3BlcnR5IHtBcnJheX0gW2RheXNPZldlZWs9WyAnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknIF1dIGRheXNPZldlZWsgV2Vla2RheSBsYWJlbHMgYXMgc3RyaW5ncywgc3RhcnRpbmcgd2l0aCBTdW5kYXkuXHJcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IFttb250aHNPZlllYXI9WyAnSmFudWFyeScsJ0ZlYnJ1YXJ5JywnTWFyY2gnLCdBcHJpbCcsJ01heScsJ0p1bmUnLCdKdWx5JywnQXVndXN0JywnU2VwdGVtYmVyJywnT2N0b2JlcicsJ05vdmVtYmVyJywnRGVjZW1iZXInIF1dIG1vbnRoc09mWWVhciBNb250aCBsYWJlbHMgYXMgc3RyaW5ncywgc3RhcnRpbmcgd2l0aCBKYW51YXJ5LlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIHN1cHBvcnQgYWRkaXRpb25hbCBsYW5ndWFnZXMgYnkgcGFzc2luZyBhbiBvYmplY3Qgd2l0aCBcclxuICogYGRheXNPZldlZWtgIGFuZCBgbW9udGhzT2ZZZWFyYCBhdHRyaWJ1dGVzLiAgRWFjaCBhdHRyaWJ1dGUgc2hvdWxkIGJlIGFuIGFycmF5IG9mXHJcbiAqIHN0cmluZ3MgKGV4OiBgZGF5c09mV2VlazogWydtb25kYXknLCAndHVlc2RheScsICd3ZWRuZXNkYXknLi4uXWApXHJcbiAqXHJcbiAqIEBwYXJhbSB7aW50ZXJuYXRpb25hbGl6ZU9ian0gY29uZlxyXG4gKi9cclxuY29uc3QgaW50ZXJuYXRpb25hbGl6ZSA9IChjb25mPXt9KSA9PiB7IFxyXG4gIGV4dGVuZERpY3Rpb25hcnkoY29uZik7XHJcbn07XHJcblxyXG4vKipcclxuICogZ2VuZXJpYyBmb3JtYXREYXRlIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgZHluYW1pYyB0ZW1wbGF0ZXNcclxuICogQHBhcmFtIGRhdGUge0RhdGV9IFJlcXVpcmVkXHJcbiAqIEBwYXJhbSB0ZW1wbGF0ZSB7U3RyaW5nfSBPcHRpb25hbFxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBmb3JtYXREYXRlKG5ldyBEYXRlKCksICcje019LiAje2p9LCAje1l9JylcclxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBhIGZvcm1hdHRlZCBkYXRlXHJcbiAqXHJcbiAqL1xyXG5jb25zdCBmb3JtYXREYXRlID0gKGRhdGUsdGVtcGxhdGU9JyN7bX0vI3tkfS8je1l9JykgPT4ge1xyXG4gIGFjY2VwdGVkRGF0ZVRva2Vucy5mb3JFYWNoKHRva2VuID0+IHtcclxuICAgIGlmKHRlbXBsYXRlLmluZGV4T2YoYCN7JHt0b2tlbi5rZXl9fWApID09IC0xKSByZXR1cm47IFxyXG4gICAgdGVtcGxhdGUgPSBpbmplY3RTdHJpbmdEYXRhKHRlbXBsYXRlLHRva2VuLmtleSx0b2tlbi5tZXRob2QoZGF0ZSkpO1xyXG4gIH0pOyBcclxuICBhY2NlcHRlZFRpbWVUb2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB7XHJcbiAgICBpZih0ZW1wbGF0ZS5pbmRleE9mKGAjeyR7dG9rZW4ua2V5fX1gKSA9PSAtMSkgcmV0dXJuO1xyXG4gICAgdGVtcGxhdGUgPSBpbmplY3RTdHJpbmdEYXRhKHRlbXBsYXRlLHRva2VuLmtleSx0b2tlbi5tZXRob2QoZGF0ZSkpO1xyXG4gIH0pO1xyXG4gIHJldHVybiB0ZW1wbGF0ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTbWFsbCBmdW5jdGlvbiBmb3IgcmVzZXR0aW5nIGxhbmd1YWdlIHRvIEVuZ2xpc2ggKHVzZWQgaW4gdGVzdGluZykuXHJcbiAqL1xyXG5jb25zdCByZXNldEludGVybmF0aW9uYWxpemF0aW9uID0gKCkgPT4gcmVzZXREaWN0aW9uYXJ5KCk7XG5cbmV4cG9ydCB7IGludGVybmF0aW9uYWxpemUsIGZvcm1hdERhdGUsIHJlc2V0SW50ZXJuYXRpb25hbGl6YXRpb24gfTtcbiIsImV4cG9ydCBjb25zdCBrZXlDb2RlcyA9IHtcbiAgbGVmdDogMzcsXG4gIHVwOiAzOCxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgcGd1cDogMzMsXG4gIHBnZG93bjogMzQsXG4gIGVudGVyOiAxMyxcbiAgZXNjYXBlOiAyNyxcbiAgdGFiOiA5XG59O1xuXG5leHBvcnQgY29uc3Qga2V5Q29kZXNBcnJheSA9IE9iamVjdC5rZXlzKGtleUNvZGVzKS5tYXAoayA9PiBrZXlDb2Rlc1trXSk7XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgTW9udGggZnJvbSAnLi9Nb250aC5zdmVsdGUnO1xuICBpbXBvcnQgTmF2QmFyIGZyb20gJy4vTmF2QmFyLnN2ZWx0ZSc7XG4gIGltcG9ydCBQb3BvdmVyIGZyb20gJy4vUG9wb3Zlci5zdmVsdGUnO1xuICBpbXBvcnQgeyBnZXRNb250aHMgfSBmcm9tICcuL2xpYi9oZWxwZXJzJztcbiAgaW1wb3J0IHsgZm9ybWF0RGF0ZSwgaW50ZXJuYXRpb25hbGl6ZSB9IGZyb20gJ3RpbWVVdGlscyc7XG4gIGltcG9ydCB7IGtleUNvZGVzLCBrZXlDb2Rlc0FycmF5IH0gZnJvbSAnLi9saWIva2V5Q29kZXMnO1xuICBpbXBvcnQgeyBvbk1vdW50LCBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xuXG4gIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcblxuICBsZXQgcG9wb3ZlcjtcblxuICBleHBvcnQgbGV0IGZvcm1hdCA9ICcje219LyN7ZH0vI3tZfSc7XG4gIGV4cG9ydCBsZXQgc3RhcnQgPSBuZXcgRGF0ZSgxOTg3LCA5LCAyOSk7XG4gIGV4cG9ydCBsZXQgZW5kID0gbmV3IERhdGUoMjAyMCwgOSwgMjkpO1xuICBleHBvcnQgbGV0IHNlbGVjdGVkID0gdG9kYXk7XG4gIGV4cG9ydCBsZXQgZGF0ZUNob3NlbiA9IGZhbHNlO1xuICBleHBvcnQgbGV0IHRyaWdnZXIgPSBudWxsO1xuICBleHBvcnQgbGV0IHNlbGVjdGFibGVDYWxsYmFjayA9IG51bGw7XG4gIGV4cG9ydCBsZXQgd2Vla1N0YXJ0ID0gMDtcbiAgZXhwb3J0IGxldCBkYXlzT2ZXZWVrID0gW1xuICAgIFsnU3VuZGF5JywgJ1N1biddLFxuICAgIFsnTW9uZGF5JywgJ01vbiddLFxuICAgIFsnVHVlc2RheScsICdUdWUnXSxcbiAgICBbJ1dlZG5lc2RheScsICdXZWQnXSxcbiAgICBbJ1RodXJzZGF5JywgJ1RodSddLFxuICAgIFsnRnJpZGF5JywgJ0ZyaSddLFxuICAgIFsnU2F0dXJkYXknLCAnU2F0J11cbiAgXTtcbiAgZXhwb3J0IGxldCBtb250aHNPZlllYXIgPSBbXG4gICAgWydKYW51YXJ5JywgJ0phbiddLFxuICAgIFsnRmVicnVhcnknLCAnRmViJ10sXG4gICAgWydNYXJjaCcsICdNYXInXSxcbiAgICBbJ0FwcmlsJywgJ0FwciddLFxuICAgIFsnTWF5JywgJ01heSddLFxuICAgIFsnSnVuZScsICdKdW4nXSxcbiAgICBbJ0p1bHknLCAnSnVsJ10sXG4gICAgWydBdWd1c3QnLCAnQXVnJ10sXG4gICAgWydTZXB0ZW1iZXInLCAnU2VwJ10sXG4gICAgWydPY3RvYmVyJywgJ09jdCddLFxuICAgIFsnTm92ZW1iZXInLCAnTm92J10sXG4gICAgWydEZWNlbWJlcicsICdEZWMnXVxuICBdO1xuXG4gIGV4cG9ydCBsZXQgc3R5bGUgPSAnJztcbiAgXG4gIC8vIHRoZW1pbmcgdmFyaWFibGVzOlxuICBleHBvcnQgbGV0IGJ1dHRvbkJhY2tncm91bmRDb2xvciA9ICcjZmZmJztcbiAgZXhwb3J0IGxldCBidXR0b25Cb3JkZXJDb2xvciA9ICcjZWVlJztcbiAgZXhwb3J0IGxldCBidXR0b25UZXh0Q29sb3IgPSAnIzMzMyc7XG4gIGV4cG9ydCBsZXQgaGlnaGxpZ2h0Q29sb3IgPSAnI2Y3OTAxZSc7XG4gIGV4cG9ydCBsZXQgZGF5QmFja2dyb3VuZENvbG9yID0gJ25vbmUnO1xuICBleHBvcnQgbGV0IGRheVRleHRDb2xvciA9ICcjNGE0YTRhJztcbiAgZXhwb3J0IGxldCBkYXlIaWdobGlnaHRlZEJhY2tncm91bmRDb2xvciA9ICcjZWZlZmVmJztcbiAgZXhwb3J0IGxldCBkYXlIaWdobGlnaHRlZFRleHRDb2xvciA9ICcjNGE0YTRhJztcblxuICBpbnRlcm5hdGlvbmFsaXplKHsgZGF5c09mV2VlaywgbW9udGhzT2ZZZWFyIH0pO1xuICBsZXQgc29ydGVkRGF5c09mV2VlayA9IHdlZWtTdGFydCA9PT0gMCA/IGRheXNPZldlZWsgOiAoKCkgPT4ge1xuICAgIGxldCBkb3cgPSBkYXlzT2ZXZWVrLnNsaWNlKCk7XG4gICAgZG93LnB1c2goZG93LnNoaWZ0KCkpO1xuICAgIHJldHVybiBkb3c7XG4gIH0pKCk7XG5cbiAgbGV0IGhpZ2hsaWdodGVkID0gdG9kYXk7XG4gIGxldCBzaG91bGRTaGFrZURhdGUgPSBmYWxzZTtcbiAgbGV0IHNoYWtlSGlnaGxpZ2h0VGltZW91dDtcbiAgbGV0IG1vbnRoID0gdG9kYXkuZ2V0TW9udGgoKTtcbiAgbGV0IHllYXIgPSB0b2RheS5nZXRGdWxsWWVhcigpO1xuXG4gIGxldCBpc09wZW4gPSBmYWxzZTtcbiAgbGV0IGlzQ2xvc2luZyA9IGZhbHNlO1xuXG4gIHRvZGF5LnNldEhvdXJzKDAsIDAsIDAsIDApO1xuXG4gIGZ1bmN0aW9uIGFzc2lnbm1lbnRIYW5kbGVyKGZvcm1hdHRlZCkge1xuICAgIGlmICghdHJpZ2dlcikgcmV0dXJuO1xuICAgIHRyaWdnZXIuaW5uZXJIVE1MID0gZm9ybWF0dGVkO1xuICB9XG5cbiAgJDogbW9udGhzID0gZ2V0TW9udGhzKHN0YXJ0LCBlbmQsIHNlbGVjdGFibGVDYWxsYmFjaywgd2Vla1N0YXJ0KTtcblxuICBsZXQgbW9udGhJbmRleCA9IDA7XG4gICQ6IHtcbiAgICBtb250aEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vbnRocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKG1vbnRoc1tpXS5tb250aCA9PT0gbW9udGggJiYgbW9udGhzW2ldLnllYXIgPT09IHllYXIpIHtcbiAgICAgICAgbW9udGhJbmRleCA9IGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICQ6IHZpc2libGVNb250aCA9IG1vbnRoc1ttb250aEluZGV4XTtcblxuICAkOiB2aXNpYmxlTW9udGhJZCA9IHllYXIgKyBtb250aCAvIDEwMDtcbiAgJDogbGFzdFZpc2libGVEYXRlID0gdmlzaWJsZU1vbnRoLndlZWtzW3Zpc2libGVNb250aC53ZWVrcy5sZW5ndGggLSAxXS5kYXlzWzZdLmRhdGU7XG4gICQ6IGZpcnN0VmlzaWJsZURhdGUgPSB2aXNpYmxlTW9udGgud2Vla3NbMF0uZGF5c1swXS5kYXRlO1xuICAkOiBjYW5JbmNyZW1lbnRNb250aCA9IG1vbnRoSW5kZXggPCBtb250aHMubGVuZ3RoIC0gMTtcbiAgJDogY2FuRGVjcmVtZW50TW9udGggPSBtb250aEluZGV4ID4gMDtcbiAgJDogd3JhcHBlclN0eWxlID0gYFxuICAgIC0tYnV0dG9uLWJhY2tncm91bmQtY29sb3I6ICR7YnV0dG9uQmFja2dyb3VuZENvbG9yfTtcbiAgICAtLWJ1dHRvbi1ib3JkZXItY29sb3I6ICR7YnV0dG9uQm9yZGVyQ29sb3J9O1xuICAgIC0tYnV0dG9uLXRleHQtY29sb3I6ICR7YnV0dG9uVGV4dENvbG9yfTtcbiAgICAtLWhpZ2hsaWdodC1jb2xvcjogJHtoaWdobGlnaHRDb2xvcn07XG4gICAgLS1kYXktYmFja2dyb3VuZC1jb2xvcjogJHtkYXlCYWNrZ3JvdW5kQ29sb3J9O1xuICAgIC0tZGF5LXRleHQtY29sb3I6ICR7ZGF5VGV4dENvbG9yfTtcbiAgICAtLWRheS1oaWdobGlnaHRlZC1iYWNrZ3JvdW5kLWNvbG9yOiAke2RheUhpZ2hsaWdodGVkQmFja2dyb3VuZENvbG9yfTtcbiAgICAtLWRheS1oaWdobGlnaHRlZC10ZXh0LWNvbG9yOiAke2RheUhpZ2hsaWdodGVkVGV4dENvbG9yfTtcbiAgICAke3N0eWxlfVxuICBgO1xuXG4gIGV4cG9ydCBsZXQgZm9ybWF0dGVkU2VsZWN0ZWQ7XG4gICQ6IHtcbiAgICBmb3JtYXR0ZWRTZWxlY3RlZCA9IHR5cGVvZiBmb3JtYXQgPT09ICdmdW5jdGlvbidcbiAgICAgID8gZm9ybWF0KHNlbGVjdGVkKVxuICAgICAgOiBmb3JtYXREYXRlKHNlbGVjdGVkLCBmb3JtYXQpO1xuICB9XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgbW9udGggPSBzZWxlY3RlZC5nZXRNb250aCgpO1xuICAgIHllYXIgPSBzZWxlY3RlZC5nZXRGdWxsWWVhcigpO1xuICB9KTtcblxuICBmdW5jdGlvbiBjaGFuZ2VNb250aChzZWxlY3RlZE1vbnRoKSB7XG4gICAgbW9udGggPSBzZWxlY3RlZE1vbnRoO1xuICAgIGhpZ2hsaWdodGVkID0gbmV3IERhdGUoeWVhciwgbW9udGgsIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5jcmVtZW50TW9udGgoZGlyZWN0aW9uLCBkYXkgPSAxKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gMSAmJiAhY2FuSW5jcmVtZW50TW9udGgpIHJldHVybjtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAtMSAmJiAhY2FuRGVjcmVtZW50TW9udGgpIHJldHVybjtcbiAgICBsZXQgY3VycmVudCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKTtcbiAgICBjdXJyZW50LnNldE1vbnRoKGN1cnJlbnQuZ2V0TW9udGgoKSArIGRpcmVjdGlvbik7XG4gICAgbW9udGggPSBjdXJyZW50LmdldE1vbnRoKCk7XG4gICAgeWVhciA9IGN1cnJlbnQuZ2V0RnVsbFllYXIoKTtcbiAgICBoaWdobGlnaHRlZCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGVmYXVsdEhpZ2hsaWdodGVkKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShzZWxlY3RlZCk7XG4gIH1cblxuICBjb25zdCBnZXREYXkgPSAobSwgZCwgeSkgPT4ge1xuICAgIGxldCB0aGVNb250aCA9IG1vbnRocy5maW5kKGFNb250aCA9PiBhTW9udGgubW9udGggPT09IG0gJiYgYU1vbnRoLnllYXIgPT09IHkpO1xuICAgIGlmICghdGhlTW9udGgpIHJldHVybiBudWxsO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhlTW9udGgud2Vla3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGVNb250aC53ZWVrc1tpXS5kYXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGxldCBhRGF5ID0gdGhlTW9udGgud2Vla3NbaV0uZGF5c1tqXTtcbiAgICAgICAgaWYgKGFEYXkubW9udGggPT09IG0gJiYgYURheS5kYXkgPT09IGQgJiYgYURheS55ZWFyID09PSB5KSByZXR1cm4gYURheTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5jcmVtZW50RGF5SGlnaGxpZ2h0ZWQoYW1vdW50KSB7XG4gICAgbGV0IHByb3Bvc2VkRGF0ZSA9IG5ldyBEYXRlKGhpZ2hsaWdodGVkKTtcbiAgICBwcm9wb3NlZERhdGUuc2V0RGF0ZShoaWdobGlnaHRlZC5nZXREYXRlKCkgKyBhbW91bnQpO1xuICAgIGxldCBjb3JyZXNwb25kaW5nRGF5T2JqID0gZ2V0RGF5KFxuICAgICAgcHJvcG9zZWREYXRlLmdldE1vbnRoKCksXG4gICAgICBwcm9wb3NlZERhdGUuZ2V0RGF0ZSgpLFxuICAgICAgcHJvcG9zZWREYXRlLmdldEZ1bGxZZWFyKClcbiAgICApO1xuICAgIGlmICghY29ycmVzcG9uZGluZ0RheU9iaiB8fCAhY29ycmVzcG9uZGluZ0RheU9iai5pc0luUmFuZ2UpIHJldHVybjtcbiAgICBoaWdobGlnaHRlZCA9IHByb3Bvc2VkRGF0ZTtcbiAgICBpZiAoYW1vdW50ID4gMCAmJiBoaWdobGlnaHRlZCA+IGxhc3RWaXNpYmxlRGF0ZSkge1xuICAgICAgaW5jcmVtZW50TW9udGgoMSwgaGlnaGxpZ2h0ZWQuZ2V0RGF0ZSgpKTtcbiAgICB9XG4gICAgaWYgKGFtb3VudCA8IDAgJiYgaGlnaGxpZ2h0ZWQgPCBmaXJzdFZpc2libGVEYXRlKSB7XG4gICAgICBpbmNyZW1lbnRNb250aCgtMSwgaGlnaGxpZ2h0ZWQuZ2V0RGF0ZSgpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0lmVmlzaWJsZURhdGVJc1NlbGVjdGFibGUoZGF0ZSkge1xuICAgIGNvbnN0IHByb3Bvc2VkRGF5ID0gZ2V0RGF5KGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCksIGRhdGUuZ2V0RnVsbFllYXIoKSk7XG4gICAgcmV0dXJuIHByb3Bvc2VkRGF5ICYmIHByb3Bvc2VkRGF5LnNlbGVjdGFibGU7XG4gIH1cblxuICBmdW5jdGlvbiBzaGFrZURhdGUoZGF0ZSkge1xuICAgIGNsZWFyVGltZW91dChzaGFrZUhpZ2hsaWdodFRpbWVvdXQpO1xuICAgIHNob3VsZFNoYWtlRGF0ZSA9IGRhdGU7XG4gICAgc2hha2VIaWdobGlnaHRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzaG91bGRTaGFrZURhdGUgPSBmYWxzZTtcbiAgICB9LCA3MDApO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzaWduVmFsdWVUb1RyaWdnZXIoZm9ybWF0dGVkKSB7XG4gICAgYXNzaWdubWVudEhhbmRsZXIoZm9ybWF0dGVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyU2VsZWN0aW9uKGNob3Nlbikge1xuICAgIGlmICghY2hlY2tJZlZpc2libGVEYXRlSXNTZWxlY3RhYmxlKGNob3NlbikpIHJldHVybiBzaGFrZURhdGUoY2hvc2VuKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBjbG9zZSgpO1xuICAgIHNlbGVjdGVkID0gY2hvc2VuO1xuICAgIGRhdGVDaG9zZW4gPSB0cnVlO1xuICAgIGFzc2lnblZhbHVlVG9UcmlnZ2VyKGZvcm1hdHRlZFNlbGVjdGVkKTtcbiAgICByZXR1cm4gZGlzcGF0Y2goJ2RhdGVTZWxlY3RlZCcsIHsgZGF0ZTogY2hvc2VuIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZXZ0KSB7XG4gICAgaWYgKGtleUNvZGVzQXJyYXkuaW5kZXhPZihldnQua2V5Q29kZSkgPT09IC0xKSByZXR1cm47XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgc3dpdGNoIChldnQua2V5Q29kZSkge1xuICAgICAgY2FzZSBrZXlDb2Rlcy5sZWZ0OlxuICAgICAgICBpbmNyZW1lbnREYXlIaWdobGlnaHRlZCgtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBrZXlDb2Rlcy51cDpcbiAgICAgICAgaW5jcmVtZW50RGF5SGlnaGxpZ2h0ZWQoLTcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Uga2V5Q29kZXMucmlnaHQ6XG4gICAgICAgIGluY3JlbWVudERheUhpZ2hsaWdodGVkKDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Uga2V5Q29kZXMuZG93bjpcbiAgICAgICAgaW5jcmVtZW50RGF5SGlnaGxpZ2h0ZWQoNyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBrZXlDb2Rlcy5wZ3VwOlxuICAgICAgICBpbmNyZW1lbnRNb250aCgtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBrZXlDb2Rlcy5wZ2Rvd246XG4gICAgICAgIGluY3JlbWVudE1vbnRoKDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Uga2V5Q29kZXMuZXNjYXBlOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGtleUNvZGVzLmVudGVyOlxuICAgICAgICByZWdpc3RlclNlbGVjdGlvbihoaWdobGlnaHRlZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJDbG9zZSgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5UHJlc3MpO1xuICAgIGRpc3BhdGNoKCdjbG9zZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgcG9wb3Zlci5jbG9zZSgpO1xuICAgIHJlZ2lzdGVyQ2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyT3BlbigpIHtcbiAgICBoaWdobGlnaHRlZCA9IGdldERlZmF1bHRIaWdobGlnaHRlZCgpO1xuICAgIG1vbnRoID0gc2VsZWN0ZWQuZ2V0TW9udGgoKTtcbiAgICB5ZWFyID0gc2VsZWN0ZWQuZ2V0RnVsbFllYXIoKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5UHJlc3MpO1xuICAgIGRpc3BhdGNoKCdvcGVuJyk7XG4gIH1cblxuPC9zY3JpcHQ+XG5cbjxkaXYgXG4gIGNsYXNzPVwiZGF0ZXBpY2tlclwiIFxuICBjbGFzczpvcGVuPVwie2lzT3Blbn1cIiBcbiAgY2xhc3M6Y2xvc2luZz1cIntpc0Nsb3Npbmd9XCJcbiAgc3R5bGU9e3dyYXBwZXJTdHlsZX1cbj5cbiAgPFBvcG92ZXJcbiAgICBiaW5kOnRoaXM9XCJ7cG9wb3Zlcn1cIlxuICAgIGJpbmQ6b3Blbj1cIntpc09wZW59XCJcbiAgICBiaW5kOnNocmluaz1cIntpc0Nsb3Npbmd9XCJcbiAgICB7dHJpZ2dlcn1cbiAgICBvbjpvcGVuZWQ9XCJ7cmVnaXN0ZXJPcGVufVwiXG4gICAgb246Y2xvc2VkPVwie3JlZ2lzdGVyQ2xvc2V9XCJcbiAgPlxuICAgIDxkaXYgc2xvdD1cInRyaWdnZXJcIj5cbiAgICAgIDxzbG90PlxuICAgICAgICB7I2lmICF0cmlnZ2VyfVxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiY2FsZW5kYXItYnV0dG9uXCIgdHlwZT1cImJ1dHRvblwiPlxuICAgICAgICAgIHtmb3JtYXR0ZWRTZWxlY3RlZH1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIHsvaWZ9XG4gICAgICA8L3Nsb3Q+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBzbG90PVwiY29udGVudHNcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjYWxlbmRhclwiPlxuICAgICAgICA8TmF2QmFyIFxuICAgICAgICAgIHttb250aH1cbiAgICAgICAgICB7eWVhcn1cbiAgICAgICAgICB7Y2FuSW5jcmVtZW50TW9udGh9XG4gICAgICAgICAge2NhbkRlY3JlbWVudE1vbnRofVxuICAgICAgICAgIHtzdGFydH1cbiAgICAgICAgICB7ZW5kfVxuICAgICAgICAgIHttb250aHNPZlllYXJ9XG4gICAgICAgICAgb246bW9udGhTZWxlY3RlZD17ZSA9PiBjaGFuZ2VNb250aChlLmRldGFpbCl9XG4gICAgICAgICAgb246aW5jcmVtZW50TW9udGg9e2UgPT4gaW5jcmVtZW50TW9udGgoZS5kZXRhaWwpfSBcbiAgICAgICAgLz5cbiAgICAgICAgPGRpdiBjbGFzcz1cImxlZ2VuZFwiPlxuICAgICAgICAgIHsjZWFjaCBzb3J0ZWREYXlzT2ZXZWVrIGFzIGRheX1cbiAgICAgICAgICA8c3Bhbj57ZGF5WzFdfTwvc3Bhbj5cbiAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8TW9udGggXG4gICAgICAgICAge3Zpc2libGVNb250aH1cbiAgICAgICAgICB7c2VsZWN0ZWR9XG4gICAgICAgICAge2hpZ2hsaWdodGVkfVxuICAgICAgICAgIHtzaG91bGRTaGFrZURhdGV9XG4gICAgICAgICAgaWQ9e3Zpc2libGVNb250aElkfVxuICAgICAgICAgIG9uOmRhdGVTZWxlY3RlZD17ZSA9PiByZWdpc3RlclNlbGVjdGlvbihlLmRldGFpbCl9IFxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvUG9wb3Zlcj5cbjwvZGl2PlxuXG48c3R5bGU+XG4gIC5kYXRlcGlja2VyIHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgbWFyZ2luOiAwIGF1dG87XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIG92ZXJmbG93OiB2aXNpYmxlO1xuICB9XG5cbiAgLmNhbGVuZGFyLWJ1dHRvbiB7XG4gICAgcGFkZGluZzogMTBweCAyMHB4O1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWJ1dHRvbi1ib3JkZXItY29sb3IpO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICB3aWR0aDogMzAwcHg7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1idXR0b24tYmFja2dyb3VuZC1jb2xvcik7XG4gICAgY29sb3I6IHZhcigtLWJ1dHRvbi10ZXh0LWNvbG9yKTtcbiAgICBib3JkZXItcmFkaXVzOiA3cHg7XG4gICAgYm94LXNoYWRvdzogMHB4IDBweCAzcHggcmdiYSgwLCAwLCAwLCAwLjEpO1xuICB9XG5cbiAgKixcbiAgKjpiZWZvcmUsXG4gICo6YWZ0ZXIge1xuICAgIGJveC1zaXppbmc6IGluaGVyaXQ7XG4gIH1cblxuICAuY2FsZW5kYXIge1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgd2lkdGg6IDEwMHZ3O1xuICAgIHBhZGRpbmc6IDEwcHg7XG4gICAgcGFkZGluZy10b3A6IDA7XG4gIH1cblxuICBAbWVkaWEgKG1pbi13aWR0aDogNDgwcHgpIHtcbiAgICAuY2FsZW5kYXIge1xuICAgICAgaGVpZ2h0OiBhdXRvO1xuICAgICAgd2lkdGg6IDM0MHB4O1xuICAgICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgIH1cbiAgfVxuXG4gIC5sZWdlbmQge1xuICAgIGNvbG9yOiAjNGE0YTRhO1xuICAgIHBhZGRpbmc6IDEwcHggMDtcbiAgICBtYXJnaW4tYm90dG9tOiA1cHg7XG4gIH1cblxuICAubGVnZW5kIHNwYW4ge1xuICAgIHdpZHRoOiAxNC4yODU3MTQlO1xuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIH1cbjwvc3R5bGU+XG4iLCI8c3ZlbHRlOmhlYWQ+XG4gIDx0aXRsZT4g7Yq47IiYZ2cgLSDsi5zssq3snpAg7J2064+Ze3RpdGxlX3N1Zml4fTwvdGl0bGU+XG48L3N2ZWx0ZTpoZWFkPlxuXG5cbjxkaXYgY2xhc3M9XCJwLTYgeGw6YWJzb2x1dGUgcmVsYXRpdmUgY29udGFpbmVyIG0tYXV0b1wiPlxuICA8aDEgY2xhc3M9XCJtZDp0ZXh0LTN4bCB0ZXh0LTJ4bCBpbmxpbmUtYmxvY2tcIj7si5zssq3snpAg7J2064+ZPC9oMT5cbiAgPFRpcCA+XG4gICAgPHNwYW4gc2xvdD1cInRpcFwiPiBcbiAgICDsl6zrn6wg67Cp7IahIOyCrOydtOyXkOyEnCDsi5zssq3snpDsnZgg7Z2Q66aE7J2EIOyCtO2OtOuzvCDsiJgg7J6I7Iq164uI64ukLjxicj4gXG4gICAg64Kg7Kec7JmAIOyKpO2KuOumrOuouOulvCDshKDtg53tlbTrs7TshLjsmpQuPGJyPlxuICAgICog7JW9IO2VnOyLnOqwhCDqsITqsqnsnLzroZwg7JeF642w7J207Yq4IOuQqeuLiOuLpC5cbiAgICA8L3NwYW4+XG4gIDwvVGlwPlxuPC9kaXY+XG48ZGl2IGNsYXNzPVwiY29udGFpbmVyIG0tYXV0byBmbGV4IGZsZXgtY29sIGl0ZW1zLXN0cmV0Y2ggcGItOFwiPlxuICA8dGFibGUgY2xhc3M9XCJ0ZXh0LWNlbnRlciBtYi0xMiBtdC02XCI+XG4gICAgPHRoZWFkPlxuICAgICAgPHRyPlxuICAgICAgICA8dGg+IOuCoOynnCA8L3RoPlxuICAgICAgICA8dGg+IOyKpO2KuOumrOuouDEgPC90aD5cbiAgICAgICAgPHRoPiDsiqTtirjrpqzrqLgyIDwvdGg+XG4gICAgICA8L3RyPlxuICAgIDwvdGhlYWQ+XG4gICAgPHRib2R5PlxuICAgIDx0cj5cbiAgICAgIDx0ZD5cbiAgICAgICAgPERhdGVwaWNrZXIgXG4gICAgICAgICAgIGVuZD17bmV3IERhdGUoKX0gXG4gICAgICAgICAgIGZvcm1hdD17ZD0+ZC50b0xvY2FsZURhdGVTdHJpbmcoKX0gXG4gICAgICAgICAgIHNlbGVjdGVkPXtkYXRlfSBcbiAgICAgICAgICAgb246ZGF0ZVNlbGVjdGVkPXtvbl9kYXRlX3BpY2t9IFxuICAgICAgICAgICA+XG4gICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJwLTIgcHgtNCBiZy13aGl0ZSBib3JkZXIgdy1mdWxsIHRydW5jYXRlXCI+XG4gICAgICAgICAgICAge2RhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XG4gICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L0RhdGVwaWNrZXI+XG4gICAgICA8L3RkPlxuICAgICAgPHRkPlxuICAgICAgICA8U3RyZWFtZXJBdXRvQ29tcGxldGUgXG4gICAgICAgICAgIGJpbmQ6b25zZWxlY3Q9e29uX3N0cmVhbWVyX3NlYXJjaDF9IFxuICAgICAgICAgICBwbGFjZWhvbGRlcj1cIuyKpO2KuOumrOuouCDshKDtg50xXCIgXG4gICAgICAgICAgIGlkPVwibWlncmF0aW9uLXN0cmVhbWVyLXNlYXJjaDFcIiBcbiAgICAgICAgICAgaW5wdXRpZD1cIm1pZ3JhdGlvbi1zdHJlYW1lci1zZWFyY2gxLWlucHV0XCJcbiAgICAgICAgICAgaW5wdXRfdmFsdWU9e3N0cmVhbWVyMT8gc3RyZWFtZXIxLm5hbWU6IFwiXCJ9XG4gICAgICAgICAgIGlucHV0X2NsYXNzPVwiYmctd2hpdGUgdGV4dC1zbSB3LWZ1bGwgdHJhbnNpdGlvbi1hbGwgdHJhbnNpdGlvbi0xMDAgcGwtNyBweS0yIHRydW5jYXRlIGJvcmRlclwiIC8+XG4gICAgICA8L3RkPlxuICAgICAgPHRkPlxuICAgICAgICA8U3RyZWFtZXJBdXRvQ29tcGxldGUgXG4gICAgICAgICAgIGJpbmQ6b25zZWxlY3Q9e29uX3N0cmVhbWVyX3NlYXJjaDJ9XG4gICAgICAgICAgIHBsYWNlaG9sZGVyPVwi7Iqk7Yq466as66i4IOyEoO2DnTJcIiBcbiAgICAgICAgICAgaWQ9XCJtaWdyYXRpb24tc3RyZWFtZXItc2VhcmNoMlwiIFxuICAgICAgICAgICBpbnB1dGlkPVwibWlncmF0aW9uLXN0cmVhbWVyLXNlYXJjaDItaW5wdXRcIlxuICAgICAgICAgICBpbnB1dF92YWx1ZT17c3RyZWFtZXIyPyBzdHJlYW1lcjIubmFtZTogXCJcIn1cbiAgICAgICAgICAgaW5wdXRfY2xhc3M9XCJiZy13aGl0ZSB0ZXh0LXNtIHctZnVsbCB0cmFuc2l0aW9uLWFsbCB0cmFuc2l0aW9uLTEwMCBwbC03IHB5LTIgdHJ1bmNhdGUgYm9yZGVyXCIgLz5cbiAgICAgPC90ZD5cbiAgICA8L3RyPlxuICAgIDwvdGJvZHk+XG4gIDwvdGFibGU+XG4gIDxkaXYgY2xhc3M9XCJmbGV4IGZsZXgtcm93IHctZnVsbCBpdGVtcy1jZW50ZXIgei0yMFwiPlxuICAgIDxkaXYgY2xhc3M9XCJcIj5cbiAgICAgIDxhIGhyZWY9XCJ7c3RyZWFtZXIxPyAnL3N0cmVhbWVyLycgKyBzdHJlYW1lcjEuaWQgOiAnJ31cIlxuICAgICAgICBmb3I9XCJtaWdyYXRpb24tc3RyZWFtZXItc2VhcmNoMS1pbnB1dFwiXG4gICAgICAgIGNsYXNzPVwidy0yNCBmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBvdmVyZmxvdy12aXNpYmxlIHJlbGF0aXZlXCI+XG4gICAgICAgIHsjaWYgc3RyZWFtZXIxfVxuICAgICAgICAgIDxpbWcgY2xhc3M9XCJyb3VuZGVkLWZ1bGwgaC0yNCB3LTI0IGJvcmRlciBib3JkZXItZ3JheS02MDBcIiBzcmM9e3N0cmVhbWVyMS5wcm9maWxlX2ltYWdlX3VybH0gLz5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicHQtMiBhYnNvbHV0ZVwiIHN0eWxlPVwidG9wOiAxMDAlXCI+PHNwYW4+e3N0cmVhbWVyMS5uYW1lfTwvc3Bhbj48L2Rpdj5cbiAgICAgICAgezplbHNlfVxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3VuZGVkLWZ1bGwgaC0yNCB3LTI0IGJnLWdyYXktMTAwXCIgPiA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicHQtMiB0ZXh0LXRyYW5zcGFyZW50IHRleHQtZ3JheS00MDAgYWJzb2x1dGVcIiBzdHlsZT1cInRvcDogMTAwJVwiPjxzcGFuPj88L3NwYW4+PC9kaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgICA8L2E+XG4gICAgPC9kaXY+XG4gICAgPE1pZ3JhdGlvblRpbWVsaW5lIFxuICAgICAgIHN0cmVhbWVyPXtzdHJlYW1lcjF9IFxuICAgICAgIGhlaWdodD1cIjE1MFwiXG4gICAgICAge2RhdGV9IC8+XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiZmxleCBmbGV4LXJvdyB3LWZ1bGxcIj5cbiAgICA8ZGl2IGNsYXNzPVwidy0yNFwiPjwvZGl2PlxuICAgIDxNaWdyYXRpb25zIFxuICAgICAgICAgbWlncmF0aW9ucz17dmlld2VyX21pZ3JhdGlvbnN9XG4gICAgICAgICBjbGFzcz1cImZsZXgtMVwiXG4gICAgICAgICBpZDE9e3N0cmVhbWVyMSAmJiBzdHJlYW1lcjEuaWR9XG4gICAgICAgICBpZDI9e3N0cmVhbWVyMiAmJiBzdHJlYW1lcjIuaWR9IC8+XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiZmxleCBmbGV4LXJvdyB3LWZ1bGwgaXRlbXMtY2VudGVyIHotMTBcIj5cbiAgICA8ZGl2PlxuICAgICAgPGEgaHJlZj1cIntzdHJlYW1lcjI/ICcvc3RyZWFtZXIvJyArIHN0cmVhbWVyMi5pZCA6ICcnfVwiXG4gICAgICAgIGZvcj1cIm1pZ3JhdGlvbi1zdHJlYW1lci1zZWFyY2gyLWlucHV0XCJcbiAgICAgICAgY2xhc3M9XCJ3LTI0IGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG92ZXJmbG93LXZpc2libGUgY3Vyc29yLXBvaW50ZXIgcmVsYXRpdmVcIj5cbiAgICAgICAgeyNpZiBzdHJlYW1lcjJ9XG4gICAgICAgICAgPGltZyBjbGFzcz1cInJvdW5kZWQtZnVsbCBoLTI0IHctMjQgYm9yZGVyIGJvcmRlci1ncmF5LTYwMFwiIHNyYz17c3RyZWFtZXIyLnByb2ZpbGVfaW1hZ2VfdXJsfSAvPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwdC0yIGFic29sdXRlXCIgc3R5bGU9XCJ0b3A6IDEwMCVcIj48c3Bhbj57c3RyZWFtZXIyLm5hbWV9PC9zcGFuPjwvZGl2PlxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInJvdW5kZWQtZnVsbCBoLTI0IHctMjQgYmctZ3JheS0xMDBcIiA+IDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwdC0yIHRleHQtdHJhbnNwYXJlbnQgdGV4dC1ncmF5LTQwMCBhYnNvbHV0ZVwiIHN0eWxlPVwidG9wOiAxMDAlXCI+PHNwYW4+Pzwvc3Bhbj48L2Rpdj5cbiAgICAgICAgey9pZn1cbiAgICAgIDwvYT5cbiAgICA8L2Rpdj5cbiAgICA8TWlncmF0aW9uVGltZWxpbmUgXG4gICAgICAgc3RyZWFtZXI9e3N0cmVhbWVyMn0gXG4gICAgICAgaGVpZ2h0PVwiMTUwXCJcbiAgICAgICB7ZGF0ZX0gLz5cbiAgPC9kaXY+XG48L2Rpdj5cblxuXG48c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIj5cblx0aW1wb3J0IHsgQVBJIH0gZnJvbSAnLi4vLi4vYXBpLmpzJztcblxuICBleHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlbG9hZChwYWdlLCBzZXNzaW9uKSB7XG4gICAgaWYocGFnZS5xdWVyeS5pZDEgJiYgcGFnZS5xdWVyeS5pZDIgJiYgcGFnZS5xdWVyeS5kYXRlKSB7XG4gICAgICBsZXQgW3N0cmVhbWVyMSwgc3RyZWFtZXIyXSA9IGF3YWl0IEFQSS50aGluX3N0cmVhbWVycyhbcGFnZS5xdWVyeS5pZDEsIHBhZ2UucXVlcnkuaWQyXSk7XG4gICAgICBsZXQgdGltZSA9IG5ldyBEYXRlKHBhZ2UucXVlcnkuZGF0ZS0wKTsgdGltZS5zZXRIb3VycygwLDAsMCwwKTtcbiAgICAgIGxldCBmcm9tID0gdGltZSxcbiAgICAgICAgICB0byA9IG5ldyBEYXRlKHRpbWUuZ2V0VGltZSgpICsgMTAwMCo2MCo2MCoyNCk7XG4gICAgICBsZXQgdmlld2VyX21pZ3JhdGlvbnMgPSBhd2FpdCBBUEkudmlld2VyX21pZ3JhdGlvbl9jb3VudHMocGFnZS5xdWVyeS5pZDEsIHBhZ2UucXVlcnkuaWQyLCBmcm9tLCB0byk7XG4gICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKHBhZ2UucXVlcnkuZGF0ZS0wKTtcbiAgICAgIHJldHVybiB7IHN0cmVhbWVyMSwgc3RyZWFtZXIyLCB2aWV3ZXJfbWlncmF0aW9ucywgZGF0ZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGxldCBkYXRlID0gbmV3IERhdGUoKTsgZGF0ZS5zZXRIb3VycygwLDAsMCwwKTtcbiAgICAgIHJldHVybiB7IGRhdGUgfTtcbiAgICB9XG4gIH1cbjwvc2NyaXB0PlxuXG48c2NyaXB0PlxuICBpbXBvcnQgU3RyZWFtZXJBdXRvQ29tcGxldGUgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9TdHJlYW1lckF1dG9Db21wbGV0ZS5zdmVsdGUnO1xuXHRpbXBvcnQgTWlncmF0aW9uVGltZWxpbmUgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9NaWdyYXRpb25UaW1lbGluZS5zdmVsdGUnO1xuXHRpbXBvcnQgTWlncmF0aW9ucyBmcm9tICcuLi8uLi9jb21wb25lbnRzL01pZ3JhdGlvbnMuc3ZlbHRlJztcblx0aW1wb3J0IFRpcCBmcm9tICcuLi8uLi9jb21wb25lbnRzL1RpcC5zdmVsdGUnO1xuICBpbXBvcnQgRGF0ZXBpY2tlciBmcm9tIFwic3ZlbHRlLWNhbGVuZGFyXCI7XG5cbiAgZXhwb3J0IGxldCBzdHJlYW1lcjE7XG4gIGV4cG9ydCBsZXQgc3RyZWFtZXIyO1xuICBleHBvcnQgbGV0IHZpZXdlcl9taWdyYXRpb25zID0gW107XG4gIGV4cG9ydCBsZXQgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gIGxldCB0aXRsZV9zdWZpeCA9IHN0cmVhbWVyMSAmJiBzdHJlYW1lcjI/IGB8ICR7c3RyZWFtZXIxLm5hbWV9IDwtPiAke3N0cmVhbWVyMi5uYW1lfWA6ICcnO1xuXG5cblxuICBmdW5jdGlvbiB0cnlfbG9hZCgpe1xuICAgIGlmKHN0cmVhbWVyMSAmJiBzdHJlYW1lcjIgJiYgZGF0ZSl7XG4gICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoID0gYGlkMT0ke3N0cmVhbWVyMS5pZH0maWQyPSR7c3RyZWFtZXIyLmlkfSZkYXRlPSR7ZGF0ZS5nZXRUaW1lKCl9YDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbl9kYXRlX3BpY2soZSkge1xuICAgIGlmKGUuZGV0YWlsLmRhdGUgIT0gZGF0ZSl7XG4gICAgICBkYXRlID0gZS5kZXRhaWwuZGF0ZTtcbiAgICAgIHRyeV9sb2FkKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uX3N0cmVhbWVyX3NlYXJjaDEodGFyZ2V0KSB7XG4gICAgaWYoc3RyZWFtZXIxICE9IHRhcmdldCl7XG4gICAgICBzdHJlYW1lcjEgPSB0YXJnZXQ7XG4gICAgICB0cnlfbG9hZCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbl9zdHJlYW1lcl9zZWFyY2gyKHRhcmdldCkge1xuICAgIGlmKHN0cmVhbWVyMiAhPSB0YXJnZXQpe1xuICAgICAgc3RyZWFtZXIyID0gdGFyZ2V0O1xuICAgICAgdHJ5X2xvYWQoKTtcbiAgICB9XG4gIH1cbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIDpnbG9iYWwoLmNvbnRlbnRzLXdyYXBwZXIpIHtcbiAgICB6LWluZGV4OiA1MCAhaW1wb3J0YW50O1xuICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbImZhVXNlciIsImZhVXNlclNlY3JldCIsImZhS2V5IiwiZmFDb21tZW50RG90cyIsImZhSGlzdG9yeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnRUFPK0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsU0FBUyxNQUFFLGtCQUFrQixDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsTUFBRSxtQkFBbUIsQ0FBQztnQ0FBUyxrQkFBa0I7aUNBQVUsbUJBQW1COzs7Ozs7Ozs7OztnSkFBeEosSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsU0FBUyxNQUFFLGtCQUFrQixDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsTUFBRSxtQkFBbUIsQ0FBQzs7Ozs7aUNBQVMsa0JBQWtCOzs7O2tDQUFVLG1CQUFtQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FCQUR4SyxJQUFJLENBQUMsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvRUFESSxJQUFJLENBQUMsRUFBRTtrQ0FBVSxrQkFBa0I7bUNBQVUsbUJBQW1COztnREFBbUMsTUFBTSxDQUFDLElBQUk7Ozs7Ozs7Ozs7V0FDbEksSUFBSSxD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QyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ25FLEdBQUcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxHQUFHOztVQUVoQixPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxlQUFlLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDOzs7VUFHN0gsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxlQUFlLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO09BQ3RJLEVBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMURMLE1BQU0sZUFBZSxHQUFHLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsU0FBUyxHQUFHLENBQUMsS0FBSztFQUNoRSxJQUFJLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0VBQ3BDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxD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
