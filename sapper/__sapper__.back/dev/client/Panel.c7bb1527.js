import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, D as create_slot, I as assign, N as exclude_internal_props, v as mount_component, w as transition_in, x as transition_out, y as destroy_component, e as element, a as space, c as claim_element, f as children, k as claim_space, j as detach_dev, l as attr_dev, m as toggle_class, o as add_location, P as listen_dev, p as insert_dev, q as append_dev, E as get_slot_changes, F as get_slot_context, z as group_outros, A as check_outros, R as run_all } from './index.1eb00da2.js';
import { T as Tip } from './Tip.e61592d1.js';

/* src/components/Panel.svelte generated by Svelte v3.12.1 */

const file = "src/components/Panel.svelte";

const get_contents_slot_changes = () => ({});
const get_contents_slot_context = () => ({});

const get_tip_slot_changes = () => ({});
const get_tip_slot_context = () => ({});

const get_title_slot_changes = () => ({});
const get_title_slot_context = () => ({});

// (9:4) {#if tip}
function create_if_block(ctx) {
	var current;

	var tip_1 = new Tip({
		props: {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			tip_1.$$.fragment.c();
		},

		l: function claim(nodes) {
			tip_1.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(tip_1, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var tip_1_changes = {};
			if (changed.$$scope) tip_1_changes.$$scope = { changed, ctx };
			tip_1.$set(tip_1_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(tip_1.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(tip_1.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(tip_1, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block.name, type: "if", source: "(9:4) {#if tip}", ctx });
	return block;
}

// (10:6) <Tip>
function create_default_slot(ctx) {
	var current;

	const tip_slot_template = ctx.$$slots.tip;
	const tip_slot = create_slot(tip_slot_template, ctx, get_tip_slot_context);

	const block = {
		c: function create() {
			if (tip_slot) tip_slot.c();
		},

		l: function claim(nodes) {
			if (tip_slot) tip_slot.l(nodes);
		},

		m: function mount(target, anchor) {
			if (tip_slot) {
				tip_slot.m(target, anchor);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (tip_slot && tip_slot.p && changed.$$scope) {
				tip_slot.p(
					get_slot_changes(tip_slot_template, ctx, changed, get_tip_slot_changes),
					get_slot_context(tip_slot_template, ctx, get_tip_slot_context)
				);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(tip_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(tip_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (tip_slot) tip_slot.d(detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot.name, type: "slot", source: "(10:6) <Tip>", ctx });
	return block;
}

function create_fragment(ctx) {
	var div3, div2, div0, t0, t1, div1, div3_class_value, current, dispose;

	const title_slot_template = ctx.$$slots.title;
	const title_slot = create_slot(title_slot_template, ctx, get_title_slot_context);

	var if_block = (ctx.tip) && create_if_block(ctx);

	const contents_slot_template = ctx.$$slots.contents;
	const contents_slot = create_slot(contents_slot_template, ctx, get_contents_slot_context);

	const block = {
		c: function create() {
			div3 = element("div");
			div2 = element("div");
			div0 = element("div");

			if (title_slot) title_slot.c();
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			div1 = element("div");

			if (contents_slot) contents_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true }, false);
			var div3_nodes = children(div3);

			div2 = claim_element(div3_nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			div0 = claim_element(div2_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			if (title_slot) title_slot.l(div0_nodes);
			t0 = claim_space(div0_nodes);
			if (if_block) if_block.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div2_nodes);

			div1 = claim_element(div2_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			if (contents_slot) contents_slot.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div0, "class", "title-container font-bold md:m-4 m-2 text-lg");
			toggle_class(div0, "show", ctx.title_show || ctx.static_title);
			add_location(div0, file, 5, 2, 231);

			attr_dev(div1, "class", "overflow-hidden w-full h-full relative contents svelte-unzc0l");
			add_location(div1, file, 15, 2, 527);
			attr_dev(div2, "class", "panel md:bg-white md:border md:shadow w-full svelte-unzc0l");
			toggle_class(div2, "left", ctx.left);
			toggle_class(div2, "right", ctx.right);
			add_location(div2, file, 1, 0, 120);
			attr_dev(div3, "class", div3_class_value = "" + ctx.$$props.class + " md:p-2 mt-2 mb-2 md:mb-0 border rounded-lg border-gray-600 md:border-none md:rounded-none" + " svelte-unzc0l");
			add_location(div3, file, 0, 0, 0);

			dispose = [
				listen_dev(div0, "mouseover", ctx.onmouseover),
				listen_dev(div0, "mouseleave", ctx.onmouseleave),
				listen_dev(div1, "mouseover", ctx.onmouseover),
				listen_dev(div1, "mouseleave", ctx.onmouseleave)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div2);
			append_dev(div2, div0);

			if (title_slot) {
				title_slot.m(div0, null);
			}

			append_dev(div0, t0);
			if (if_block) if_block.m(div0, null);
			append_dev(div2, t1);
			append_dev(div2, div1);

			if (contents_slot) {
				contents_slot.m(div1, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (title_slot && title_slot.p && changed.$$scope) {
				title_slot.p(
					get_slot_changes(title_slot_template, ctx, changed, get_title_slot_changes),
					get_slot_context(title_slot_template, ctx, get_title_slot_context)
				);
			}

			if (ctx.tip) {
				if (if_block) {
					if_block.p(changed, ctx);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div0, null);
				}
			} else if (if_block) {
				group_outros();
				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});
				check_outros();
			}

			if ((changed.title_show || changed.static_title)) {
				toggle_class(div0, "show", ctx.title_show || ctx.static_title);
			}

			if (contents_slot && contents_slot.p && changed.$$scope) {
				contents_slot.p(
					get_slot_changes(contents_slot_template, ctx, changed, get_contents_slot_changes),
					get_slot_context(contents_slot_template, ctx, get_contents_slot_context)
				);
			}

			if (changed.left) {
				toggle_class(div2, "left", ctx.left);
			}

			if (changed.right) {
				toggle_class(div2, "right", ctx.right);
			}

			if ((!current || changed.$$props) && div3_class_value !== (div3_class_value = "" + ctx.$$props.class + " md:p-2 mt-2 mb-2 md:mb-0 border rounded-lg border-gray-600 md:border-none md:rounded-none" + " svelte-unzc0l")) {
				attr_dev(div3, "class", div3_class_value);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(title_slot, local);
			transition_in(if_block);
			transition_in(contents_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(title_slot, local);
			transition_out(if_block);
			transition_out(contents_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div3);
			}

			if (title_slot) title_slot.d(detaching);
			if (if_block) if_block.d();

			if (contents_slot) contents_slot.d(detaching);
			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment.name, type: "component", source: "", ctx });
	return block;
}

let timer = null;

function instance($$self, $$props, $$invalidate) {
	let { tip = false, static_title =false, left =false, right =false } = $$props;

let title_show = false;
function onmouseover(e) {
  $$invalidate('title_show', title_show = true);
  /*  console.log(title_show);
  if(timer) {
    clearTimeout(timer);
    timer = null;
  }
  timer = setTimeout(()=>{
    console.log(title_show);
    title_show = false;
  }, 1000);*/
}

function onmouseleave(e) {
  $$invalidate('title_show', title_show = false);
}

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('tip' in $$new_props) $$invalidate('tip', tip = $$new_props.tip);
		if ('static_title' in $$new_props) $$invalidate('static_title', static_title = $$new_props.static_title);
		if ('left' in $$new_props) $$invalidate('left', left = $$new_props.left);
		if ('right' in $$new_props) $$invalidate('right', right = $$new_props.right);
		if ('$$scope' in $$new_props) $$invalidate('$$scope', $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => {
		return { tip, static_title, left, right, title_show, timer };
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('tip' in $$props) $$invalidate('tip', tip = $$new_props.tip);
		if ('static_title' in $$props) $$invalidate('static_title', static_title = $$new_props.static_title);
		if ('left' in $$props) $$invalidate('left', left = $$new_props.left);
		if ('right' in $$props) $$invalidate('right', right = $$new_props.right);
		if ('title_show' in $$props) $$invalidate('title_show', title_show = $$new_props.title_show);
		if ('timer' in $$props) timer = $$new_props.timer;
	};

	return {
		tip,
		static_title,
		left,
		right,
		title_show,
		onmouseover,
		onmouseleave,
		$$props,
		$$props: $$props = exclude_internal_props($$props),
		$$slots,
		$$scope
	};
}

class Panel extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["tip", "static_title", "left", "right"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Panel", options, id: create_fragment.name });
	}

	get tip() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tip(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get static_title() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set static_title(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get left() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set left(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get right() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set right(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Panel as P };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFuZWwuYzdiYjE1MjcuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1BhbmVsLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8ZGl2IGNsYXNzPVwieyQkcHJvcHMuY2xhc3N9IG1kOnAtMiBtdC0yIG1iLTIgbWQ6bWItMCBib3JkZXIgcm91bmRlZC1sZyBib3JkZXItZ3JheS02MDAgbWQ6Ym9yZGVyLW5vbmUgbWQ6cm91bmRlZC1ub25lXCI+XG48ZGl2IGNsYXNzPVwicGFuZWwgbWQ6Ymctd2hpdGUgbWQ6Ym9yZGVyIG1kOnNoYWRvdyB3LWZ1bGxcIiBcbiAgY2xhc3M6bGVmdD1cIntsZWZ0fVwiXG4gIGNsYXNzOnJpZ2h0PVwie3JpZ2h0fVwiXG4gID5cbiAgPGRpdiBjbGFzcz1cInRpdGxlLWNvbnRhaW5lciBmb250LWJvbGQgbWQ6bS00IG0tMiB0ZXh0LWxnXCIgY2xhc3M6c2hvdz1cInt0aXRsZV9zaG93IHx8IHN0YXRpY190aXRsZX1cIiBvbjptb3VzZW92ZXI9e29ubW91c2VvdmVyfSBvbjptb3VzZWxlYXZlPXtvbm1vdXNlbGVhdmV9PlxuICAgIDxzbG90IG5hbWU9XCJ0aXRsZVwiID5cbiAgICA8L3Nsb3Q+XG4gICAgeyNpZiB0aXB9XG4gICAgICA8VGlwPlxuICAgICAgICA8c2xvdCBuYW1lPVwidGlwXCI+XG4gICAgICAgIDwvc2xvdD5cbiAgICAgIDwvVGlwPlxuICAgIHsvaWZ9XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwib3ZlcmZsb3ctaGlkZGVuIHctZnVsbCBoLWZ1bGwgcmVsYXRpdmUgY29udGVudHNcIlxuICAgICBvbjptb3VzZW92ZXI9e29ubW91c2VvdmVyfSBvbjptb3VzZWxlYXZlPXtvbm1vdXNlbGVhdmV9PlxuICAgIDxzbG90IG5hbWU9XCJjb250ZW50c1wiPlxuICAgIDwvc2xvdD5cbiAgPC9kaXY+XG48L2Rpdj5cbjwvZGl2PlxuXG48c2NyaXB0PlxuaW1wb3J0IFRpcCBmcm9tICcuL1RpcC5zdmVsdGUnO1xuXG5leHBvcnQgbGV0IHRpcCA9IGZhbHNlO1xuZXhwb3J0IGxldCBzdGF0aWNfdGl0bGUgPWZhbHNlO1xuZXhwb3J0IGxldCBsZWZ0ID1mYWxzZTtcbmV4cG9ydCBsZXQgcmlnaHQgPWZhbHNlO1xuXG5sZXQgdGl0bGVfc2hvdyA9IGZhbHNlO1xubGV0IHRpbWVyID0gbnVsbDtcbmZ1bmN0aW9uIG9ubW91c2VvdmVyKGUpIHtcbiAgdGl0bGVfc2hvdyA9IHRydWU7XG4gIC8qICBjb25zb2xlLmxvZyh0aXRsZV9zaG93KTtcbiAgaWYodGltZXIpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHRpbWVyID0gbnVsbDtcbiAgfVxuICB0aW1lciA9IHNldFRpbWVvdXQoKCk9PntcbiAgICBjb25zb2xlLmxvZyh0aXRsZV9zaG93KTtcbiAgICB0aXRsZV9zaG93ID0gZmFsc2U7XG4gIH0sIDEwMDApOyovXG59XG5cbmZ1bmN0aW9uIG9ubW91c2VsZWF2ZShlKSB7XG4gIHRpdGxlX3Nob3cgPSBmYWxzZTtcbn1cbjwvc2NyaXB0PlxuXG5cbjxzdHlsZT5cbi8qLnRpdGxlLWNvbnRhaW5lciB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgcGFkZGluZzogMC41cmVtO1xufSovXG4vKi50aXRsZS1jb250YWluZXIuc2hvdyB7XG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIC0xMDAlKTtcbiAgei1pbmRleDogMztcbn0qL1xuLyoucGFuZWwge1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgaGVpZ2h0OiBmaXQtY29udGVudDtcbn0qL1xuXG5cbkBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkgeyBcbiAgLnBhbmVsIHtcbiAgfVxuICAuY29udGVudHMge1xuICB9XG59XG5cbi5jb250ZW50cyB7XG4gIHotaW5kZXg6IDI7XG4gIGJvcmRlci1yYWRpdXM6IDJweDtcbn1cbi5sZWZ0IHtcbiAgbWFyZ2luLWxlZnQ6IDA7XG59XG4ucmlnaHQge1xuICBtYXJnaW4tcmlnaHQ6IDA7XG59XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQkFRUyxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQUg2RCxVQUFVLFFBQUksWUFBWTs7Ozs7O2tDQUhwRixJQUFJO21DQUNILEtBQUs7O3VEQUhSLE9BQU8sQ0FBQyxLQUFLOzs7O3NDQUswRixXQUFXO3VDQUFpQixZQUFZO3NDQVd6SSxXQUFXO3VDQUFpQixZQUFZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7V0FSbEQsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQ0FINkQsVUFBVSxRQUFJLFlBQVk7Ozs7Ozs7Ozs7O21DQUhwRixJQUFJOzs7O29DQUNILEtBQUs7OzswRkFIUixPQUFPLENBQUMsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0MxQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUM7OztDQU5WLE1BQUksR0FBRyxHQUFHLEtBQUssRUFDWCxZQUFZLEVBQUUsS0FBSyxFQUNuQixJQUFJLEVBQUUsS0FBSyxFQUNYLEtBQUssRUFBRSxpQkFBSyxDQUFDOztBQUV4QixJQUFJLFVBQVUsR0FBRyxLQUFLLENBQUM7QUFFdkIsU0FBUyxXQUFXLENBQUMsQ0FBQyxFQUFFOzZCQUN0QixVQUFVLEdBQUcsS0FBSSxDQUFDOzs7Ozs7Ozs7O0NBVW5COztBQUVELFNBQVMsWUFBWSxDQUFDLENBQUMsRUFBRTs2QkFDdkIsVUFBVSxHQUFHLE1BQUssQ0FBQztDQUNwQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyJ9
