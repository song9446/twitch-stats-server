import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, I as assign, N as exclude_internal_props, e as element, c as claim_element, f as children, j as detach_dev, l as attr_dev, o as add_location, p as insert_dev, v as mount_component, w as transition_in, x as transition_out, y as destroy_component, n as noop, H as empty, a as space, k as claim_space, q as append_dev, z as group_outros, A as check_outros, B as destroy_each, t as text, h as claim_text, b as svg_element, O as set_style, G as set_data_dev } from './index.1eb00da2.js';
import { c as createCommonjsModule, u as unwrapExports } from './api.8ae65b01.js';
import { T as Tip } from './Tip.e61592d1.js';
import { d as dark_random_color } from './faHistory.56473669.js';

var faRobot = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fas';
var iconName = 'robot';
var width = 640;
var height = 512;
var ligatures = [];
var unicode = 'f544';
var svgPathData = 'M32,224H64V416H32A31.96166,31.96166,0,0,1,0,384V256A31.96166,31.96166,0,0,1,32,224Zm512-48V448a64.06328,64.06328,0,0,1-64,64H160a64.06328,64.06328,0,0,1-64-64V176a79.974,79.974,0,0,1,80-80H288V32a32,32,0,0,1,64,0V96H464A79.974,79.974,0,0,1,544,176ZM264,256a40,40,0,1,0-40,40A39.997,39.997,0,0,0,264,256Zm-8,128H192v32h64Zm96,0H288v32h64ZM456,256a40,40,0,1,0-40,40A39.997,39.997,0,0,0,456,256Zm-8,128H384v32h64ZM640,256V384a31.96166,31.96166,0,0,1-32,32H576V224h32A31.96166,31.96166,0,0,1,640,256Z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faRobot = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;
});

unwrapExports(faRobot);
var faRobot_1 = faRobot.definition;
var faRobot_2 = faRobot.faRobot;
var faRobot_3 = faRobot.prefix;
var faRobot_4 = faRobot.iconName;
var faRobot_5 = faRobot.width;
var faRobot_6 = faRobot.height;
var faRobot_7 = faRobot.ligatures;
var faRobot_8 = faRobot.unicode;
var faRobot_9 = faRobot.svgPathData;

var faBuilding = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fas';
var iconName = 'building';
var width = 448;
var height = 512;
var ligatures = [];
var unicode = 'f1ad';
var svgPathData = 'M436 480h-20V24c0-13.255-10.745-24-24-24H56C42.745 0 32 10.745 32 24v456H12c-6.627 0-12 5.373-12 12v20h448v-20c0-6.627-5.373-12-12-12zM128 76c0-6.627 5.373-12 12-12h40c6.627 0 12 5.373 12 12v40c0 6.627-5.373 12-12 12h-40c-6.627 0-12-5.373-12-12V76zm0 96c0-6.627 5.373-12 12-12h40c6.627 0 12 5.373 12 12v40c0 6.627-5.373 12-12 12h-40c-6.627 0-12-5.373-12-12v-40zm52 148h-40c-6.627 0-12-5.373-12-12v-40c0-6.627 5.373-12 12-12h40c6.627 0 12 5.373 12 12v40c0 6.627-5.373 12-12 12zm76 160h-64v-84c0-6.627 5.373-12 12-12h40c6.627 0 12 5.373 12 12v84zm64-172c0 6.627-5.373 12-12 12h-40c-6.627 0-12-5.373-12-12v-40c0-6.627 5.373-12 12-12h40c6.627 0 12 5.373 12 12v40zm0-96c0 6.627-5.373 12-12 12h-40c-6.627 0-12-5.373-12-12v-40c0-6.627 5.373-12 12-12h40c6.627 0 12 5.373 12 12v40zm0-96c0 6.627-5.373 12-12 12h-40c-6.627 0-12-5.373-12-12V76c0-6.627 5.373-12 12-12h40c6.627 0 12 5.373 12 12v40z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faBuilding = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;
});

unwrapExports(faBuilding);
var faBuilding_1 = faBuilding.definition;
var faBuilding_2 = faBuilding.faBuilding;
var faBuilding_3 = faBuilding.prefix;
var faBuilding_4 = faBuilding.iconName;
var faBuilding_5 = faBuilding.width;
var faBuilding_6 = faBuilding.height;
var faBuilding_7 = faBuilding.ligatures;
var faBuilding_8 = faBuilding.unicode;
var faBuilding_9 = faBuilding.svgPathData;

var faHome = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fas';
var iconName = 'home';
var width = 576;
var height = 512;
var ligatures = [];
var unicode = 'f015';
var svgPathData = 'M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faHome = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;
});

unwrapExports(faHome);
var faHome_1 = faHome.definition;
var faHome_2 = faHome.faHome;
var faHome_3 = faHome.prefix;
var faHome_4 = faHome.iconName;
var faHome_5 = faHome.width;
var faHome_6 = faHome.height;
var faHome_7 = faHome.ligatures;
var faHome_8 = faHome.unicode;
var faHome_9 = faHome.svgPathData;

var faCity = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fas';
var iconName = 'city';
var width = 640;
var height = 512;
var ligatures = [];
var unicode = 'f64f';
var svgPathData = 'M616 192H480V24c0-13.26-10.74-24-24-24H312c-13.26 0-24 10.74-24 24v72h-64V16c0-8.84-7.16-16-16-16h-16c-8.84 0-16 7.16-16 16v80h-64V16c0-8.84-7.16-16-16-16H80c-8.84 0-16 7.16-16 16v80H24c-13.26 0-24 10.74-24 24v360c0 17.67 14.33 32 32 32h576c17.67 0 32-14.33 32-32V216c0-13.26-10.75-24-24-24zM128 404c0 6.63-5.37 12-12 12H76c-6.63 0-12-5.37-12-12v-40c0-6.63 5.37-12 12-12h40c6.63 0 12 5.37 12 12v40zm0-96c0 6.63-5.37 12-12 12H76c-6.63 0-12-5.37-12-12v-40c0-6.63 5.37-12 12-12h40c6.63 0 12 5.37 12 12v40zm0-96c0 6.63-5.37 12-12 12H76c-6.63 0-12-5.37-12-12v-40c0-6.63 5.37-12 12-12h40c6.63 0 12 5.37 12 12v40zm128 192c0 6.63-5.37 12-12 12h-40c-6.63 0-12-5.37-12-12v-40c0-6.63 5.37-12 12-12h40c6.63 0 12 5.37 12 12v40zm0-96c0 6.63-5.37 12-12 12h-40c-6.63 0-12-5.37-12-12v-40c0-6.63 5.37-12 12-12h40c6.63 0 12 5.37 12 12v40zm0-96c0 6.63-5.37 12-12 12h-40c-6.63 0-12-5.37-12-12v-40c0-6.63 5.37-12 12-12h40c6.63 0 12 5.37 12 12v40zm160 96c0 6.63-5.37 12-12 12h-40c-6.63 0-12-5.37-12-12v-40c0-6.63 5.37-12 12-12h40c6.63 0 12 5.37 12 12v40zm0-96c0 6.63-5.37 12-12 12h-40c-6.63 0-12-5.37-12-12v-40c0-6.63 5.37-12 12-12h40c6.63 0 12 5.37 12 12v40zm0-96c0 6.63-5.37 12-12 12h-40c-6.63 0-12-5.37-12-12V76c0-6.63 5.37-12 12-12h40c6.63 0 12 5.37 12 12v40zm160 288c0 6.63-5.37 12-12 12h-40c-6.63 0-12-5.37-12-12v-40c0-6.63 5.37-12 12-12h40c6.63 0 12 5.37 12 12v40zm0-96c0 6.63-5.37 12-12 12h-40c-6.63 0-12-5.37-12-12v-40c0-6.63 5.37-12 12-12h40c6.63 0 12 5.37 12 12v40z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faCity = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;
});

unwrapExports(faCity);
var faCity_1 = faCity.definition;
var faCity_2 = faCity.faCity;
var faCity_3 = faCity.prefix;
var faCity_4 = faCity.iconName;
var faCity_5 = faCity.width;
var faCity_6 = faCity.height;
var faCity_7 = faCity.ligatures;
var faCity_8 = faCity.unicode;
var faCity_9 = faCity.svgPathData;

/* src/components/Badges.svelte generated by Svelte v3.12.1 */

const file = "src/components/Badges.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.badge = list[i];
	return child_ctx;
}

// (2:2) {#if streamer.broadcaster_type == "partner"}
function create_if_block_8(ctx) {
	var li, current;

	var tip = new Tip({
		props: {
		position: "bottom",
		$$slots: {
		default: [create_default_slot_7],
		tip: [create_tip_slot_7],
		contents: [create_contents_slot_7]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			li = element("li");
			tip.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			tip.$$.fragment.l(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(li, "class", "py-px mb-1 mr-1 inline-block svelte-oix4tn");
			add_location(li, file, 2, 4, 101);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(tip, li, null);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(tip.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(tip.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			destroy_component(tip);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_8.name, type: "if", source: "(2:2) {#if streamer.broadcaster_type == \"partner\"}", ctx });
	return block;
}

// (5:8) <div slot="contents">
function create_contents_slot_7(ctx) {
	var div, img;

	const block = {
		c: function create() {
			div = element("div");
			img = element("img");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true }, false);
			var div_nodes = children(div);

			img = claim_element(div_nodes, "IMG", { src: true, alt: true, class: true }, false);
			var img_nodes = children(img);

			img_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(img, "src", "/twitch_glitch.png");
			attr_dev(img, "alt", "partner");
			attr_dev(img, "class", "w-3 h-3 inline");
			add_location(img, file, 5, 10, 213);
			attr_dev(div, "slot", "contents");
			add_location(div, file, 4, 8, 181);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_contents_slot_7.name, type: "slot", source: "(5:8) <div slot=\"contents\">", ctx });
	return block;
}

// (8:8) <span slot="tip">
function create_tip_slot_7(ctx) {
	var span, t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("트위치 파트너 스트리머");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { slot: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, "트위치 파트너 스트리머");
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "slot", "tip");
			add_location(span, file, 7, 8, 305);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_tip_slot_7.name, type: "slot", source: "(8:8) <span slot=\"tip\">", ctx });
	return block;
}

// (4:6) <Tip position="bottom">
function create_default_slot_7(ctx) {
	var t;

	const block = {
		c: function create() {
			t = space();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_7.name, type: "slot", source: "(4:6) <Tip position=\"bottom\">", ctx });
	return block;
}

// (14:2) {#if streamer.broadcaster_type == "affiliate"}
function create_if_block_7(ctx) {
	var li, current;

	var tip = new Tip({
		props: {
		position: "bottom",
		$$slots: {
		default: [create_default_slot_6],
		tip: [create_tip_slot_6],
		contents: [create_contents_slot_6]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			li = element("li");
			tip.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			tip.$$.fragment.l(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(li, "class", "py-px mb-1 mr-1 inline-block svelte-oix4tn");
			add_location(li, file, 14, 4, 446);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(tip, li, null);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(tip.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(tip.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			destroy_component(tip);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_7.name, type: "if", source: "(14:2) {#if streamer.broadcaster_type == \"affiliate\"}", ctx });
	return block;
}

// (17:8) <div slot="contents">
function create_contents_slot_6(ctx) {
	var div, img;

	const block = {
		c: function create() {
			div = element("div");
			img = element("img");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true }, false);
			var div_nodes = children(div);

			img = claim_element(div_nodes, "IMG", { src: true, alt: true, class: true }, false);
			var img_nodes = children(img);

			img_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(img, "src", "/verified_icon.png");
			attr_dev(img, "alt", "affiliate");
			attr_dev(img, "class", "w-3 h-3 inline");
			add_location(img, file, 17, 10, 558);
			attr_dev(div, "slot", "contents");
			add_location(div, file, 16, 8, 526);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_contents_slot_6.name, type: "slot", source: "(17:8) <div slot=\"contents\">", ctx });
	return block;
}

// (20:8) <span slot="tip">
function create_tip_slot_6(ctx) {
	var span, t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("트위치 제휴 스트리머");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { slot: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, "트위치 제휴 스트리머");
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "slot", "tip");
			add_location(span, file, 19, 8, 652);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_tip_slot_6.name, type: "slot", source: "(20:8) <span slot=\"tip\">", ctx });
	return block;
}

// (16:6) <Tip position="bottom">
function create_default_slot_6(ctx) {
	var t;

	const block = {
		c: function create() {
			t = space();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_6.name, type: "slot", source: "(16:6) <Tip position=\"bottom\">", ctx });
	return block;
}

// (26:2) {#if 0}
function create_if_block_2(ctx) {
	var t, current_block_type_index, if_block1, if_block1_anchor, current;

	var if_block0 = (ctx.streamer.streaming_hours_per_week >= 56) && create_if_block_6(ctx);

	var if_block_creators = [
		create_if_block_3,
		create_if_block_4,
		create_if_block_5
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.streamer.average_viewer_count >= 10000) return 0;
		if (ctx.streamer.average_viewer_count >= 1000) return 1;
		if (ctx.streamer.average_viewer_count >= 100) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(null, ctx))) {
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},

		l: function claim(nodes) {
			if (if_block0) if_block0.l(nodes);
			t = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
		},

		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t, anchor);
			if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if (ctx.streamer.streaming_hours_per_week >= 56) {
				if (if_block0) {
					if_block0.p(changed, ctx);
					transition_in(if_block0, 1);
				} else {
					if_block0 = create_if_block_6(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();
				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});
				check_outros();
			}

			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				if (if_block1) {
					group_outros();
					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});
					check_outros();
				}

				if (~current_block_type_index) {
					if_block1 = if_blocks[current_block_type_index];
					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					}
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				} else {
					if_block1 = null;
				}
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},

		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);

			if (detaching) {
				detach_dev(t);
			}

			if (~current_block_type_index) if_blocks[current_block_type_index].d(detaching);

			if (detaching) {
				detach_dev(if_block1_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_2.name, type: "if", source: "(26:2) {#if 0}", ctx });
	return block;
}

// (27:2) {#if streamer.streaming_hours_per_week >= 56}
function create_if_block_6(ctx) {
	var li, current;

	var tip = new Tip({
		props: {
		position: "bottom",
		$$slots: {
		default: [create_default_slot_5],
		tip: [create_tip_slot_5],
		contents: [create_contents_slot_5]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			li = element("li");
			tip.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			tip.$$.fragment.l(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(li, "class", "py-px mb-1 mr-1 inline-block svelte-oix4tn");
			add_location(li, file, 27, 4, 801);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(tip, li, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var tip_changes = {};
			if (changed.$$scope) tip_changes.$$scope = { changed, ctx };
			tip.$set(tip_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(tip.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(tip.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			destroy_component(tip);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_6.name, type: "if", source: "(27:2) {#if streamer.streaming_hours_per_week >= 56}", ctx });
	return block;
}

// (30:8) <div slot="contents">
function create_contents_slot_5(ctx) {
	var div, svg, path;

	const block = {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");
			path = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true }, false);
			var div_nodes = children(div);

			svg = claim_element(div_nodes, "svg", { "area-hidden": true, role: true, xmlns: true, viewBox: true, class: true }, true);
			var svg_nodes = children(svg);

			path = claim_element(svg_nodes, "path", { fill: true, d: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(path, "fill", "currentColor");
			attr_dev(path, "d", faRobot_2.icon[4]);
			add_location(path, file, 31, 12, 1092);
			attr_dev(svg, "area-hidden", "true");
			attr_dev(svg, "role", "img");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "viewBox", "0 0 " + faRobot_2.icon[0] + " " + faRobot_2.icon[1]);
			attr_dev(svg, "class", "w-4 h-4 overflow-visible inline-block");
			add_location(svg, file, 30, 10, 913);
			attr_dev(div, "slot", "contents");
			add_location(div, file, 29, 8, 881);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, svg);
			append_dev(svg, path);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_contents_slot_5.name, type: "slot", source: "(30:8) <div slot=\"contents\">", ctx });
	return block;
}

// (35:8) <span slot="tip">
function create_tip_slot_5(ctx) {
	var span, t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("로봇 - 이 스트리머는 한 주에 56시간 이상 방송합니다.");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { slot: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, "로봇 - 이 스트리머는 한 주에 56시간 이상 방송합니다.");
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "slot", "tip");
			add_location(span, file, 34, 8, 1182);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_tip_slot_5.name, type: "slot", source: "(35:8) <span slot=\"tip\">", ctx });
	return block;
}

// (29:6) <Tip position="bottom">
function create_default_slot_5(ctx) {
	var t;

	const block = {
		c: function create() {
			t = space();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_5.name, type: "slot", source: "(29:6) <Tip position=\"bottom\">", ctx });
	return block;
}

// (67:49) 
function create_if_block_5(ctx) {
	var li, current;

	var tip = new Tip({
		props: {
		position: "bottom",
		$$slots: {
		default: [create_default_slot_4],
		tip: [create_tip_slot_4],
		contents: [create_contents_slot_4]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			li = element("li");
			tip.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			tip.$$.fragment.l(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(li, "class", "py-px mb-1 mr-1 inline-block svelte-oix4tn");
			add_location(li, file, 67, 4, 2418);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(tip, li, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var tip_changes = {};
			if (changed.$$scope) tip_changes.$$scope = { changed, ctx };
			tip.$set(tip_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(tip.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(tip.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			destroy_component(tip);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_5.name, type: "if", source: "(67:49) ", ctx });
	return block;
}

// (54:50) 
function create_if_block_4(ctx) {
	var li, current;

	var tip = new Tip({
		props: {
		position: "bottom",
		$$slots: {
		default: [create_default_slot_3],
		tip: [create_tip_slot_3],
		contents: [create_contents_slot_3]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			li = element("li");
			tip.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			tip.$$.fragment.l(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(li, "class", "py-px mb-1 mr-1 inline-block svelte-oix4tn");
			add_location(li, file, 54, 4, 1874);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(tip, li, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var tip_changes = {};
			if (changed.$$scope) tip_changes.$$scope = { changed, ctx };
			tip.$set(tip_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(tip.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(tip.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			destroy_component(tip);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_4.name, type: "if", source: "(54:50) ", ctx });
	return block;
}

// (41:2) {#if streamer.average_viewer_count >= 10000}
function create_if_block_3(ctx) {
	var li, current;

	var tip = new Tip({
		props: {
		position: "bottom",
		$$slots: {
		default: [create_default_slot_2],
		tip: [create_tip_slot_2],
		contents: [create_contents_slot_2]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			li = element("li");
			tip.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			tip.$$.fragment.l(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(li, "class", "py-px mb-1 mr-1 inline-block svelte-oix4tn");
			add_location(li, file, 41, 4, 1341);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(tip, li, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var tip_changes = {};
			if (changed.$$scope) tip_changes.$$scope = { changed, ctx };
			tip.$set(tip_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(tip.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(tip.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			destroy_component(tip);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_3.name, type: "if", source: "(41:2) {#if streamer.average_viewer_count >= 10000}", ctx });
	return block;
}

// (70:8) <div slot="contents">
function create_contents_slot_4(ctx) {
	var div, svg, path;

	const block = {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");
			path = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true }, false);
			var div_nodes = children(div);

			svg = claim_element(div_nodes, "svg", { "area-hidden": true, role: true, xmlns: true, viewBox: true, class: true }, true);
			var svg_nodes = children(svg);

			path = claim_element(svg_nodes, "path", { fill: true, d: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(path, "fill", "currentColor");
			attr_dev(path, "d", faHome_2.icon[4]);
			add_location(path, file, 71, 12, 2707);
			attr_dev(svg, "area-hidden", "true");
			attr_dev(svg, "role", "img");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "viewBox", "0 0 " + faHome_2.icon[0] + " " + faHome_2.icon[1]);
			attr_dev(svg, "class", "w-4 h-4 overflow-visible inline-block");
			add_location(svg, file, 70, 10, 2530);
			attr_dev(div, "slot", "contents");
			add_location(div, file, 69, 8, 2498);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, svg);
			append_dev(svg, path);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_contents_slot_4.name, type: "slot", source: "(70:8) <div slot=\"contents\">", ctx });
	return block;
}

// (75:8) <span slot="tip">
function create_tip_slot_4(ctx) {
	var span, t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("주택 - 이 스트리머의 방송을 평균 백명 이상 시청합니다.");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { slot: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, "주택 - 이 스트리머의 방송을 평균 백명 이상 시청합니다.");
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "slot", "tip");
			add_location(span, file, 74, 8, 2796);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_tip_slot_4.name, type: "slot", source: "(75:8) <span slot=\"tip\">", ctx });
	return block;
}

// (69:6) <Tip position="bottom">
function create_default_slot_4(ctx) {
	var t;

	const block = {
		c: function create() {
			t = space();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_4.name, type: "slot", source: "(69:6) <Tip position=\"bottom\">", ctx });
	return block;
}

// (57:8) <div slot="contents">
function create_contents_slot_3(ctx) {
	var div, svg, path;

	const block = {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");
			path = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true }, false);
			var div_nodes = children(div);

			svg = claim_element(div_nodes, "svg", { "area-hidden": true, role: true, xmlns: true, viewBox: true, class: true }, true);
			var svg_nodes = children(svg);

			path = claim_element(svg_nodes, "path", { fill: true, d: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(path, "fill", "currentColor");
			attr_dev(path, "d", faBuilding_2.icon[4]);
			add_location(path, file, 58, 12, 2171);
			attr_dev(svg, "area-hidden", "true");
			attr_dev(svg, "role", "img");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "viewBox", "0 0 " + faBuilding_2.icon[0] + " " + faBuilding_2.icon[1]);
			attr_dev(svg, "class", "w-4 h-4 overflow-visible inline-block");
			add_location(svg, file, 57, 10, 1986);
			attr_dev(div, "slot", "contents");
			add_location(div, file, 56, 8, 1954);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, svg);
			append_dev(svg, path);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_contents_slot_3.name, type: "slot", source: "(57:8) <div slot=\"contents\">", ctx });
	return block;
}

// (62:8) <span slot="tip">
function create_tip_slot_3(ctx) {
	var span, t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("빌딩 - 이 스트리머의 방송을 평균 천명 이상 시청합니다.");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { slot: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, "빌딩 - 이 스트리머의 방송을 평균 천명 이상 시청합니다.");
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "slot", "tip");
			add_location(span, file, 61, 8, 2264);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_tip_slot_3.name, type: "slot", source: "(62:8) <span slot=\"tip\">", ctx });
	return block;
}

// (56:6) <Tip position="bottom">
function create_default_slot_3(ctx) {
	var t;

	const block = {
		c: function create() {
			t = space();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_3.name, type: "slot", source: "(56:6) <Tip position=\"bottom\">", ctx });
	return block;
}

// (44:8) <div slot="contents">
function create_contents_slot_2(ctx) {
	var div, svg, path;

	const block = {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");
			path = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true }, false);
			var div_nodes = children(div);

			svg = claim_element(div_nodes, "svg", { "area-hidden": true, role: true, xmlns: true, viewBox: true, class: true }, true);
			var svg_nodes = children(svg);

			path = claim_element(svg_nodes, "path", { fill: true, d: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(path, "fill", "currentColor");
			attr_dev(path, "d", faCity_2.icon[4]);
			add_location(path, file, 45, 12, 1630);
			attr_dev(svg, "area-hidden", "true");
			attr_dev(svg, "role", "img");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "viewBox", "0 0 " + faCity_2.icon[0] + " " + faCity_2.icon[1]);
			attr_dev(svg, "class", "w-4 h-4 overflow-visible inline-block");
			add_location(svg, file, 44, 10, 1453);
			attr_dev(div, "slot", "contents");
			add_location(div, file, 43, 8, 1421);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, svg);
			append_dev(svg, path);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_contents_slot_2.name, type: "slot", source: "(44:8) <div slot=\"contents\">", ctx });
	return block;
}

// (49:8) <span slot="tip">
function create_tip_slot_2(ctx) {
	var span, t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("도시 - 이 스트리머의 방송을 평균 만명 이상 시청합니다.");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { slot: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, "도시 - 이 스트리머의 방송을 평균 만명 이상 시청합니다.");
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "slot", "tip");
			add_location(span, file, 48, 8, 1719);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_tip_slot_2.name, type: "slot", source: "(49:8) <span slot=\"tip\">", ctx });
	return block;
}

// (43:6) <Tip position="bottom">
function create_default_slot_2(ctx) {
	var t;

	const block = {
		c: function create() {
			t = space();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_2.name, type: "slot", source: "(43:6) <Tip position=\"bottom\">", ctx });
	return block;
}

// (82:2) {#if streamer.is_streaming}
function create_if_block_1(ctx) {
	const block = {
		c: noop,
		l: noop,
		m: noop,
		d: noop
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1.name, type: "if", source: "(82:2) {#if streamer.is_streaming}", ctx });
	return block;
}

// (97:4) {:else}
function create_else_block(ctx) {
	var li, t, current;

	var tip = new Tip({
		props: {
		position: "bottom",
		$$slots: {
		default: [create_default_slot_1],
		tip: [create_tip_slot_1],
		contents: [create_contents_slot_1]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			li = element("li");
			tip.$$.fragment.c();
			t = space();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			tip.$$.fragment.l(li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(li, "class", "mb-1 mr-1 inline-block svelte-oix4tn");
			add_location(li, file, 97, 6, 3479);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(tip, li, null);
			append_dev(li, t);
			current = true;
		},

		p: function update(changed, ctx) {
			var tip_changes = {};
			if (changed.$$scope) tip_changes.$$scope = { changed, ctx };
			tip.$set(tip_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(tip.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(tip.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			destroy_component(tip);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block.name, type: "else", source: "(97:4) {:else}", ctx });
	return block;
}

// (86:4) {#if !badge[2]}
function create_if_block(ctx) {
	var li, t, current;

	var tip = new Tip({
		props: {
		position: "bottom",
		$$slots: {
		default: [create_default_slot],
		tip: [create_tip_slot],
		contents: [create_contents_slot]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			li = element("li");
			tip.$$.fragment.c();
			t = space();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			tip.$$.fragment.l(li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(li, "class", "mb-1 mr-1 inline-block svelte-oix4tn");
			add_location(li, file, 86, 6, 3128);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(tip, li, null);
			append_dev(li, t);
			current = true;
		},

		p: function update(changed, ctx) {
			var tip_changes = {};
			if (changed.$$scope) tip_changes.$$scope = { changed, ctx };
			tip.$set(tip_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(tip.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(tip.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			destroy_component(tip);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block.name, type: "if", source: "(86:4) {#if !badge[2]}", ctx });
	return block;
}

// (100:10) <div slot="contents" class="px-1 py-px font-bold rounded-lg" style="color: white; background-color: {badge[1]}; border: 2px solid {badge[1]};">
function create_contents_slot_1(ctx) {
	var div, t_value = ctx.badge[0] + "", t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true, class: true, style: true }, false);
			var div_nodes = children(div);

			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "slot", "contents");
			attr_dev(div, "class", "px-1 py-px font-bold rounded-lg");
			set_style(div, "color", "white");
			set_style(div, "background-color", ctx.badge[1]);
			set_style(div, "border", "2px solid " + ctx.badge[1]);
			add_location(div, file, 99, 10, 3557);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_contents_slot_1.name, type: "slot", source: "(100:10) <div slot=\"contents\" class=\"px-1 py-px font-bold rounded-lg\" style=\"color: white; background-color: {badge[1]}; border: 2px solid {badge[1]};\">", ctx });
	return block;
}

// (103:10) <span slot="tip">
function create_tip_slot_1(ctx) {
	var span, t_value = ctx.badge[3] + "", t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { slot: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "slot", "tip");
			add_location(span, file, 102, 10, 3751);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_tip_slot_1.name, type: "slot", source: "(103:10) <span slot=\"tip\">", ctx });
	return block;
}

// (99:8) <Tip position="bottom">
function create_default_slot_1(ctx) {
	var t;

	const block = {
		c: function create() {
			t = space();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_1.name, type: "slot", source: "(99:8) <Tip position=\"bottom\">", ctx });
	return block;
}

// (89:10) <div slot="contents" class="px-1 py-px font-bold rounded-lg" style="color: {badge[1]}; border: 2px solid {badge[1]};">
function create_contents_slot(ctx) {
	var div, t_value = ctx.badge[0] + "", t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true, class: true, style: true }, false);
			var div_nodes = children(div);

			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "slot", "contents");
			attr_dev(div, "class", "px-1 py-px font-bold rounded-lg");
			set_style(div, "color", ctx.badge[1]);
			set_style(div, "border", "2px solid " + ctx.badge[1]);
			add_location(div, file, 88, 10, 3206);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_contents_slot.name, type: "slot", source: "(89:10) <div slot=\"contents\" class=\"px-1 py-px font-bold rounded-lg\" style=\"color: {badge[1]}; border: 2px solid {badge[1]};\">", ctx });
	return block;
}

// (92:10) <span slot="tip">
function create_tip_slot(ctx) {
	var span, t_value = ctx.badge[3] + "", t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { slot: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "slot", "tip");
			add_location(span, file, 91, 10, 3375);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_tip_slot.name, type: "slot", source: "(92:10) <span slot=\"tip\">", ctx });
	return block;
}

// (88:8) <Tip position="bottom">
function create_default_slot(ctx) {
	var t;

	const block = {
		c: function create() {
			t = space();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot.name, type: "slot", source: "(88:8) <Tip position=\"bottom\">", ctx });
	return block;
}

// (85:2) {#each badges as badge}
function create_each_block(ctx) {
	var current_block_type_index, if_block, if_block_anchor, current;

	var if_block_creators = [
		create_if_block,
		create_else_block
	];

	var if_blocks = [];

	function select_block_type_1(changed, ctx) {
		if (!ctx.badge[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if_block.p(changed, ctx);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block.name, type: "each", source: "(85:2) {#each badges as badge}", ctx });
	return block;
}

function create_fragment(ctx) {
	var ul, t0, t1, t2, t3, ul_class_value, current;

	var if_block0 = (ctx.streamer.broadcaster_type == "partner") && create_if_block_8(ctx);

	var if_block1 = (ctx.streamer.broadcaster_type == "affiliate") && create_if_block_7(ctx);

	var if_block2 = (0) && create_if_block_2(ctx);

	var if_block3 = (ctx.streamer.is_streaming) && create_if_block_1(ctx);

	let each_value = ctx.badges;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			ul = element("ul");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
			this.h();
		},

		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true }, false);
			var ul_nodes = children(ul);

			if (if_block0) if_block0.l(ul_nodes);
			t0 = claim_space(ul_nodes);
			if (if_block1) if_block1.l(ul_nodes);
			t1 = claim_space(ul_nodes);
			t2 = claim_space(ul_nodes);
			if (if_block3) if_block3.l(ul_nodes);
			t3 = claim_space(ul_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(ul, "class", ul_class_value = "" + ctx.$$props.class + " font-bold rounded-lg");
			add_location(ul, file, 0, 0, 0);
		},

		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);
			if (if_block0) if_block0.m(ul, null);
			append_dev(ul, t0);
			if (if_block1) if_block1.m(ul, null);
			append_dev(ul, t1);
			append_dev(ul, t2);
			if (if_block3) if_block3.m(ul, null);
			append_dev(ul, t3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (ctx.streamer.broadcaster_type == "partner") {
				if (!if_block0) {
					if_block0 = create_if_block_8(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(ul, t0);
				} else transition_in(if_block0, 1);
			} else if (if_block0) {
				group_outros();
				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});
				check_outros();
			}

			if (ctx.streamer.broadcaster_type == "affiliate") {
				if (!if_block1) {
					if_block1 = create_if_block_7(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(ul, t1);
				} else transition_in(if_block1, 1);
			} else if (if_block1) {
				group_outros();
				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});
				check_outros();
			}

			if (ctx.streamer.is_streaming) {
				if (!if_block3) {
					if_block3 = create_if_block_1(ctx);
					if_block3.c();
					if_block3.m(ul, t3);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (changed.badges) {
				each_value = ctx.badges;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();
				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}
				check_outros();
			}

			if ((!current || changed.$$props) && ul_class_value !== (ul_class_value = "" + ctx.$$props.class + " font-bold rounded-lg")) {
				attr_dev(ul, "class", ul_class_value);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},

		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);

			each_blocks = each_blocks.filter(Boolean);
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(ul);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block3) if_block3.d();

			destroy_each(each_blocks, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment.name, type: "component", source: "", ctx });
	return block;
}

function instance($$self, $$props, $$invalidate) {
	
  let { streamer } = $$props; 
  let last_streamer = null;
  let badges = [];

	$$self.$set = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('streamer' in $$new_props) $$invalidate('streamer', streamer = $$new_props.streamer);
	};

	$$self.$capture_state = () => {
		return { streamer, last_streamer, badges };
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('streamer' in $$props) $$invalidate('streamer', streamer = $$new_props.streamer);
		if ('last_streamer' in $$props) $$invalidate('last_streamer', last_streamer = $$new_props.last_streamer);
		if ('badges' in $$props) $$invalidate('badges', badges = $$new_props.badges);
	};

	$$self.$$.update = ($$dirty = { streamer: 1, last_streamer: 1 }) => {
		if ($$dirty.streamer || $$dirty.last_streamer) { if(streamer != last_streamer){
        $$invalidate('last_streamer', last_streamer = streamer);
      } }
	};

	return {
		streamer,
		badges,
		$$props,
		$$props: $$props = exclude_internal_props($$props)
	};
}

class Badges extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["streamer"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Badges", options, id: create_fragment.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.streamer === undefined && !('streamer' in props)) {
			console.warn("<Badges> was created without expected prop 'streamer'");
		}
	}

	get streamer() {
		throw new Error("<Badges>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set streamer(value) {
		throw new Error("<Badges>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/GameBadges.svelte generated by Svelte v3.12.1 */

const file$1 = "src/components/GameBadges.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.badge = list[i];
	return child_ctx;
}

// (15:4) {:else}
function create_else_block$1(ctx) {
	var li, t, current;

	var tip = new Tip({
		props: {
		position: "bottom",
		$$slots: {
		default: [create_default_slot_1$1],
		tip: [create_tip_slot_1$1],
		contents: [create_contents_slot_1$1]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			li = element("li");
			tip.$$.fragment.c();
			t = space();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			tip.$$.fragment.l(li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(li, "class", "mb-1 mr-1 svelte-1d1rkia");
			add_location(li, file$1, 15, 6, 566);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(tip, li, null);
			append_dev(li, t);
			current = true;
		},

		p: function update(changed, ctx) {
			var tip_changes = {};
			if (changed.$$scope || changed.badges) tip_changes.$$scope = { changed, ctx };
			tip.$set(tip_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(tip.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(tip.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			destroy_component(tip);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block$1.name, type: "else", source: "(15:4) {:else}", ctx });
	return block;
}

// (3:4) {#if !badge[2]}
function create_if_block$1(ctx) {
	var li, t, current;

	var tip = new Tip({
		props: {
		position: "bottom",
		$$slots: {
		default: [create_default_slot$1],
		tip: [create_tip_slot$1],
		contents: [create_contents_slot$1]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			li = element("li");
			tip.$$.fragment.c();
			t = space();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			tip.$$.fragment.l(li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(li, "class", "mb-1 mr-1 svelte-1d1rkia");
			add_location(li, file$1, 3, 6, 102);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(tip, li, null);
			append_dev(li, t);
			current = true;
		},

		p: function update(changed, ctx) {
			var tip_changes = {};
			if (changed.$$scope || changed.badges) tip_changes.$$scope = { changed, ctx };
			tip.$set(tip_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(tip.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(tip.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			destroy_component(tip);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$1.name, type: "if", source: "(3:4) {#if !badge[2]}", ctx });
	return block;
}

// (18:10) <div slot="contents" class="px-1 py-px font-bold rounded-lg truncate" style="color: white; background-color: {badge[1]}; border: 2px solid {badge[1]}; max-width: 12rem;"                                                                                 title="{badge[0]}">
function create_contents_slot_1$1(ctx) {
	var div, t_value = ctx.badge[0] + "", t, div_title_value;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true, class: true, style: true, title: true }, false);
			var div_nodes = children(div);

			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "slot", "contents");
			attr_dev(div, "class", "px-1 py-px font-bold rounded-lg truncate");
			set_style(div, "color", "white");
			set_style(div, "background-color", ctx.badge[1]);
			set_style(div, "border", "2px solid " + ctx.badge[1]);
			set_style(div, "max-width", "12rem");
			attr_dev(div, "title", div_title_value = ctx.badge[0]);
			add_location(div, file$1, 17, 10, 631);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},

		p: function update(changed, ctx) {
			if ((changed.badges) && t_value !== (t_value = ctx.badge[0] + "")) {
				set_data_dev(t, t_value);
			}

			if (changed.badges) {
				set_style(div, "background-color", ctx.badge[1]);
				set_style(div, "border", "2px solid " + ctx.badge[1]);
			}

			if ((changed.badges) && div_title_value !== (div_title_value = ctx.badge[0])) {
				attr_dev(div, "title", div_title_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_contents_slot_1$1.name, type: "slot", source: "(18:10) <div slot=\"contents\" class=\"px-1 py-px font-bold rounded-lg truncate\" style=\"color: white; background-color: {badge[1]}; border: 2px solid {badge[1]}; max-width: 12rem;\"                                                                                 title=\"{badge[0]}\">", ctx });
	return block;
}

// (22:10) <span slot="tip">
function create_tip_slot_1$1(ctx) {
	var span, t_value = ctx.badge[3] + "", t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { slot: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "slot", "tip");
			add_location(span, file$1, 21, 10, 951);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},

		p: function update(changed, ctx) {
			if ((changed.badges) && t_value !== (t_value = ctx.badge[3] + "")) {
				set_data_dev(t, t_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_tip_slot_1$1.name, type: "slot", source: "(22:10) <span slot=\"tip\">", ctx });
	return block;
}

// (17:8) <Tip position="bottom">
function create_default_slot_1$1(ctx) {
	var t;

	const block = {
		c: function create() {
			t = space();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_1$1.name, type: "slot", source: "(17:8) <Tip position=\"bottom\">", ctx });
	return block;
}

// (6:10) <div slot="contents" class="px-1 py-px font-bold rounded-lg truncate" style="color: {badge[1]}; border: 2px solid {badge[1]}; max-width: 12rem;"                                                                                 title="{badge[0]}">
function create_contents_slot$1(ctx) {
	var div, t_value = ctx.badge[0] + "", t, div_title_value;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true, class: true, style: true, title: true }, false);
			var div_nodes = children(div);

			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "slot", "contents");
			attr_dev(div, "class", "px-1 py-px font-bold rounded-lg truncate");
			set_style(div, "color", ctx.badge[1]);
			set_style(div, "border", "2px solid " + ctx.badge[1]);
			set_style(div, "max-width", "12rem");
			attr_dev(div, "title", div_title_value = ctx.badge[0]);
			add_location(div, file$1, 5, 10, 167);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},

		p: function update(changed, ctx) {
			if ((changed.badges) && t_value !== (t_value = ctx.badge[0] + "")) {
				set_data_dev(t, t_value);
			}

			if (changed.badges) {
				set_style(div, "color", ctx.badge[1]);
				set_style(div, "border", "2px solid " + ctx.badge[1]);
			}

			if ((changed.badges) && div_title_value !== (div_title_value = ctx.badge[0])) {
				attr_dev(div, "title", div_title_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_contents_slot$1.name, type: "slot", source: "(6:10) <div slot=\"contents\" class=\"px-1 py-px font-bold rounded-lg truncate\" style=\"color: {badge[1]}; border: 2px solid {badge[1]}; max-width: 12rem;\"                                                                                 title=\"{badge[0]}\">", ctx });
	return block;
}

// (10:10) <span slot="tip">
function create_tip_slot$1(ctx) {
	var span, t_value = ctx.badge[3] + "", t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { slot: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "slot", "tip");
			add_location(span, file$1, 9, 10, 462);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},

		p: function update(changed, ctx) {
			if ((changed.badges) && t_value !== (t_value = ctx.badge[3] + "")) {
				set_data_dev(t, t_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_tip_slot$1.name, type: "slot", source: "(10:10) <span slot=\"tip\">", ctx });
	return block;
}

// (5:8) <Tip position="bottom">
function create_default_slot$1(ctx) {
	var t;

	const block = {
		c: function create() {
			t = space();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot$1.name, type: "slot", source: "(5:8) <Tip position=\"bottom\">", ctx });
	return block;
}

// (2:2) {#each badges as badge}
function create_each_block$1(ctx) {
	var current_block_type_index, if_block, if_block_anchor, current;

	var if_block_creators = [
		create_if_block$1,
		create_else_block$1
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (!ctx.badge[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block$1.name, type: "each", source: "(2:2) {#each badges as badge}", ctx });
	return block;
}

function create_fragment$1(ctx) {
	var ul, ul_class_value, current;

	let each_value = ctx.badges;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
			this.h();
		},

		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true }, false);
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(ul, "class", ul_class_value = "" + ctx.$$props.class + " font-bold rounded-lg");
			add_location(ul, file$1, 0, 0, 0);
		},

		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.badges) {
				each_value = ctx.badges;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();
				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}
				check_outros();
			}

			if ((!current || changed.$$props) && ul_class_value !== (ul_class_value = "" + ctx.$$props.class + " font-bold rounded-lg")) {
				attr_dev(ul, "class", ul_class_value);
			}
		},

		i: function intro(local) {
			if (current) return;
			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},

		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(ul);
			}

			destroy_each(each_blocks, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$1.name, type: "component", source: "", ctx });
	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	
  let { streamer } = $$props; 
  let last_streamer = null;
  let badges = [];

	$$self.$set = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('streamer' in $$new_props) $$invalidate('streamer', streamer = $$new_props.streamer);
	};

	$$self.$capture_state = () => {
		return { streamer, last_streamer, badges };
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('streamer' in $$props) $$invalidate('streamer', streamer = $$new_props.streamer);
		if ('last_streamer' in $$props) $$invalidate('last_streamer', last_streamer = $$new_props.last_streamer);
		if ('badges' in $$props) $$invalidate('badges', badges = $$new_props.badges);
	};

	$$self.$$.update = ($$dirty = { streamer: 1, last_streamer: 1, badges: 1 }) => {
		if ($$dirty.streamer || $$dirty.last_streamer || $$dirty.badges) { if(streamer != last_streamer){
        $$invalidate('last_streamer', last_streamer = streamer);
        $$invalidate('badges', badges = []);
        if(streamer.primary_game_name)
          badges.push([streamer.primary_game_name, dark_random_color(streamer.primary_game_id), 1, "가장 많이하는 컨텐츠"]);
        if(streamer.secondary_game_name)
          badges.push([streamer.secondary_game_name, dark_random_color(streamer.secondary_game_id), 1, "두번째로 많이하는 컨텐츠"]);
        $$invalidate('badges', badges), $$invalidate('streamer', streamer), $$invalidate('last_streamer', last_streamer);
      } }
	};

	return {
		streamer,
		badges,
		$$props,
		$$props: $$props = exclude_internal_props($$props)
	};
}

class GameBadges extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["streamer"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "GameBadges", options, id: create_fragment$1.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.streamer === undefined && !('streamer' in props)) {
			console.warn("<GameBadges> was created without expected prop 'streamer'");
		}
	}

	get streamer() {
		throw new Error("<GameBadges>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set streamer(value) {
		throw new Error("<GameBadges>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/FaIcon.svelte generated by Svelte v3.12.1 */

const file$2 = "src/components/FaIcon.svelte";

function create_fragment$2(ctx) {
	var svg, path, path_d_value, svg_viewBox_value, svg_class_value, svg_style_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", { "area-hidden": true, role: true, xmlns: true, viewBox: true, class: true, style: true }, true);
			var svg_nodes = children(svg);

			path = claim_element(svg_nodes, "path", { fill: true, d: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(path, "fill", "currentColor");
			attr_dev(path, "d", path_d_value = ctx.icon.icon[4]);
			add_location(path, file$2, 6, 2, 224);
			attr_dev(svg, "area-hidden", "true");
			attr_dev(svg, "role", "img");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "viewBox", svg_viewBox_value = "0 0 " + ctx.icon.icon[0] + " " + ctx.icon.icon[1]);
			attr_dev(svg, "class", svg_class_value = "" + ctx.$$props.class + " overflow-visible inline-block");
			attr_dev(svg, "style", svg_style_value = ctx.$$props.style);
			add_location(svg, file$2, 0, 0, 0);
		},

		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},

		p: function update(changed, ctx) {
			if ((changed.icon) && path_d_value !== (path_d_value = ctx.icon.icon[4])) {
				attr_dev(path, "d", path_d_value);
			}

			if ((changed.icon) && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + ctx.icon.icon[0] + " " + ctx.icon.icon[1])) {
				attr_dev(svg, "viewBox", svg_viewBox_value);
			}

			if ((changed.$$props) && svg_class_value !== (svg_class_value = "" + ctx.$$props.class + " overflow-visible inline-block")) {
				attr_dev(svg, "class", svg_class_value);
			}

			if ((changed.$$props) && svg_style_value !== (svg_style_value = ctx.$$props.style)) {
				attr_dev(svg, "style", svg_style_value);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$2.name, type: "component", source: "", ctx });
	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { icon } = $$props;

	$$self.$set = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('icon' in $$new_props) $$invalidate('icon', icon = $$new_props.icon);
	};

	$$self.$capture_state = () => {
		return { icon };
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('icon' in $$props) $$invalidate('icon', icon = $$new_props.icon);
	};

	return {
		icon,
		$$props,
		$$props: $$props = exclude_internal_props($$props)
	};
}

class FaIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, ["icon"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "FaIcon", options, id: create_fragment$2.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.icon === undefined && !('icon' in props)) {
			console.warn("<FaIcon> was created without expected prop 'icon'");
		}
	}

	get icon() {
		throw new Error("<FaIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set icon(value) {
		throw new Error("<FaIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Badges as B, FaIcon as F, GameBadges as G };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmFJY29uLjQ4OWI3MTlmLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZvcnRhd2Vzb21lL2ZyZWUtc29saWQtc3ZnLWljb25zL2ZhUm9ib3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZvcnRhd2Vzb21lL2ZyZWUtc29saWQtc3ZnLWljb25zL2ZhQnVpbGRpbmcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZvcnRhd2Vzb21lL2ZyZWUtc29saWQtc3ZnLWljb25zL2ZhSG9tZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZm9ydGF3ZXNvbWUvZnJlZS1zb2xpZC1zdmctaWNvbnMvZmFDaXR5LmpzIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvQmFkZ2VzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0dhbWVCYWRnZXMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvRmFJY29uLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHByZWZpeCA9ICdmYXMnO1xudmFyIGljb25OYW1lID0gJ3JvYm90JztcbnZhciB3aWR0aCA9IDY0MDtcbnZhciBoZWlnaHQgPSA1MTI7XG52YXIgbGlnYXR1cmVzID0gW107XG52YXIgdW5pY29kZSA9ICdmNTQ0JztcbnZhciBzdmdQYXRoRGF0YSA9ICdNMzIsMjI0SDY0VjQxNkgzMkEzMS45NjE2NiwzMS45NjE2NiwwLDAsMSwwLDM4NFYyNTZBMzEuOTYxNjYsMzEuOTYxNjYsMCwwLDEsMzIsMjI0Wm01MTItNDhWNDQ4YTY0LjA2MzI4LDY0LjA2MzI4LDAsMCwxLTY0LDY0SDE2MGE2NC4wNjMyOCw2NC4wNjMyOCwwLDAsMS02NC02NFYxNzZhNzkuOTc0LDc5Ljk3NCwwLDAsMSw4MC04MEgyODhWMzJhMzIsMzIsMCwwLDEsNjQsMFY5Nkg0NjRBNzkuOTc0LDc5Ljk3NCwwLDAsMSw1NDQsMTc2Wk0yNjQsMjU2YTQwLDQwLDAsMSwwLTQwLDQwQTM5Ljk5NywzOS45OTcsMCwwLDAsMjY0LDI1NlptLTgsMTI4SDE5MnYzMmg2NFptOTYsMEgyODh2MzJoNjRaTTQ1NiwyNTZhNDAsNDAsMCwxLDAtNDAsNDBBMzkuOTk3LDM5Ljk5NywwLDAsMCw0NTYsMjU2Wm0tOCwxMjhIMzg0djMyaDY0Wk02NDAsMjU2VjM4NGEzMS45NjE2NiwzMS45NjE2NiwwLDAsMS0zMiwzMkg1NzZWMjI0aDMyQTMxLjk2MTY2LDMxLjk2MTY2LDAsMCwxLDY0MCwyNTZaJztcblxuZXhwb3J0cy5kZWZpbml0aW9uID0ge1xuICBwcmVmaXg6IHByZWZpeCxcbiAgaWNvbk5hbWU6IGljb25OYW1lLFxuICBpY29uOiBbXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGxpZ2F0dXJlcyxcbiAgICB1bmljb2RlLFxuICAgIHN2Z1BhdGhEYXRhXG4gIF19O1xuXG5leHBvcnRzLmZhUm9ib3QgPSBleHBvcnRzLmRlZmluaXRpb247XG5leHBvcnRzLnByZWZpeCA9IHByZWZpeDtcbmV4cG9ydHMuaWNvbk5hbWUgPSBpY29uTmFtZTtcbmV4cG9ydHMud2lkdGggPSB3aWR0aDtcbmV4cG9ydHMuaGVpZ2h0ID0gaGVpZ2h0O1xuZXhwb3J0cy5saWdhdHVyZXMgPSBsaWdhdHVyZXM7XG5leHBvcnRzLnVuaWNvZGUgPSB1bmljb2RlO1xuZXhwb3J0cy5zdmdQYXRoRGF0YSA9IHN2Z1BhdGhEYXRhOyIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJlZml4ID0gJ2Zhcyc7XG52YXIgaWNvbk5hbWUgPSAnYnVpbGRpbmcnO1xudmFyIHdpZHRoID0gNDQ4O1xudmFyIGhlaWdodCA9IDUxMjtcbnZhciBsaWdhdHVyZXMgPSBbXTtcbnZhciB1bmljb2RlID0gJ2YxYWQnO1xudmFyIHN2Z1BhdGhEYXRhID0gJ000MzYgNDgwaC0yMFYyNGMwLTEzLjI1NS0xMC43NDUtMjQtMjQtMjRINTZDNDIuNzQ1IDAgMzIgMTAuNzQ1IDMyIDI0djQ1NkgxMmMtNi42MjcgMC0xMiA1LjM3My0xMiAxMnYyMGg0NDh2LTIwYzAtNi42MjctNS4zNzMtMTItMTItMTJ6TTEyOCA3NmMwLTYuNjI3IDUuMzczLTEyIDEyLTEyaDQwYzYuNjI3IDAgMTIgNS4zNzMgMTIgMTJ2NDBjMCA2LjYyNy01LjM3MyAxMi0xMiAxMmgtNDBjLTYuNjI3IDAtMTItNS4zNzMtMTItMTJWNzZ6bTAgOTZjMC02LjYyNyA1LjM3My0xMiAxMi0xMmg0MGM2LjYyNyAwIDEyIDUuMzczIDEyIDEydjQwYzAgNi42MjctNS4zNzMgMTItMTIgMTJoLTQwYy02LjYyNyAwLTEyLTUuMzczLTEyLTEydi00MHptNTIgMTQ4aC00MGMtNi42MjcgMC0xMi01LjM3My0xMi0xMnYtNDBjMC02LjYyNyA1LjM3My0xMiAxMi0xMmg0MGM2LjYyNyAwIDEyIDUuMzczIDEyIDEydjQwYzAgNi42MjctNS4zNzMgMTItMTIgMTJ6bTc2IDE2MGgtNjR2LTg0YzAtNi42MjcgNS4zNzMtMTIgMTItMTJoNDBjNi42MjcgMCAxMiA1LjM3MyAxMiAxMnY4NHptNjQtMTcyYzAgNi42MjctNS4zNzMgMTItMTIgMTJoLTQwYy02LjYyNyAwLTEyLTUuMzczLTEyLTEydi00MGMwLTYuNjI3IDUuMzczLTEyIDEyLTEyaDQwYzYuNjI3IDAgMTIgNS4zNzMgMTIgMTJ2NDB6bTAtOTZjMCA2LjYyNy01LjM3MyAxMi0xMiAxMmgtNDBjLTYuNjI3IDAtMTItNS4zNzMtMTItMTJ2LTQwYzAtNi42MjcgNS4zNzMtMTIgMTItMTJoNDBjNi42MjcgMCAxMiA1LjM3MyAxMiAxMnY0MHptMC05NmMwIDYuNjI3LTUuMzczIDEyLTEyIDEyaC00MGMtNi42MjcgMC0xMi01LjM3My0xMi0xMlY3NmMwLTYuNjI3IDUuMzczLTEyIDEyLTEyaDQwYzYuNjI3IDAgMTIgNS4zNzMgMTIgMTJ2NDB6JztcblxuZXhwb3J0cy5kZWZpbml0aW9uID0ge1xuICBwcmVmaXg6IHByZWZpeCxcbiAgaWNvbk5hbWU6IGljb25OYW1lLFxuICBpY29uOiBbXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGxpZ2F0dXJlcyxcbiAgICB1bmljb2RlLFxuICAgIHN2Z1BhdGhEYXRhXG4gIF19O1xuXG5leHBvcnRzLmZhQnVpbGRpbmcgPSBleHBvcnRzLmRlZmluaXRpb247XG5leHBvcnRzLnByZWZpeCA9IHByZWZpeDtcbmV4cG9ydHMuaWNvbk5hbWUgPSBpY29uTmFtZTtcbmV4cG9ydHMud2lkdGggPSB3aWR0aDtcbmV4cG9ydHMuaGVpZ2h0ID0gaGVpZ2h0O1xuZXhwb3J0cy5saWdhdHVyZXMgPSBsaWdhdHVyZXM7XG5leHBvcnRzLnVuaWNvZGUgPSB1bmljb2RlO1xuZXhwb3J0cy5zdmdQYXRoRGF0YSA9IHN2Z1BhdGhEYXRhOyIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJlZml4ID0gJ2Zhcyc7XG52YXIgaWNvbk5hbWUgPSAnaG9tZSc7XG52YXIgd2lkdGggPSA1NzY7XG52YXIgaGVpZ2h0ID0gNTEyO1xudmFyIGxpZ2F0dXJlcyA9IFtdO1xudmFyIHVuaWNvZGUgPSAnZjAxNSc7XG52YXIgc3ZnUGF0aERhdGEgPSAnTTI4MC4zNyAxNDguMjZMOTYgMzAwLjExVjQ2NGExNiAxNiAwIDAgMCAxNiAxNmwxMTIuMDYtLjI5YTE2IDE2IDAgMCAwIDE1LjkyLTE2VjM2OGExNiAxNiAwIDAgMSAxNi0xNmg2NGExNiAxNiAwIDAgMSAxNiAxNnY5NS42NGExNiAxNiAwIDAgMCAxNiAxNi4wNUw0NjQgNDgwYTE2IDE2IDAgMCAwIDE2LTE2VjMwMEwyOTUuNjcgMTQ4LjI2YTEyLjE5IDEyLjE5IDAgMCAwLTE1LjMgMHpNNTcxLjYgMjUxLjQ3TDQ4OCAxODIuNTZWNDQuMDVhMTIgMTIgMCAwIDAtMTItMTJoLTU2YTEyIDEyIDAgMCAwLTEyIDEydjcyLjYxTDMxOC40NyA0M2E0OCA0OCAwIDAgMC02MSAwTDQuMzQgMjUxLjQ3YTEyIDEyIDAgMCAwLTEuNiAxNi45bDI1LjUgMzFBMTIgMTIgMCAwIDAgNDUuMTUgMzAxbDIzNS4yMi0xOTMuNzRhMTIuMTkgMTIuMTkgMCAwIDEgMTUuMyAwTDUzMC45IDMwMWExMiAxMiAwIDAgMCAxNi45LTEuNmwyNS41LTMxYTEyIDEyIDAgMCAwLTEuNy0xNi45M3onO1xuXG5leHBvcnRzLmRlZmluaXRpb24gPSB7XG4gIHByZWZpeDogcHJlZml4LFxuICBpY29uTmFtZTogaWNvbk5hbWUsXG4gIGljb246IFtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGlnYXR1cmVzLFxuICAgIHVuaWNvZGUsXG4gICAgc3ZnUGF0aERhdGFcbiAgXX07XG5cbmV4cG9ydHMuZmFIb21lID0gZXhwb3J0cy5kZWZpbml0aW9uO1xuZXhwb3J0cy5wcmVmaXggPSBwcmVmaXg7XG5leHBvcnRzLmljb25OYW1lID0gaWNvbk5hbWU7XG5leHBvcnRzLndpZHRoID0gd2lkdGg7XG5leHBvcnRzLmhlaWdodCA9IGhlaWdodDtcbmV4cG9ydHMubGlnYXR1cmVzID0gbGlnYXR1cmVzO1xuZXhwb3J0cy51bmljb2RlID0gdW5pY29kZTtcbmV4cG9ydHMuc3ZnUGF0aERhdGEgPSBzdmdQYXRoRGF0YTsiLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHByZWZpeCA9ICdmYXMnO1xudmFyIGljb25OYW1lID0gJ2NpdHknO1xudmFyIHdpZHRoID0gNjQwO1xudmFyIGhlaWdodCA9IDUxMjtcbnZhciBsaWdhdHVyZXMgPSBbXTtcbnZhciB1bmljb2RlID0gJ2Y2NGYnO1xudmFyIHN2Z1BhdGhEYXRhID0gJ002MTYgMTkySDQ4MFYyNGMwLTEzLjI2LTEwLjc0LTI0LTI0LTI0SDMxMmMtMTMuMjYgMC0yNCAxMC43NC0yNCAyNHY3MmgtNjRWMTZjMC04Ljg0LTcuMTYtMTYtMTYtMTZoLTE2Yy04Ljg0IDAtMTYgNy4xNi0xNiAxNnY4MGgtNjRWMTZjMC04Ljg0LTcuMTYtMTYtMTYtMTZIODBjLTguODQgMC0xNiA3LjE2LTE2IDE2djgwSDI0Yy0xMy4yNiAwLTI0IDEwLjc0LTI0IDI0djM2MGMwIDE3LjY3IDE0LjMzIDMyIDMyIDMyaDU3NmMxNy42NyAwIDMyLTE0LjMzIDMyLTMyVjIxNmMwLTEzLjI2LTEwLjc1LTI0LTI0LTI0ek0xMjggNDA0YzAgNi42My01LjM3IDEyLTEyIDEySDc2Yy02LjYzIDAtMTItNS4zNy0xMi0xMnYtNDBjMC02LjYzIDUuMzctMTIgMTItMTJoNDBjNi42MyAwIDEyIDUuMzcgMTIgMTJ2NDB6bTAtOTZjMCA2LjYzLTUuMzcgMTItMTIgMTJINzZjLTYuNjMgMC0xMi01LjM3LTEyLTEydi00MGMwLTYuNjMgNS4zNy0xMiAxMi0xMmg0MGM2LjYzIDAgMTIgNS4zNyAxMiAxMnY0MHptMC05NmMwIDYuNjMtNS4zNyAxMi0xMiAxMkg3NmMtNi42MyAwLTEyLTUuMzctMTItMTJ2LTQwYzAtNi42MyA1LjM3LTEyIDEyLTEyaDQwYzYuNjMgMCAxMiA1LjM3IDEyIDEydjQwem0xMjggMTkyYzAgNi42My01LjM3IDEyLTEyIDEyaC00MGMtNi42MyAwLTEyLTUuMzctMTItMTJ2LTQwYzAtNi42MyA1LjM3LTEyIDEyLTEyaDQwYzYuNjMgMCAxMiA1LjM3IDEyIDEydjQwem0wLTk2YzAgNi42My01LjM3IDEyLTEyIDEyaC00MGMtNi42MyAwLTEyLTUuMzctMTItMTJ2LTQwYzAtNi42MyA1LjM3LTEyIDEyLTEyaDQwYzYuNjMgMCAxMiA1LjM3IDEyIDEydjQwem0wLTk2YzAgNi42My01LjM3IDEyLTEyIDEyaC00MGMtNi42MyAwLTEyLTUuMzctMTItMTJ2LTQwYzAtNi42MyA1LjM3LTEyIDEyLTEyaDQwYzYuNjMgMCAxMiA1LjM3IDEyIDEydjQwem0xNjAgOTZjMCA2LjYzLTUuMzcgMTItMTIgMTJoLTQwYy02LjYzIDAtMTItNS4zNy0xMi0xMnYtNDBjMC02LjYzIDUuMzctMTIgMTItMTJoNDBjNi42MyAwIDEyIDUuMzcgMTIgMTJ2NDB6bTAtOTZjMCA2LjYzLTUuMzcgMTItMTIgMTJoLTQwYy02LjYzIDAtMTItNS4zNy0xMi0xMnYtNDBjMC02LjYzIDUuMzctMTIgMTItMTJoNDBjNi42MyAwIDEyIDUuMzcgMTIgMTJ2NDB6bTAtOTZjMCA2LjYzLTUuMzcgMTItMTIgMTJoLTQwYy02LjYzIDAtMTItNS4zNy0xMi0xMlY3NmMwLTYuNjMgNS4zNy0xMiAxMi0xMmg0MGM2LjYzIDAgMTIgNS4zNyAxMiAxMnY0MHptMTYwIDI4OGMwIDYuNjMtNS4zNyAxMi0xMiAxMmgtNDBjLTYuNjMgMC0xMi01LjM3LTEyLTEydi00MGMwLTYuNjMgNS4zNy0xMiAxMi0xMmg0MGM2LjYzIDAgMTIgNS4zNyAxMiAxMnY0MHptMC05NmMwIDYuNjMtNS4zNyAxMi0xMiAxMmgtNDBjLTYuNjMgMC0xMi01LjM3LTEyLTEydi00MGMwLTYuNjMgNS4zNy0xMiAxMi0xMmg0MGM2LjYzIDAgMTIgNS4zNyAxMiAxMnY0MHonO1xuXG5leHBvcnRzLmRlZmluaXRpb24gPSB7XG4gIHByZWZpeDogcHJlZml4LFxuICBpY29uTmFtZTogaWNvbk5hbWUsXG4gIGljb246IFtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGlnYXR1cmVzLFxuICAgIHVuaWNvZGUsXG4gICAgc3ZnUGF0aERhdGFcbiAgXX07XG5cbmV4cG9ydHMuZmFDaXR5ID0gZXhwb3J0cy5kZWZpbml0aW9uO1xuZXhwb3J0cy5wcmVmaXggPSBwcmVmaXg7XG5leHBvcnRzLmljb25OYW1lID0gaWNvbk5hbWU7XG5leHBvcnRzLndpZHRoID0gd2lkdGg7XG5leHBvcnRzLmhlaWdodCA9IGhlaWdodDtcbmV4cG9ydHMubGlnYXR1cmVzID0gbGlnYXR1cmVzO1xuZXhwb3J0cy51bmljb2RlID0gdW5pY29kZTtcbmV4cG9ydHMuc3ZnUGF0aERhdGEgPSBzdmdQYXRoRGF0YTsiLCI8dWwgY2xhc3M9XCJ7JCRwcm9wcy5jbGFzc30gZm9udC1ib2xkIHJvdW5kZWQtbGdcIj5cbiAgeyNpZiBzdHJlYW1lci5icm9hZGNhc3Rlcl90eXBlID09IFwicGFydG5lclwifVxuICAgIDxsaSBjbGFzcz1cInB5LXB4IG1iLTEgbXItMSBpbmxpbmUtYmxvY2tcIj5cbiAgICAgIDxUaXAgcG9zaXRpb249XCJib3R0b21cIj5cbiAgICAgICAgPGRpdiBzbG90PVwiY29udGVudHNcIj5cbiAgICAgICAgICA8aW1nIHNyYz1cIi90d2l0Y2hfZ2xpdGNoLnBuZ1wiIGFsdD1cInBhcnRuZXJcIiBjbGFzcz1cInctMyBoLTMgaW5saW5lXCIvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHNwYW4gc2xvdD1cInRpcFwiPlxuICAgICAgICAgIO2KuOychOy5mCDtjIztirjrhIgg7Iqk7Yq466as66i4XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvVGlwPlxuICAgIDwvbGk+XG4gIHsvaWZ9XG4gIHsjaWYgc3RyZWFtZXIuYnJvYWRjYXN0ZXJfdHlwZSA9PSBcImFmZmlsaWF0ZVwifVxuICAgIDxsaSBjbGFzcz1cInB5LXB4IG1iLTEgbXItMSBpbmxpbmUtYmxvY2tcIj5cbiAgICAgIDxUaXAgcG9zaXRpb249XCJib3R0b21cIj5cbiAgICAgICAgPGRpdiBzbG90PVwiY29udGVudHNcIj5cbiAgICAgICAgICA8aW1nIHNyYz1cIi92ZXJpZmllZF9pY29uLnBuZ1wiIGFsdD1cImFmZmlsaWF0ZVwiIGNsYXNzPVwidy0zIGgtMyBpbmxpbmVcIi8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8c3BhbiBzbG90PVwidGlwXCI+XG4gICAgICAgICAg7Yq47JyE7LmYIOygnO2ctCDsiqTtirjrpqzrqLhcbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9UaXA+XG4gICAgPC9saT5cbiAgey9pZn1cbiAgeyNpZiAwfVxuICB7I2lmIHN0cmVhbWVyLnN0cmVhbWluZ19ob3Vyc19wZXJfd2VlayA+PSA1Nn1cbiAgICA8bGkgY2xhc3M9XCJweS1weCBtYi0xIG1yLTEgaW5saW5lLWJsb2NrXCI+XG4gICAgICA8VGlwIHBvc2l0aW9uPVwiYm90dG9tXCI+XG4gICAgICAgIDxkaXYgc2xvdD1cImNvbnRlbnRzXCI+XG4gICAgICAgICAgPHN2ZyBhcmVhLWhpZGRlbj1cInRydWVcIiByb2xlPVwiaW1nXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAge2ZhUm9ib3QuaWNvblswXX0ge2ZhUm9ib3QuaWNvblsxXX1cIiBjbGFzcz1cInctNCBoLTQgb3ZlcmZsb3ctdmlzaWJsZSBpbmxpbmUtYmxvY2tcIj5cbiAgICAgICAgICAgIDxwYXRoIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBkPVwie2ZhUm9ib3QuaWNvbls0XX1cIi8+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8c3BhbiBzbG90PVwidGlwXCI+XG4gICAgICAgICAg66Gc67SHIC0g7J20IOyKpO2KuOumrOuouOuKlCDtlZwg7KO87JeQIDU27Iuc6rCEIOydtOyDgSDrsKnshqHtlanri4jri6QuXG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvVGlwPlxuICAgIDwvbGk+XG4gIHsvaWZ9XG4gIHsjaWYgc3RyZWFtZXIuYXZlcmFnZV92aWV3ZXJfY291bnQgPj0gMTAwMDB9XG4gICAgPGxpIGNsYXNzPVwicHktcHggbWItMSBtci0xIGlubGluZS1ibG9ja1wiPlxuICAgICAgPFRpcCBwb3NpdGlvbj1cImJvdHRvbVwiPlxuICAgICAgICA8ZGl2IHNsb3Q9XCJjb250ZW50c1wiPlxuICAgICAgICAgIDxzdmcgYXJlYS1oaWRkZW49XCJ0cnVlXCIgcm9sZT1cImltZ1wiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIHtmYUNpdHkuaWNvblswXX0ge2ZhQ2l0eS5pY29uWzFdfVwiIGNsYXNzPVwidy00IGgtNCBvdmVyZmxvdy12aXNpYmxlIGlubGluZS1ibG9ja1wiPlxuICAgICAgICAgICAgPHBhdGggZmlsbD1cImN1cnJlbnRDb2xvclwiIGQ9XCJ7ZmFDaXR5Lmljb25bNF19XCIvPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHNwYW4gc2xvdD1cInRpcFwiPlxuICAgICAgICAgIOuPhOyLnCAtIOydtCDsiqTtirjrpqzrqLjsnZgg67Cp7Iah7J2EIO2Pieq3oCDrp4zrqoUg7J207IOBIOyLnOyyre2VqeuLiOuLpC5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9UaXA+XG4gICAgPC9saT5cbiAgezplbHNlIGlmIHN0cmVhbWVyLmF2ZXJhZ2Vfdmlld2VyX2NvdW50ID49IDEwMDB9XG4gICAgPGxpIGNsYXNzPVwicHktcHggbWItMSBtci0xIGlubGluZS1ibG9ja1wiPlxuICAgICAgPFRpcCBwb3NpdGlvbj1cImJvdHRvbVwiPlxuICAgICAgICA8ZGl2IHNsb3Q9XCJjb250ZW50c1wiPlxuICAgICAgICAgIDxzdmcgYXJlYS1oaWRkZW49XCJ0cnVlXCIgcm9sZT1cImltZ1wiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIHtmYUJ1aWxkaW5nLmljb25bMF19IHtmYUJ1aWxkaW5nLmljb25bMV19XCIgY2xhc3M9XCJ3LTQgaC00IG92ZXJmbG93LXZpc2libGUgaW5saW5lLWJsb2NrXCI+XG4gICAgICAgICAgICA8cGF0aCBmaWxsPVwiY3VycmVudENvbG9yXCIgZD1cIntmYUJ1aWxkaW5nLmljb25bNF19XCIvPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHNwYW4gc2xvdD1cInRpcFwiPlxuICAgICAgICAgIOu5jOuUqSAtIOydtCDsiqTtirjrpqzrqLjsnZgg67Cp7Iah7J2EIO2Pieq3oCDsspzrqoUg7J207IOBIOyLnOyyre2VqeuLiOuLpC5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9UaXA+XG4gICAgPC9saT5cbiAgezplbHNlIGlmIHN0cmVhbWVyLmF2ZXJhZ2Vfdmlld2VyX2NvdW50ID49IDEwMH1cbiAgICA8bGkgY2xhc3M9XCJweS1weCBtYi0xIG1yLTEgaW5saW5lLWJsb2NrXCI+XG4gICAgICA8VGlwIHBvc2l0aW9uPVwiYm90dG9tXCI+XG4gICAgICAgIDxkaXYgc2xvdD1cImNvbnRlbnRzXCI+XG4gICAgICAgICAgPHN2ZyBhcmVhLWhpZGRlbj1cInRydWVcIiByb2xlPVwiaW1nXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAge2ZhSG9tZS5pY29uWzBdfSB7ZmFIb21lLmljb25bMV19XCIgY2xhc3M9XCJ3LTQgaC00IG92ZXJmbG93LXZpc2libGUgaW5saW5lLWJsb2NrXCI+XG4gICAgICAgICAgICA8cGF0aCBmaWxsPVwiY3VycmVudENvbG9yXCIgZD1cIntmYUhvbWUuaWNvbls0XX1cIi8+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8c3BhbiBzbG90PVwidGlwXCI+XG4gICAgICAgICAg7KO87YOdIC0g7J20IOyKpO2KuOumrOuouOydmCDrsKnshqHsnYQg7Y+J6regIOuwseuqhSDsnbTsg4Eg7Iuc7LKt7ZWp64uI64ukLlxuICAgICAgICA8L3NwYW4+XG4gICAgICA8L1RpcD5cbiAgICA8L2xpPlxuICB7L2lmfVxuICB7L2lmfVxuICB7I2lmIHN0cmVhbWVyLmlzX3N0cmVhbWluZ31cbiAgICA8IS0tPGxpIGNsYXNzPVwicHktcHggbWItMSBtci0xIGZvbnQtYm9sZCByb3VuZGVkLWxnIHRyYWNraW5nLXRpZ2h0ZXIgaW5saW5lLWJsb2NrXCIgc3R5bGU9XCJjb2xvcjogI0ZGNDU2MDtcIj5PTiBBSVI8L2xpPi0tPlxuICB7L2lmfVxuICB7I2VhY2ggYmFkZ2VzIGFzIGJhZGdlfVxuICAgIHsjaWYgIWJhZGdlWzJdfVxuICAgICAgPGxpIGNsYXNzPVwibWItMSBtci0xIGlubGluZS1ibG9ja1wiPlxuICAgICAgICA8VGlwIHBvc2l0aW9uPVwiYm90dG9tXCI+XG4gICAgICAgICAgPGRpdiBzbG90PVwiY29udGVudHNcIiBjbGFzcz1cInB4LTEgcHktcHggZm9udC1ib2xkIHJvdW5kZWQtbGdcIiBzdHlsZT1cImNvbG9yOiB7YmFkZ2VbMV19OyBib3JkZXI6IDJweCBzb2xpZCB7YmFkZ2VbMV19O1wiPlxuICAgICAgICAgICAge2JhZGdlWzBdfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxzcGFuIHNsb3Q9XCJ0aXBcIj5cbiAgICAgICAgICAgIHtiYWRnZVszXX1cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvVGlwPlxuICAgICAgPC9saT5cbiAgICB7OmVsc2V9XG4gICAgICA8bGkgY2xhc3M9XCJtYi0xIG1yLTEgaW5saW5lLWJsb2NrXCI+XG4gICAgICAgIDxUaXAgcG9zaXRpb249XCJib3R0b21cIj5cbiAgICAgICAgICA8ZGl2IHNsb3Q9XCJjb250ZW50c1wiIGNsYXNzPVwicHgtMSBweS1weCBmb250LWJvbGQgcm91bmRlZC1sZ1wiIHN0eWxlPVwiY29sb3I6IHdoaXRlOyBiYWNrZ3JvdW5kLWNvbG9yOiB7YmFkZ2VbMV19OyBib3JkZXI6IDJweCBzb2xpZCB7YmFkZ2VbMV19O1wiPlxuICAgICAgICAgICAge2JhZGdlWzBdfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxzcGFuIHNsb3Q9XCJ0aXBcIj5cbiAgICAgICAgICAgIHtiYWRnZVszXX1cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvVGlwPlxuICAgICAgPC9saT5cbiAgICB7L2lmfVxuICB7L2VhY2h9XG48L3VsPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBkYXJrX3JhbmRvbV9jb2xvciB9IGZyb20gXCIuLi91dGlsLmpzXCI7XG4gIGltcG9ydCB7IGZhUm9ib3QgfSBmcm9tICdAZm9ydGF3ZXNvbWUvZnJlZS1zb2xpZC1zdmctaWNvbnMvZmFSb2JvdCc7XG4gIGltcG9ydCB7IGZhQnVpbGRpbmcgfSBmcm9tICdAZm9ydGF3ZXNvbWUvZnJlZS1zb2xpZC1zdmctaWNvbnMvZmFCdWlsZGluZyc7XG4gIGltcG9ydCB7IGZhSG9tZSB9IGZyb20gJ0Bmb3J0YXdlc29tZS9mcmVlLXNvbGlkLXN2Zy1pY29ucy9mYUhvbWUnO1xuICBpbXBvcnQgeyBmYUNpdHkgfSBmcm9tICdAZm9ydGF3ZXNvbWUvZnJlZS1zb2xpZC1zdmctaWNvbnMvZmFDaXR5JztcbiAgaW1wb3J0IFRpcCBmcm9tIFwiLi9UaXAuc3ZlbHRlXCI7XG4gIGV4cG9ydCBsZXQgc3RyZWFtZXI7IFxuICBsZXQgbGFzdF9zdHJlYW1lciA9IG51bGw7XG4gIGxldCBiYWRnZXMgPSBbXTtcbiAgJDogaWYoc3RyZWFtZXIgIT0gbGFzdF9zdHJlYW1lcil7XG4gICAgbGFzdF9zdHJlYW1lciA9IHN0cmVhbWVyO1xuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICBsaSB7XG4gICAgZm9udC1zaXplOiAwLjVyZW07XG4gIH1cbjwvc3R5bGU+XG4iLCI8dWwgY2xhc3M9XCJ7JCRwcm9wcy5jbGFzc30gZm9udC1ib2xkIHJvdW5kZWQtbGdcIj5cbiAgeyNlYWNoIGJhZGdlcyBhcyBiYWRnZX1cbiAgICB7I2lmICFiYWRnZVsyXX1cbiAgICAgIDxsaSBjbGFzcz1cIm1iLTEgbXItMVwiPlxuICAgICAgICA8VGlwIHBvc2l0aW9uPVwiYm90dG9tXCI+XG4gICAgICAgICAgPGRpdiBzbG90PVwiY29udGVudHNcIiBjbGFzcz1cInB4LTEgcHktcHggZm9udC1ib2xkIHJvdW5kZWQtbGcgdHJ1bmNhdGVcIiBzdHlsZT1cImNvbG9yOiB7YmFkZ2VbMV19OyBib3JkZXI6IDJweCBzb2xpZCB7YmFkZ2VbMV19OyBtYXgtd2lkdGg6IDEycmVtO1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPVwie2JhZGdlWzBdfVwiPlxuICAgICAgICAgICAge2JhZGdlWzBdfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxzcGFuIHNsb3Q9XCJ0aXBcIj5cbiAgICAgICAgICAgIHtiYWRnZVszXX1cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvVGlwPlxuICAgICAgPC9saT5cbiAgICB7OmVsc2V9XG4gICAgICA8bGkgY2xhc3M9XCJtYi0xIG1yLTFcIj5cbiAgICAgICAgPFRpcCBwb3NpdGlvbj1cImJvdHRvbVwiPlxuICAgICAgICAgIDxkaXYgc2xvdD1cImNvbnRlbnRzXCIgY2xhc3M9XCJweC0xIHB5LXB4IGZvbnQtYm9sZCByb3VuZGVkLWxnIHRydW5jYXRlXCIgc3R5bGU9XCJjb2xvcjogd2hpdGU7IGJhY2tncm91bmQtY29sb3I6IHtiYWRnZVsxXX07IGJvcmRlcjogMnB4IHNvbGlkIHtiYWRnZVsxXX07IG1heC13aWR0aDogMTJyZW07XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJ7YmFkZ2VbMF19XCI+XG4gICAgICAgICAgICB7YmFkZ2VbMF19XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPHNwYW4gc2xvdD1cInRpcFwiPlxuICAgICAgICAgICAge2JhZGdlWzNdfVxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9UaXA+XG4gICAgICA8L2xpPlxuICAgIHsvaWZ9XG4gIHsvZWFjaH1cbjwvdWw+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCB7IGRhcmtfcmFuZG9tX2NvbG9yIH0gZnJvbSBcIi4uL3V0aWwuanNcIjtcbiAgaW1wb3J0IFRpcCBmcm9tIFwiLi9UaXAuc3ZlbHRlXCI7XG4gIGV4cG9ydCBsZXQgc3RyZWFtZXI7IFxuICBsZXQgbGFzdF9zdHJlYW1lciA9IG51bGw7XG4gIGxldCBiYWRnZXMgPSBbXTtcbiAgJDogaWYoc3RyZWFtZXIgIT0gbGFzdF9zdHJlYW1lcil7XG4gICAgbGFzdF9zdHJlYW1lciA9IHN0cmVhbWVyO1xuICAgIGJhZGdlcyA9IFtdO1xuICAgIGlmKHN0cmVhbWVyLnByaW1hcnlfZ2FtZV9uYW1lKVxuICAgICAgYmFkZ2VzLnB1c2goW3N0cmVhbWVyLnByaW1hcnlfZ2FtZV9uYW1lLCBkYXJrX3JhbmRvbV9jb2xvcihzdHJlYW1lci5wcmltYXJ5X2dhbWVfaWQpLCAxLCBcIuqwgOyepSDrp47snbTtlZjripQg7Luo7YWQ7LigXCJdKTtcbiAgICBpZihzdHJlYW1lci5zZWNvbmRhcnlfZ2FtZV9uYW1lKVxuICAgICAgYmFkZ2VzLnB1c2goW3N0cmVhbWVyLnNlY29uZGFyeV9nYW1lX25hbWUsIGRhcmtfcmFuZG9tX2NvbG9yKHN0cmVhbWVyLnNlY29uZGFyeV9nYW1lX2lkKSwgMSwgXCLrkZDrsojsp7jroZwg66eO7J207ZWY64qUIOy7qO2FkOy4oFwiXSk7XG4gICAgYmFkZ2VzID0gYmFkZ2VzO1xuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICBsaSB7XG4gICAgZm9udC1zaXplOiAwLjVyZW07XG4gICAgLyogd2hpdGUtc3BhY2U6IG5vcm1hbDsqL1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgfVxuPC9zdHlsZT5cbiIsIjxzdmcgYXJlYS1oaWRkZW49XCJ0cnVlXCIgXG4gICAgIHJvbGU9XCJpbWdcIiBcbiAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIFxuICAgICB2aWV3Qm94PVwiMCAwIHtpY29uLmljb25bMF19IHtpY29uLmljb25bMV19XCIgXG4gICAgIGNsYXNzPVwieyQkcHJvcHMuY2xhc3N9IG92ZXJmbG93LXZpc2libGUgaW5saW5lLWJsb2NrXCJcbiAgICAgc3R5bGU9XCJ7JCRwcm9wcy5zdHlsZX1cIj5cbiAgPHBhdGggZmlsbD1cImN1cnJlbnRDb2xvclwiIGQ9XCJ7aWNvbi5pY29uWzRdfVwiLz5cbjwvc3ZnPlxuXG48c2NyaXB0PlxuICBleHBvcnQgbGV0IGljb247XG48L3NjcmlwdD5cbiJdLCJu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Ozs7cUNBRHFDQSxTQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFHQSxTQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1QkF5Q3JGQyxRQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzs7Ozs7cUNBRHNDQSxRQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFHQSxRQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1QkFabkZDLFlBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDOzs7OztxQ0FEa0NBLFlBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQUdBLFlBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VCQVozRkMsUUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Ozs7O3FDQURzQ0EsUUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBR0EsUUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBd0RoSCxLQUFLLENBQUMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBDQUQwRixLQUFLLENBQUMsQ0FBQyxDQUFDOytDQUFzQixLQUFLLENBQUMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QkFJeEksS0FBSyxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBZFIsS0FBSyxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytCQURpRSxLQUFLLENBQUMsQ0FBQyxDQUFDOytDQUFzQixLQUFLLENBQUMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QkFJL0csS0FBSyxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BUFosS0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
