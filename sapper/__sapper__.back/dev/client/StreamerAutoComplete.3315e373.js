import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, M as onMount, I as assign, N as exclude_internal_props, b as svg_element, c as claim_element, f as children, j as detach_dev, l as attr_dev, o as add_location, O as set_style, p as insert_dev, q as append_dev, e as element, a as space, k as claim_space, m as toggle_class, P as listen_dev, Q as set_input_value, n as noop, R as run_all, r as binding_callbacks, t as text, h as claim_text, G as set_data_dev, H as empty, B as destroy_each } from './index.1eb00da2.js';
import { A as API } from './api.8ae65b01.js';

/* src/components/StreamerAutoComplete.svelte generated by Svelte v3.12.1 */

const file = "src/components/StreamerAutoComplete.svelte";

function get_each_context_1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.streamer = list[i];
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.streamer = list[i];
	return child_ctx;
}

// (95:2) {#if icon === true}
function create_if_block_1(ctx) {
	var svg, path, svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", { xmlns: true, "xmlns:xlink": true, version: true, x: true, y: true, viewBox: true, "xml:space": true, width: true, height: true, id: true, class: true, style: true }, true);
			var svg_nodes = children(svg);

			path = claim_element(svg_nodes, "path", { d: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(path, "d", "M55.146,51.887L41.588,37.786c3.486-4.144,5.396-9.358,5.396-14.786c0-12.682-10.318-23-23-23s-23,10.318-23,23  s10.318,23,23,23c4.761,0,9.298-1.436,13.177-4.162l13.661,14.208c0.571,0.593,1.339,0.92,2.162,0.92  c0.779,0,1.518-0.297,2.079-0.837C56.255,54.982,56.293,53.08,55.146,51.887z M23.984,6c9.374,0,17,7.626,17,17s-7.626,17-17,17  s-17-7.626-17-17S14.61,6,23.984,6z");
			add_location(path, file, 96, 8, 3799);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr_dev(svg, "version", "1.1");
			attr_dev(svg, "x", "0px");
			attr_dev(svg, "y", "0px");
			attr_dev(svg, "viewBox", "0 0 56.966 56.966");
			attr_dev(svg, "xml:space", "preserve");
			attr_dev(svg, "width", "512px");
			attr_dev(svg, "height", "512px");
			attr_dev(svg, "id", "Capa_1");
			attr_dev(svg, "class", svg_class_value = "" + ctx.icon_class + " text-gray-600 fill-current absolute");
			set_style(svg, "enable-background", "new 0 0 56.966 56.966");
			set_style(svg, "top", "50%");
			set_style(svg, "transform", "translateY(-50%)");
			set_style(svg, "left", "0.6rem");
			add_location(svg, file, 95, 2, 3428);
		},

		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},

		p: function update(changed, ctx) {
			if ((changed.icon_class) && svg_class_value !== (svg_class_value = "" + ctx.icon_class + " text-gray-600 fill-current absolute")) {
				attr_dev(svg, "class", svg_class_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1.name, type: "if", source: "(95:2) {#if icon === true}", ctx });
	return block;
}

// (109:4) {:else}
function create_else_block(ctx) {
	var each_1_anchor;

	let each_value_1 = ctx.filtered_streamers;

	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},

		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},

		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if (changed.autocomplete_class || changed.filtered_streamers) {
				each_value_1 = ctx.filtered_streamers;

				let i;
				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value_1.length;
			}
		},

		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);

			if (detaching) {
				detach_dev(each_1_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block.name, type: "else", source: "(109:4) {:else}", ctx });
	return block;
}

// (101:4) {#if !input_value && recent_search_history}
function create_if_block(ctx) {
	var each_1_anchor;

	let each_value = ctx.recent_search_history;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},

		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},

		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if (changed.recent_search_history) {
				each_value = ctx.recent_search_history;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}
		},

		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);

			if (detaching) {
				detach_dev(each_1_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block.name, type: "if", source: "(101:4) {#if !input_value && recent_search_history}", ctx });
	return block;
}

// (110:6) {#each filtered_streamers as streamer}
function create_each_block_1(ctx) {
	var li, img, img_src_value, t0, div, span0, t1_value = ctx.streamer._left + "", t1, span1, t2_value = ctx.streamer._center + "", t2, span2, t3_value = ctx.streamer._right + "", t3, t4, li_class_value, dispose;

	function mousedown_handler_2(...args) {
		return ctx.mousedown_handler_2(ctx, ...args);
	}

	const block = {
		c: function create() {
			li = element("li");
			img = element("img");
			t0 = space();
			div = element("div");
			span0 = element("span");
			t1 = text(t1_value);
			span1 = element("span");
			t2 = text(t2_value);
			span2 = element("span");
			t3 = text(t3_value);
			t4 = space();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			img = claim_element(li_nodes, "IMG", { class: true, src: true }, false);
			var img_nodes = children(img);

			img_nodes.forEach(detach_dev);
			t0 = claim_space(li_nodes);

			div = claim_element(li_nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			span0 = claim_element(div_nodes, "SPAN", {}, false);
			var span0_nodes = children(span0);

			t1 = claim_text(span0_nodes, t1_value);
			span0_nodes.forEach(detach_dev);

			span1 = claim_element(div_nodes, "SPAN", { class: true }, false);
			var span1_nodes = children(span1);

			t2 = claim_text(span1_nodes, t2_value);
			span1_nodes.forEach(detach_dev);

			span2 = claim_element(div_nodes, "SPAN", {}, false);
			var span2_nodes = children(span2);

			t3 = claim_text(span2_nodes, t3_value);
			span2_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			t4 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(img, "class", "rounded-full h-8 w-8");
			attr_dev(img, "src", img_src_value = ctx.streamer.profile_image_url);
			add_location(img, file, 111, 10, 5181);
			add_location(span0, file, 112, 28, 5279);
			attr_dev(span1, "class", "text-red-500");
			add_location(span1, file, 112, 57, 5308);
			add_location(span2, file, 112, 109, 5360);
			attr_dev(div, "class", "px-2");
			add_location(div, file, 112, 10, 5261);
			attr_dev(li, "class", li_class_value = "" + ctx.autocomplete_class + " px-2 py-2 hover:bg-purple-500 hover:text-white text-black flex flex-row items-center truncate bg-white");
			add_location(li, file, 110, 8, 4992);
			dispose = listen_dev(li, "mousedown", mousedown_handler_2);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, img);
			append_dev(li, t0);
			append_dev(li, div);
			append_dev(div, span0);
			append_dev(span0, t1);
			append_dev(div, span1);
			append_dev(span1, t2);
			append_dev(div, span2);
			append_dev(span2, t3);
			append_dev(li, t4);
		},

		p: function update(changed, new_ctx) {
			ctx = new_ctx;
			if ((changed.filtered_streamers) && img_src_value !== (img_src_value = ctx.streamer.profile_image_url)) {
				attr_dev(img, "src", img_src_value);
			}

			if ((changed.filtered_streamers) && t1_value !== (t1_value = ctx.streamer._left + "")) {
				set_data_dev(t1, t1_value);
			}

			if ((changed.filtered_streamers) && t2_value !== (t2_value = ctx.streamer._center + "")) {
				set_data_dev(t2, t2_value);
			}

			if ((changed.filtered_streamers) && t3_value !== (t3_value = ctx.streamer._right + "")) {
				set_data_dev(t3, t3_value);
			}

			if ((changed.autocomplete_class) && li_class_value !== (li_class_value = "" + ctx.autocomplete_class + " px-2 py-2 hover:bg-purple-500 hover:text-white text-black flex flex-row items-center truncate bg-white")) {
				attr_dev(li, "class", li_class_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block_1.name, type: "each", source: "(110:6) {#each filtered_streamers as streamer}", ctx });
	return block;
}

// (102:6) {#each recent_search_history as streamer}
function create_each_block(ctx) {
	var li, img, img_src_value, t0, div, span, t1_value = ctx.streamer.name + "", t1, t2, button, t3, dispose;

	function mousedown_handler(...args) {
		return ctx.mousedown_handler(ctx, ...args);
	}

	function mousedown_handler_1(...args) {
		return ctx.mousedown_handler_1(ctx, ...args);
	}

	const block = {
		c: function create() {
			li = element("li");
			img = element("img");
			t0 = space();
			div = element("div");
			span = element("span");
			t1 = text(t1_value);
			t2 = space();
			button = element("button");
			t3 = text("🞩");
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			img = claim_element(li_nodes, "IMG", { class: true, src: true }, false);
			var img_nodes = children(img);

			img_nodes.forEach(detach_dev);
			t0 = claim_space(li_nodes);

			div = claim_element(li_nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			span = claim_element(div_nodes, "SPAN", {}, false);
			var span_nodes = children(span);

			t1 = claim_text(span_nodes, t1_value);
			span_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			li_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);

			button = claim_element(nodes, "BUTTON", { style: true, class: true }, false);
			var button_nodes = children(button);

			t3 = claim_text(button_nodes, "🞩");
			button_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(img, "class", "rounded-full h-8 w-8");
			attr_dev(img, "src", img_src_value = ctx.streamer.profile_image_url);
			add_location(img, file, 103, 10, 4561);
			add_location(span, file, 104, 28, 4659);
			attr_dev(div, "class", "px-2");
			add_location(div, file, 104, 10, 4641);
			attr_dev(li, "class", "md:w-48 w-32 px-2 py-2 hover:bg-purple-500 hover:text-white text-black flex flex-row items-center truncate bg-white flex-wrap");
			add_location(li, file, 102, 8, 4370);
			set_style(button, "line-height", "1rem");
			attr_dev(button, "class", "absolute right-0 w-4 h-4 text-center -mr-6 -mt-8 text-gray-800 bg-white rounded-full");
			add_location(button, file, 106, 8, 4716);

			dispose = [
				listen_dev(li, "mousedown", mousedown_handler),
				listen_dev(button, "mousedown", mousedown_handler_1)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, img);
			append_dev(li, t0);
			append_dev(li, div);
			append_dev(div, span);
			append_dev(span, t1);
			insert_dev(target, t2, anchor);
			insert_dev(target, button, anchor);
			append_dev(button, t3);
		},

		p: function update(changed, new_ctx) {
			ctx = new_ctx;
			if ((changed.recent_search_history) && img_src_value !== (img_src_value = ctx.streamer.profile_image_url)) {
				attr_dev(img, "src", img_src_value);
			}

			if ((changed.recent_search_history) && t1_value !== (t1_value = ctx.streamer.name + "")) {
				set_data_dev(t1, t1_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
				detach_dev(t2);
				detach_dev(button);
			}

			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block.name, type: "each", source: "(102:6) {#each recent_search_history as streamer}", ctx });
	return block;
}

function create_fragment(ctx) {
	var div, input, t0, t1, ul, div_class_value, dispose;

	var if_block0 = (ctx.icon === true) && create_if_block_1(ctx);

	function select_block_type(changed, ctx) {
		if (!ctx.input_value && ctx.recent_search_history) return create_if_block;
		return create_else_block;
	}

	var current_block_type = select_block_type(null, ctx);
	var if_block1 = current_block_type(ctx);

	const block = {
		c: function create() {
			div = element("div");
			input = element("input");
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			ul = element("ul");
			if_block1.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			input = claim_element(div_nodes, "INPUT", { placeholder: true, id: true, class: true }, false);
			var input_nodes = children(input);

			input_nodes.forEach(detach_dev);
			t0 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);

			ul = claim_element(div_nodes, "UL", { class: true }, false);
			var ul_nodes = children(ul);

			if_block1.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(input, "placeholder", ctx.placeholder);
			attr_dev(input, "id", ctx.inputid);
			attr_dev(input, "class", ctx.input_class);
			add_location(input, file, 88, 2, 3176);
			attr_dev(ul, "class", "absolute bg-white z-50");
			toggle_class(ul, "hidden", !ctx.focused);
			add_location(ul, file, 99, 2, 4204);
			attr_dev(div, "class", div_class_value = "inline-block relative " + ctx.$$props.class);
			add_location(div, file, 87, 0, 3121);

			dispose = [
				listen_dev(input, "input", ctx.input_input_handler),
				listen_dev(input, "focus", ctx.focus_handler),
				listen_dev(input, "keyup", ctx.on_input_change),
				listen_dev(input, "blur", ctx.blur_handler)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, input);

			set_input_value(input, ctx.input_value);

			ctx.input_binding(input);
			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			append_dev(div, ul);
			if_block1.m(ul, null);
		},

		p: function update(changed, ctx) {
			if (changed.input_value && (input.value !== ctx.input_value)) set_input_value(input, ctx.input_value);

			if (changed.placeholder) {
				attr_dev(input, "placeholder", ctx.placeholder);
			}

			if (changed.inputid) {
				attr_dev(input, "id", ctx.inputid);
			}

			if (changed.input_class) {
				attr_dev(input, "class", ctx.input_class);
			}

			if (ctx.icon === true) {
				if (if_block0) {
					if_block0.p(changed, ctx);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block1) {
				if_block1.p(changed, ctx);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type(ctx);
				if (if_block1) {
					if_block1.c();
					if_block1.m(ul, null);
				}
			}

			if (changed.focused) {
				toggle_class(ul, "hidden", !ctx.focused);
			}

			if ((changed.$$props) && div_class_value !== (div_class_value = "inline-block relative " + ctx.$$props.class)) {
				attr_dev(div, "class", div_class_value);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			ctx.input_binding(null);
			if (if_block0) if_block0.d();
			if_block1.d();
			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment.name, type: "component", source: "", ctx });
	return block;
}

let next_id=0;
const recent_search_history_length = 10;
const local_storage_recent_search_key = 'streamer-auto-complete-recent-search-history';
function load_recent_search(id){
  return JSON.parse(localStorage.getItem(local_storage_recent_search_key + id)) || [];
}
function save_recent_search(id, recent_search){
  return localStorage.setItem(local_storage_recent_search_key + id, JSON.stringify(recent_search));
}

function instance($$self, $$props, $$invalidate) {
	

  let { streamers = [], selected = null, placeholder = "", onselect = (e)=>{} } = $$props;
  let { inputid = "", input_class = "border rounded focus:outline-none md:w-48 w-32 text-sm leading-loose pr-5 transition-all focus:outline-0 border border-transparent focus:bg-white focus:border-primary-600 placeholder-gray-600 rounded-lg  bg-primary-100 pl-7", icon = true, id = next_id++, autocomplete_class = "md:w-48 w-32", icon_class = "w-3 h-3" } = $$props;
  
  
  let input_element;
  let { input_value="" } = $$props;
  let last_keyword;
  let focused = false;
  let filtered_streamers = [];
  let recent_search_history = [];

  onMount(()=>{
    $$invalidate('recent_search_history', recent_search_history = load_recent_search(id));
    $$invalidate('recent_search_history', recent_search_history = recent_search_history.map(r => streamers.find(s => s.id == r.id) || r));
  });

  function add_streamer_to_recent_search_history(streamer) {
    let index = recent_search_history.findIndex(s=>s.id == streamer.id);
    if(index >= 0)
      recent_search_history.splice(index, 1);
    $$invalidate('recent_search_history', recent_search_history = [streamer, ...recent_search_history.slice(0, recent_search_history_length-1)]);
  }

  function filter(streamers, keyword){
      $$invalidate('filtered_streamers', filtered_streamers = keyword? streamers.filter(s => s.name.toLocaleLowerCase().search(keyword.toLocaleLowerCase()) >= 0): []);
      for(let s of filtered_streamers){
        let i = s.name.toLocaleLowerCase().search(keyword.toLocaleLowerCase());
        s._left = s.name.slice(0, i);
        s._center = s.name.slice(i, i+keyword.length);
        s._right = s.name.slice(i + keyword.length);
      }
      //selected = filtered_streamers.find(s => s.name === keyword);
  }
  function on_input_change(e) {
    let keyword = input_value;
    if(last_keyword == keyword) 
      return;
    last_keyword = keyword;
    if(streamers.length){
      filter(streamers, keyword);
    }
    else {
      API.thin_streamers(keyword)
        .then(streamers=>{
          filter(streamers, keyword);
        });
    }
  }
  function on_list_click(streamer) {
    $$invalidate('selected', selected = streamer);
    $$invalidate('input_element', input_element.value = streamer.name, input_element);
    input_element.blur();
    add_streamer_to_recent_search_history(streamer);
    save_recent_search(id, recent_search_history);
    onselect(selected);
  }
  function remove_from_recent_history(streamer, e) {
    $$invalidate('recent_search_history', recent_search_history = recent_search_history.filter(e=>e.id != streamer.id));
    save_recent_search(id, recent_search_history);
    focus = true;
    return e.preventDefault() && false;
  }

	function input_input_handler() {
		input_value = this.value;
		$$invalidate('input_value', input_value);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('input_element', input_element = $$value);
		});
	}

	const focus_handler = (e) => $$invalidate('focused', focused=true);

	const blur_handler = (e) => $$invalidate('focused', focused=false);

	const mousedown_handler = ({ streamer }, e) => on_list_click(streamer);

	const mousedown_handler_1 = ({ streamer }, e) => remove_from_recent_history(streamer, e);

	const mousedown_handler_2 = ({ streamer }, e) => on_list_click(streamer);

	$$self.$set = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('streamers' in $$new_props) $$invalidate('streamers', streamers = $$new_props.streamers);
		if ('selected' in $$new_props) $$invalidate('selected', selected = $$new_props.selected);
		if ('placeholder' in $$new_props) $$invalidate('placeholder', placeholder = $$new_props.placeholder);
		if ('onselect' in $$new_props) $$invalidate('onselect', onselect = $$new_props.onselect);
		if ('inputid' in $$new_props) $$invalidate('inputid', inputid = $$new_props.inputid);
		if ('input_class' in $$new_props) $$invalidate('input_class', input_class = $$new_props.input_class);
		if ('icon' in $$new_props) $$invalidate('icon', icon = $$new_props.icon);
		if ('id' in $$new_props) $$invalidate('id', id = $$new_props.id);
		if ('autocomplete_class' in $$new_props) $$invalidate('autocomplete_class', autocomplete_class = $$new_props.autocomplete_class);
		if ('icon_class' in $$new_props) $$invalidate('icon_class', icon_class = $$new_props.icon_class);
		if ('input_value' in $$new_props) $$invalidate('input_value', input_value = $$new_props.input_value);
	};

	$$self.$capture_state = () => {
		return { next_id, streamers, selected, placeholder, onselect, inputid, input_class, icon, id, autocomplete_class, icon_class, input_element, input_value, last_keyword, focused, filtered_streamers, recent_search_history };
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('streamers' in $$props) $$invalidate('streamers', streamers = $$new_props.streamers);
		if ('selected' in $$props) $$invalidate('selected', selected = $$new_props.selected);
		if ('placeholder' in $$props) $$invalidate('placeholder', placeholder = $$new_props.placeholder);
		if ('onselect' in $$props) $$invalidate('onselect', onselect = $$new_props.onselect);
		if ('inputid' in $$props) $$invalidate('inputid', inputid = $$new_props.inputid);
		if ('input_class' in $$props) $$invalidate('input_class', input_class = $$new_props.input_class);
		if ('icon' in $$props) $$invalidate('icon', icon = $$new_props.icon);
		if ('id' in $$props) $$invalidate('id', id = $$new_props.id);
		if ('autocomplete_class' in $$props) $$invalidate('autocomplete_class', autocomplete_class = $$new_props.autocomplete_class);
		if ('icon_class' in $$props) $$invalidate('icon_class', icon_class = $$new_props.icon_class);
		if ('input_element' in $$props) $$invalidate('input_element', input_element = $$new_props.input_element);
		if ('input_value' in $$props) $$invalidate('input_value', input_value = $$new_props.input_value);
		if ('last_keyword' in $$props) last_keyword = $$new_props.last_keyword;
		if ('focused' in $$props) $$invalidate('focused', focused = $$new_props.focused);
		if ('filtered_streamers' in $$props) $$invalidate('filtered_streamers', filtered_streamers = $$new_props.filtered_streamers);
		if ('recent_search_history' in $$props) $$invalidate('recent_search_history', recent_search_history = $$new_props.recent_search_history);
	};

	return {
		streamers,
		selected,
		placeholder,
		onselect,
		inputid,
		input_class,
		icon,
		id,
		autocomplete_class,
		icon_class,
		input_element,
		input_value,
		focused,
		filtered_streamers,
		recent_search_history,
		on_input_change,
		on_list_click,
		remove_from_recent_history,
		$$props,
		input_input_handler,
		input_binding,
		focus_handler,
		blur_handler,
		mousedown_handler,
		mousedown_handler_1,
		mousedown_handler_2,
		$$props: $$props = exclude_internal_props($$props)
	};
}

class StreamerAutoComplete extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["streamers", "selected", "placeholder", "onselect", "inputid", "input_class", "icon", "id", "autocomplete_class", "icon_class", "input_value"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "StreamerAutoComplete", options, id: create_fragment.name });
	}

	get streamers() {
		throw new Error("<StreamerAutoComplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set streamers(value) {
		throw new Error("<StreamerAutoComplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selected() {
		throw new Error("<StreamerAutoComplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<StreamerAutoComplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<StreamerAutoComplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<StreamerAutoComplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onselect() {
		throw new Error("<StreamerAutoComplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onselect(value) {
		throw new Error("<StreamerAutoComplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputid() {
		throw new Error("<StreamerAutoComplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputid(value) {
		throw new Error("<StreamerAutoComplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get input_class() {
		throw new Error("<StreamerAutoComplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input_class(value) {
		throw new Error("<StreamerAutoComplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get icon() {
		throw new Error("<StreamerAutoComplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set icon(value) {
		throw new Error("<StreamerAutoComplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<StreamerAutoComplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<StreamerAutoComplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autocomplete_class() {
		throw new Error("<StreamerAutoComplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autocomplete_class(value) {
		throw new Error("<StreamerAutoComplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get icon_class() {
		throw new Error("<StreamerAutoComplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set icon_class(value) {
		throw new Error("<StreamerAutoComplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get input_value() {
		throw new Error("<StreamerAutoComplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input_value(value) {
		throw new Error("<StreamerAutoComplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { StreamerAutoComplete as S };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RyZWFtZXJBdXRvQ29tcGxldGUuMzMxNWUzNzMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1N0cmVhbWVyQXV0b0NvbXBsZXRlLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIj5cbiAgbGV0IG5leHRfaWQ9MDtcbiAgY29uc3QgcmVjZW50X3NlYXJjaF9oaXN0b3J5X2xlbmd0aCA9IDEwO1xuICBjb25zdCBsb2NhbF9zdG9yYWdlX3JlY2VudF9zZWFyY2hfa2V5ID0gJ3N0cmVhbWVyLWF1dG8tY29tcGxldGUtcmVjZW50LXNlYXJjaC1oaXN0b3J5JztcbiAgZnVuY3Rpb24gbG9hZF9yZWNlbnRfc2VhcmNoKGlkKXtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShsb2NhbF9zdG9yYWdlX3JlY2VudF9zZWFyY2hfa2V5ICsgaWQpKSB8fCBbXTtcbiAgfVxuICBmdW5jdGlvbiBzYXZlX3JlY2VudF9zZWFyY2goaWQsIHJlY2VudF9zZWFyY2gpe1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShsb2NhbF9zdG9yYWdlX3JlY2VudF9zZWFyY2hfa2V5ICsgaWQsIEpTT04uc3RyaW5naWZ5KHJlY2VudF9zZWFyY2gpKTtcbiAgfVxuPC9zY3JpcHQ+XG48c2NyaXB0PlxuICBpbXBvcnQgeyBBUEkgfSBmcm9tICcuLi9hcGkuanMnO1xuICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcblxuICBleHBvcnQgbGV0IHN0cmVhbWVycyA9IFtdO1xuICBleHBvcnQgbGV0IHNlbGVjdGVkID0gbnVsbDtcbiAgZXhwb3J0IGxldCBwbGFjZWhvbGRlciA9IFwiXCI7XG4gIGV4cG9ydCBsZXQgb25zZWxlY3QgPSAoZSk9Pnt9XG4gIGV4cG9ydCBsZXQgaW5wdXRpZCA9IFwiXCI7XG4gIGV4cG9ydCBsZXQgaW5wdXRfY2xhc3MgPSBcImJvcmRlciByb3VuZGVkIGZvY3VzOm91dGxpbmUtbm9uZSBtZDp3LTQ4IHctMzIgdGV4dC1zbSBsZWFkaW5nLWxvb3NlIHByLTUgdHJhbnNpdGlvbi1hbGwgZm9jdXM6b3V0bGluZS0wIGJvcmRlciBib3JkZXItdHJhbnNwYXJlbnQgZm9jdXM6Ymctd2hpdGUgZm9jdXM6Ym9yZGVyLXByaW1hcnktNjAwIHBsYWNlaG9sZGVyLWdyYXktNjAwIHJvdW5kZWQtbGcgIGJnLXByaW1hcnktMTAwIHBsLTdcIjtcbiAgZXhwb3J0IGxldCBpY29uID0gdHJ1ZTtcbiAgZXhwb3J0IGxldCBpZCA9IG5leHRfaWQrKztcbiAgZXhwb3J0IGxldCBhdXRvY29tcGxldGVfY2xhc3MgPSBcIm1kOnctNDggdy0zMlwiO1xuICBleHBvcnQgbGV0IGljb25fY2xhc3MgPSBcInctMyBoLTNcIjtcbiAgXG4gIFxuICBsZXQgaW5wdXRfZWxlbWVudDtcbiAgZXhwb3J0IGxldCBpbnB1dF92YWx1ZT1cIlwiO1xuICBsZXQgbGFzdF9rZXl3b3JkO1xuICBsZXQgZm9jdXNlZCA9IGZhbHNlO1xuICBsZXQgZmlsdGVyZWRfc3RyZWFtZXJzID0gW107XG4gIGxldCByZWNlbnRfc2VhcmNoX2hpc3RvcnkgPSBbXTtcblxuICBvbk1vdW50KCgpPT57XG4gICAgcmVjZW50X3NlYXJjaF9oaXN0b3J5ID0gbG9hZF9yZWNlbnRfc2VhcmNoKGlkKTtcbiAgICByZWNlbnRfc2VhcmNoX2hpc3RvcnkgPSByZWNlbnRfc2VhcmNoX2hpc3RvcnkubWFwKHIgPT4gc3RyZWFtZXJzLmZpbmQocyA9PiBzLmlkID09IHIuaWQpIHx8IHIpO1xuICB9KTtcblxuICBmdW5jdGlvbiBhZGRfc3RyZWFtZXJfdG9fcmVjZW50X3NlYXJjaF9oaXN0b3J5KHN0cmVhbWVyKSB7XG4gICAgbGV0IGluZGV4ID0gcmVjZW50X3NlYXJjaF9oaXN0b3J5LmZpbmRJbmRleChzPT5zLmlkID09IHN0cmVhbWVyLmlkKTtcbiAgICBpZihpbmRleCA+PSAwKVxuICAgICAgcmVjZW50X3NlYXJjaF9oaXN0b3J5LnNwbGljZShpbmRleCwgMSk7XG4gICAgcmVjZW50X3NlYXJjaF9oaXN0b3J5ID0gW3N0cmVhbWVyLCAuLi5yZWNlbnRfc2VhcmNoX2hpc3Rvcnkuc2xpY2UoMCwgcmVjZW50X3NlYXJjaF9oaXN0b3J5X2xlbmd0aC0xKV07XG4gIH1cblxuICBmdW5jdGlvbiBmaWx0ZXIoc3RyZWFtZXJzLCBrZXl3b3JkKXtcbiAgICAgIGZpbHRlcmVkX3N0cmVhbWVycyA9IGtleXdvcmQ/IHN0cmVhbWVycy5maWx0ZXIocyA9PiBzLm5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKS5zZWFyY2goa2V5d29yZC50b0xvY2FsZUxvd2VyQ2FzZSgpKSA+PSAwKTogW107XG4gICAgICBmb3IobGV0IHMgb2YgZmlsdGVyZWRfc3RyZWFtZXJzKXtcbiAgICAgICAgbGV0IGkgPSBzLm5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKS5zZWFyY2goa2V5d29yZC50b0xvY2FsZUxvd2VyQ2FzZSgpKTtcbiAgICAgICAgcy5fbGVmdCA9IHMubmFtZS5zbGljZSgwLCBpKTtcbiAgICAgICAgcy5fY2VudGVyID0gcy5uYW1lLnNsaWNlKGksIGkra2V5d29yZC5sZW5ndGgpO1xuICAgICAgICBzLl9yaWdodCA9IHMubmFtZS5zbGljZShpICsga2V5d29yZC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgLy9zZWxlY3RlZCA9IGZpbHRlcmVkX3N0cmVhbWVycy5maW5kKHMgPT4gcy5uYW1lID09PSBrZXl3b3JkKTtcbiAgfVxuICBmdW5jdGlvbiBvbl9pbnB1dF9jaGFuZ2UoZSkge1xuICAgIGxldCBrZXl3b3JkID0gaW5wdXRfdmFsdWU7XG4gICAgaWYobGFzdF9rZXl3b3JkID09IGtleXdvcmQpIFxuICAgICAgcmV0dXJuO1xuICAgIGxhc3Rfa2V5d29yZCA9IGtleXdvcmQ7XG4gICAgaWYoc3RyZWFtZXJzLmxlbmd0aCl7XG4gICAgICBmaWx0ZXIoc3RyZWFtZXJzLCBrZXl3b3JkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBBUEkudGhpbl9zdHJlYW1lcnMoa2V5d29yZClcbiAgICAgICAgLnRoZW4oc3RyZWFtZXJzPT57XG4gICAgICAgICAgZmlsdGVyKHN0cmVhbWVycywga2V5d29yZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbl9saXN0X2NsaWNrKHN0cmVhbWVyKSB7XG4gICAgc2VsZWN0ZWQgPSBzdHJlYW1lcjtcbiAgICBpbnB1dF9lbGVtZW50LnZhbHVlID0gc3RyZWFtZXIubmFtZTtcbiAgICBpbnB1dF9lbGVtZW50LmJsdXIoKTtcbiAgICBhZGRfc3RyZWFtZXJfdG9fcmVjZW50X3NlYXJjaF9oaXN0b3J5KHN0cmVhbWVyKTtcbiAgICBzYXZlX3JlY2VudF9zZWFyY2goaWQsIHJlY2VudF9zZWFyY2hfaGlzdG9yeSk7XG4gICAgb25zZWxlY3Qoc2VsZWN0ZWQpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZV9mcm9tX3JlY2VudF9oaXN0b3J5KHN0cmVhbWVyLCBlKSB7XG4gICAgcmVjZW50X3NlYXJjaF9oaXN0b3J5ID0gcmVjZW50X3NlYXJjaF9oaXN0b3J5LmZpbHRlcihlPT5lLmlkICE9IHN0cmVhbWVyLmlkKTtcbiAgICBzYXZlX3JlY2VudF9zZWFyY2goaWQsIHJlY2VudF9zZWFyY2hfaGlzdG9yeSk7XG4gICAgZm9jdXMgPSB0cnVlO1xuICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCkgJiYgZmFsc2U7XG4gIH1cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiaW5saW5lLWJsb2NrIHJlbGF0aXZlIHskJHByb3BzLmNsYXNzfVwiID5cbiAgPGlucHV0IFxuICAgIHBsYWNlaG9sZGVyPXtwbGFjZWhvbGRlcn1cbiAgICBpZCA9IFwie2lucHV0aWR9XCJcbiAgICBjbGFzcz1cIntpbnB1dF9jbGFzc31cIlxuICAgIG9uOmZvY3VzPXtlPT5mb2N1c2VkPXRydWV9IG9uOmtleXVwPXtvbl9pbnB1dF9jaGFuZ2V9IGJpbmQ6dmFsdWU9e2lucHV0X3ZhbHVlfSBiaW5kOnRoaXM9e2lucHV0X2VsZW1lbnR9XG4gICAgb246Ymx1cj17ZT0+Zm9jdXNlZD1mYWxzZX0gLz5cbiAgeyNpZiBpY29uID09PSB0cnVlfVxuICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB2ZXJzaW9uPVwiMS4xXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB2aWV3Qm94PVwiMCAwIDU2Ljk2NiA1Ni45NjZcIiB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiIHdpZHRoPVwiNTEycHhcIiBoZWlnaHQ9XCI1MTJweFwiIGlkPVwiQ2FwYV8xXCIgY2xhc3M9XCJ7aWNvbl9jbGFzc30gdGV4dC1ncmF5LTYwMCBmaWxsLWN1cnJlbnQgYWJzb2x1dGVcIiBzdHlsZT1cImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNTYuOTY2IDU2Ljk2NjsgdG9wOiA1MCU7IHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTsgbGVmdDogMC42cmVtO1wiPlxuICAgICAgICA8cGF0aCBkPVwiTTU1LjE0Niw1MS44ODdMNDEuNTg4LDM3Ljc4NmMzLjQ4Ni00LjE0NCw1LjM5Ni05LjM1OCw1LjM5Ni0xNC43ODZjMC0xMi42ODItMTAuMzE4LTIzLTIzLTIzcy0yMywxMC4zMTgtMjMsMjMgIHMxMC4zMTgsMjMsMjMsMjNjNC43NjEsMCw5LjI5OC0xLjQzNiwxMy4xNzctNC4xNjJsMTMuNjYxLDE0LjIwOGMwLjU3MSwwLjU5MywxLjMzOSwwLjkyLDIuMTYyLDAuOTIgIGMwLjc3OSwwLDEuNTE4LTAuMjk3LDIuMDc5LTAuODM3QzU2LjI1NSw1NC45ODIsNTYuMjkzLDUzLjA4LDU1LjE0Niw1MS44ODd6IE0yMy45ODQsNmM5LjM3NCwwLDE3LDcuNjI2LDE3LDE3cy03LjYyNiwxNy0xNywxNyAgcy0xNy03LjYyNi0xNy0xN1MxNC42MSw2LDIzLjk4NCw2elwiPjwvcGF0aD5cbiAgPC9zdmc+XG4gIHsvaWZ9XG4gIDx1bCBjbGFzcz1cImFic29sdXRlIGJnLXdoaXRlIHotNTBcIiBjbGFzczpoaWRkZW49XCJ7IWZvY3VzZWR9XCI+XG4gICAgeyNpZiAhaW5wdXRfdmFsdWUgJiYgcmVjZW50X3NlYXJjaF9oaXN0b3J5fVxuICAgICAgeyNlYWNoIHJlY2VudF9zZWFyY2hfaGlzdG9yeSBhcyBzdHJlYW1lcn1cbiAgICAgICAgPGxpIG9uOm1vdXNlZG93bj17ZT0+b25fbGlzdF9jbGljayhzdHJlYW1lcil9IGNsYXNzPVwibWQ6dy00OCB3LTMyIHB4LTIgcHktMiBob3ZlcjpiZy1wdXJwbGUtNTAwIGhvdmVyOnRleHQtd2hpdGUgdGV4dC1ibGFjayBmbGV4IGZsZXgtcm93IGl0ZW1zLWNlbnRlciB0cnVuY2F0ZSBiZy13aGl0ZSBmbGV4LXdyYXBcIj5cbiAgICAgICAgICA8aW1nIGNsYXNzPVwicm91bmRlZC1mdWxsIGgtOCB3LThcIiBzcmM9e3N0cmVhbWVyLnByb2ZpbGVfaW1hZ2VfdXJsfSAvPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJweC0yXCI+PHNwYW4+e3N0cmVhbWVyLm5hbWV9PC9zcGFuPjwvZGl2PlxuICAgICAgICA8L2xpPlxuICAgICAgICA8YnV0dG9uIHN0eWxlPVwibGluZS1oZWlnaHQ6IDFyZW1cIiBjbGFzcz1cImFic29sdXRlIHJpZ2h0LTAgdy00IGgtNCB0ZXh0LWNlbnRlciAtbXItNiAtbXQtOCB0ZXh0LWdyYXktODAwIGJnLXdoaXRlIHJvdW5kZWQtZnVsbFwiIG9uOm1vdXNlZG93bj17ZT0+cmVtb3ZlX2Zyb21fcmVjZW50X2hpc3Rvcnkoc3RyZWFtZXIsIGUpfT7wn56pPC9idXR0b24+XG4gICAgICB7L2VhY2h9XG4gICAgezplbHNlfVxuICAgICAgeyNlYWNoIGZpbHRlcmVkX3N0cmVhbWVycyBhcyBzdHJlYW1lcn1cbiAgICAgICAgPGxpIG9uOm1vdXNlZG93bj17ZT0+b25fbGlzdF9jbGljayhzdHJlYW1lcil9IGNsYXNzPVwie2F1dG9jb21wbGV0ZV9jbGFzc30gcHgtMiBweS0yIGhvdmVyOmJnLXB1cnBsZS01MDAgaG92ZXI6dGV4dC13aGl0ZSB0ZXh0LWJsYWNrIGZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIHRydW5jYXRlIGJnLXdoaXRlXCI+XG4gICAgICAgICAgPGltZyBjbGFzcz1cInJvdW5kZWQtZnVsbCBoLTggdy04XCIgc3JjPXtzdHJlYW1lci5wcm9maWxlX2ltYWdlX3VybH0gLz5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicHgtMlwiPjxzcGFuPntzdHJlYW1lci5fbGVmdH08L3NwYW4+PHNwYW4gY2xhc3M9XCJ0ZXh0LXJlZC01MDBcIj57c3RyZWFtZXIuX2NlbnRlcn08L3NwYW4+PHNwYW4+e3N0cmVhbWVyLl9yaWdodH08L3NwYW4+PC9kaXY+XG4gICAgICAgIDwvbGk+XG4gICAgICB7L2VhY2h9XG4gICAgey9pZn1cbiAgPC91bD5cbjwvZGl2PlxuXG5cbjxzdHlsZT5cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxREErRnFOLFVBQVU7Ozs7Ozs7Ozs7Ozs7OytFQUFWLFVBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBY2xOLGtCQUFrQjs7OztrQ0FBdkI7Ozs7OzttQ0FBQTs7Ozs7Ozs7bUNBQUE7Ozs7Ozs7O21DQUFBOzs7Ozs7Ozs7dUJBQUssa0JBQWtCOzs7aUNBQXZCOzs7Ozs7Ozs7Ozs7MkJBQUE7OztnQkFBQSxzQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBUksscUJBQXFCOzs7O2dDQUExQjs7Ozs7O21DQUFBOzs7Ozs7OzttQ0FBQTs7Ozs7Ozs7bUNBQUE7Ozs7Ozs7OztxQkFBSyxxQkFBcUI7OzsrQkFBMUI7Ozs7Ozs7Ozs7OzsyQkFBQTs7O2dCQUFBLG9CQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7NERBVzJCLFFBQVEsQ0FBQyxLQUFLLGlDQUFvQyxRQUFRLENBQUMsT0FBTyxpQ0FBZSxRQUFRLENBQUMsTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QUFNLENBQUMsQ0FBQztRQUM5QyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7T0FDN0M7O0dBRUo7RUFDRCxTQUFTLGVBQWUsQ0FBQyxDQUFDLEVBQUU7SUFDMUIsSUFBSSxPQUFPLEdBQUcsV0FBVyxDQUFDO0lBQzFCLEdBQUcsWUFBWSxJQUFJLE9BQU87TUFDeEIsT0FBTztJQUNULFlBQVksR0FBRyxPQUFPLENBQUM7SUFDdkIsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDO01BQ2xCLE1BQU0sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDNUI7U0FDSTtNQUNILEdBQUcsQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDO1NBQ3hCLElBQUksQ0FBQyxTQUFTLEVBQUU7VUFDZixNQUFNLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQzVCLENBQUMsQ0FBQztLQUNOO0dBQ0Y7RUFDRCxTQUFTLGFBQWEsQ0FBQyxRQUFRLEVBQUU7NkJBQy9CLFFBQVEsR0FBRyxTQUFRLENBQUM7a0NBQ3BCLGFBQWEsQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLG9CQUFJLENBQUM7SUFDcEMsYUFBYSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ3JCLHFDQUFxQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2hELGtCQUFrQixDQUFDLEVBQUUsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO0lBQzlDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztHQUNwQjtFQUNELFNBQVMsMEJBQTBCLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRTswQ0FDL0MscUJBQXFCLEdBQUcscUJBQXFCLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLFFBQVEsQ0FBQyxFQUFFLEVBQUMsQ0FBQztJQUM3RSxrQkFBa0IsQ0FBQyxFQUFFLEVBQUUscUJBQXFCLENBQUMsQ0FBQztJQUM5QyxLQUFLLEdBQUcsSUFBSSxDQUFDO0lBQ2IsT0FBTyxDQUFDLENBQUMsY0FBYyxFQUFFLElBQUksS0FBSyxDQUFDO0dBQ3BDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
